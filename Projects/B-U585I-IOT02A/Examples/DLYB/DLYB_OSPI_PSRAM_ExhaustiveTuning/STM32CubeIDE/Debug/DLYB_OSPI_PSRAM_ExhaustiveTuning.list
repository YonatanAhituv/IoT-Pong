
DLYB_OSPI_PSRAM_ExhaustiveTuning.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000238  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00006adc  08000238  08000238  00010238  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000225  08006d14  08006d14  00016d14  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08006f3c  08006f3c  00016f3c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08006f40  08006f40  00016f40  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000078  20000000  08006f44  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00001298  20000078  08006fbc  00020078  2**2
                  ALLOC
  7 ._user_heap_stack 00000600  20001310  08006fbc  00021310  2**0
                  ALLOC
  8 .ARM.attributes 00000036  00000000  00000000  00020078  2**0
                  CONTENTS, READONLY
  9 .comment      00000043  00000000  00000000  000200ae  2**0
                  CONTENTS, READONLY
 10 .debug_line   0000f222  00000000  00000000  000200f1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line_str 000000bc  00000000  00000000  0002f313  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_info   0000e5d4  00000000  00000000  0002f3cf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00002376  00000000  00000000  0003d9a3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00000be0  00000000  00000000  0003fd20  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    00138d3c  00000000  00000000  00040900  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 000008e5  00000000  00000000  0017963c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  000326c8  00000000  00000000  00179f21  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_frame  00003ac4  00000000  00000000  001ac5ec  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000238 <__do_global_dtors_aux>:
 8000238:	b510      	push	{r4, lr}
 800023a:	4c05      	ldr	r4, [pc, #20]	; (8000250 <__do_global_dtors_aux+0x18>)
 800023c:	7823      	ldrb	r3, [r4, #0]
 800023e:	b933      	cbnz	r3, 800024e <__do_global_dtors_aux+0x16>
 8000240:	4b04      	ldr	r3, [pc, #16]	; (8000254 <__do_global_dtors_aux+0x1c>)
 8000242:	b113      	cbz	r3, 800024a <__do_global_dtors_aux+0x12>
 8000244:	4804      	ldr	r0, [pc, #16]	; (8000258 <__do_global_dtors_aux+0x20>)
 8000246:	f3af 8000 	nop.w
 800024a:	2301      	movs	r3, #1
 800024c:	7023      	strb	r3, [r4, #0]
 800024e:	bd10      	pop	{r4, pc}
 8000250:	20000078 	.word	0x20000078
 8000254:	00000000 	.word	0x00000000
 8000258:	08006cfc 	.word	0x08006cfc

0800025c <frame_dummy>:
 800025c:	b508      	push	{r3, lr}
 800025e:	4b03      	ldr	r3, [pc, #12]	; (800026c <frame_dummy+0x10>)
 8000260:	b11b      	cbz	r3, 800026a <frame_dummy+0xe>
 8000262:	4903      	ldr	r1, [pc, #12]	; (8000270 <frame_dummy+0x14>)
 8000264:	4803      	ldr	r0, [pc, #12]	; (8000274 <frame_dummy+0x18>)
 8000266:	f3af 8000 	nop.w
 800026a:	bd08      	pop	{r3, pc}
 800026c:	00000000 	.word	0x00000000
 8000270:	2000007c 	.word	0x2000007c
 8000274:	08006cfc 	.word	0x08006cfc

08000278 <strlen>:
 8000278:	4603      	mov	r3, r0
 800027a:	f813 2b01 	ldrb.w	r2, [r3], #1
 800027e:	2a00      	cmp	r2, #0
 8000280:	d1fb      	bne.n	800027a <strlen+0x2>
 8000282:	1a18      	subs	r0, r3, r0
 8000284:	3801      	subs	r0, #1
 8000286:	4770      	bx	lr

08000288 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* set stack pointer */
 8000288:	f8df d034 	ldr.w	sp, [pc, #52]	; 80002c0 <LoopForever+0x2>
/* Call the clock system initialization function.*/
  bl  SystemInit
 800028c:	f000 fe14 	bl	8000eb8 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8000290:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8000292:	e003      	b.n	800029c <LoopCopyDataInit>

08000294 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8000294:	4b0b      	ldr	r3, [pc, #44]	; (80002c4 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 8000296:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8000298:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 800029a:	3104      	adds	r1, #4

0800029c <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 800029c:	480a      	ldr	r0, [pc, #40]	; (80002c8 <LoopForever+0xa>)
	ldr	r3, =_edata
 800029e:	4b0b      	ldr	r3, [pc, #44]	; (80002cc <LoopForever+0xe>)
	adds	r2, r0, r1
 80002a0:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 80002a2:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 80002a4:	d3f6      	bcc.n	8000294 <CopyDataInit>
	ldr	r2, =_sbss
 80002a6:	4a0a      	ldr	r2, [pc, #40]	; (80002d0 <LoopForever+0x12>)
	b	LoopFillZerobss
 80002a8:	e002      	b.n	80002b0 <LoopFillZerobss>

080002aa <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 80002aa:	2300      	movs	r3, #0
	str	r3, [r2], #4
 80002ac:	f842 3b04 	str.w	r3, [r2], #4

080002b0 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 80002b0:	4b08      	ldr	r3, [pc, #32]	; (80002d4 <LoopForever+0x16>)
	cmp	r2, r3
 80002b2:	429a      	cmp	r2, r3
	bcc	FillZerobss
 80002b4:	d3f9      	bcc.n	80002aa <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 80002b6:	f005 fc1f 	bl	8005af8 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 80002ba:	f000 f80f 	bl	80002dc <main>

080002be <LoopForever>:

LoopForever:
    b LoopForever
 80002be:	e7fe      	b.n	80002be <LoopForever>
  ldr   sp, =_estack    /* set stack pointer */
 80002c0:	200c0000 	.word	0x200c0000
	ldr	r3, =_sidata
 80002c4:	08006f44 	.word	0x08006f44
	ldr	r0, =_sdata
 80002c8:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 80002cc:	20000078 	.word	0x20000078
	ldr	r2, =_sbss
 80002d0:	20000078 	.word	0x20000078
	ldr	r3, = _ebss
 80002d4:	20001310 	.word	0x20001310

080002d8 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 80002d8:	e7fe      	b.n	80002d8 <ADC1_IRQHandler>
	...

080002dc <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 80002dc:	b580      	push	{r7, lr}
 80002de:	b096      	sub	sp, #88	; 0x58
 80002e0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 1 */
#if defined(__GNUC__) && !defined(__ARMCC_VERSION)
  initialise_monitor_handles();	/*rtt*/
 80002e2:	f006 fc8f 	bl	8006c04 <initialise_monitor_handles>
  printf("Semihosting Test...\n\r");
 80002e6:	48a8      	ldr	r0, [pc, #672]	; (8000588 <main+0x2ac>)
 80002e8:	f005 fb8a 	bl	8005a00 <iprintf>
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 80002ec:	f000 fe1c 	bl	8000f28 <HAL_Init>

  /* USER CODE BEGIN Init */
  uint16_t index;
  OSPI_RegularCmdTypeDef sCommand = {0};
 80002f0:	1d3b      	adds	r3, r7, #4
 80002f2:	2250      	movs	r2, #80	; 0x50
 80002f4:	2100      	movs	r1, #0
 80002f6:	4618      	mov	r0, r3
 80002f8:	f005 fbf0 	bl	8005adc <memset>
  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 80002fc:	f000 f962 	bl	80005c4 <SystemClock_Config>

  /* Configure the System Power */
  SystemPower_Config();
 8000300:	f000 f9bc 	bl	800067c <SystemPower_Config>

  /* USER CODE BEGIN SysInit */
  /* Configure LED6, LED7 */
  BSP_LED_Init(LED6);
 8000304:	2000      	movs	r0, #0
 8000306:	f000 fd2b 	bl	8000d60 <BSP_LED_Init>
  BSP_LED_Init(LED7);
 800030a:	2001      	movs	r0, #1
 800030c:	f000 fd28 	bl	8000d60 <BSP_LED_Init>

  /* Turn LED6, LED7 off */
  BSP_LED_Off(LED6);
 8000310:	2000      	movs	r0, #0
 8000312:	f000 fd95 	bl	8000e40 <BSP_LED_Off>
  BSP_LED_Off(LED7);
 8000316:	2001      	movs	r0, #1
 8000318:	f000 fd92 	bl	8000e40 <BSP_LED_Off>

  /*fill aTxBuffer */
  for (index = 0; index < BUFFER_LENGTH; index++)
 800031c:	2300      	movs	r3, #0
 800031e:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
 8000322:	e00b      	b.n	800033c <main+0x60>
  {
    TX_Buffer[index] = index;
 8000324:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
 8000328:	f8b7 2056 	ldrh.w	r2, [r7, #86]	; 0x56
 800032c:	b2d1      	uxtb	r1, r2
 800032e:	4a97      	ldr	r2, [pc, #604]	; (800058c <main+0x2b0>)
 8000330:	54d1      	strb	r1, [r2, r3]
  for (index = 0; index < BUFFER_LENGTH; index++)
 8000332:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
 8000336:	3301      	adds	r3, #1
 8000338:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
 800033c:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
 8000340:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8000344:	d3ee      	bcc.n	8000324 <main+0x48>
  }
  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8000346:	f000 fa37 	bl	80007b8 <MX_GPIO_Init>
  MX_ICACHE_Init();
 800034a:	f000 f9a5 	bl	8000698 <MX_ICACHE_Init>
  MX_OCTOSPI1_Init();
 800034e:	f000 f9b7 	bl	80006c0 <MX_OCTOSPI1_Init>
  /* USER CODE BEGIN 2 */
  /*  Writing Sequence ------------------------------------------------ */
  sCommand.OperationType      = HAL_OSPI_OPTYPE_COMMON_CFG;
 8000352:	2300      	movs	r3, #0
 8000354:	607b      	str	r3, [r7, #4]
  sCommand.FlashId            = HAL_OSPI_FLASH_ID_1;
 8000356:	2300      	movs	r3, #0
 8000358:	60bb      	str	r3, [r7, #8]
  sCommand.InstructionMode    = HAL_OSPI_INSTRUCTION_8_LINES;
 800035a:	2304      	movs	r3, #4
 800035c:	613b      	str	r3, [r7, #16]
  sCommand.InstructionSize    = HAL_OSPI_INSTRUCTION_8_BITS;
 800035e:	2300      	movs	r3, #0
 8000360:	617b      	str	r3, [r7, #20]
  sCommand.InstructionDtrMode = HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 8000362:	2300      	movs	r3, #0
 8000364:	61bb      	str	r3, [r7, #24]
  sCommand.AddressMode        = HAL_OSPI_ADDRESS_8_LINES;
 8000366:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800036a:	623b      	str	r3, [r7, #32]
  sCommand.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 800036c:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 8000370:	627b      	str	r3, [r7, #36]	; 0x24
  sCommand.AddressDtrMode     = HAL_OSPI_ADDRESS_DTR_ENABLE;
 8000372:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8000376:	62bb      	str	r3, [r7, #40]	; 0x28
  sCommand.AlternateBytesMode = HAL_OSPI_ALTERNATE_BYTES_NONE;
 8000378:	2300      	movs	r3, #0
 800037a:	633b      	str	r3, [r7, #48]	; 0x30
  sCommand.DataMode           = HAL_OSPI_DATA_8_LINES;
 800037c:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8000380:	63fb      	str	r3, [r7, #60]	; 0x3c
  sCommand.DataDtrMode        = HAL_OSPI_DATA_DTR_ENABLE;
 8000382:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000386:	647b      	str	r3, [r7, #68]	; 0x44
  sCommand.DQSMode            = HAL_OSPI_DQS_ENABLE;
 8000388:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 800038c:	64fb      	str	r3, [r7, #76]	; 0x4c
  sCommand.SIOOMode           = HAL_OSPI_SIOO_INST_EVERY_CMD;
 800038e:	2300      	movs	r3, #0
 8000390:	653b      	str	r3, [r7, #80]	; 0x50
  sCommand.Instruction        = WRITE_CMD;
 8000392:	2380      	movs	r3, #128	; 0x80
 8000394:	60fb      	str	r3, [r7, #12]
  sCommand.Address            = 0x0;
 8000396:	2300      	movs	r3, #0
 8000398:	61fb      	str	r3, [r7, #28]
  sCommand.NbData             = BUFFER_LENGTH;
 800039a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800039e:	643b      	str	r3, [r7, #64]	; 0x40
  sCommand.DummyCycles        = DUMMY_CLOCK_CYCLES_WRITE;
 80003a0:	2304      	movs	r3, #4
 80003a2:	64bb      	str	r3, [r7, #72]	; 0x48

  if (HAL_OSPI_Command(&hospi1, &sCommand, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80003a4:	1d3b      	adds	r3, r7, #4
 80003a6:	f241 3288 	movw	r2, #5000	; 0x1388
 80003aa:	4619      	mov	r1, r3
 80003ac:	4878      	ldr	r0, [pc, #480]	; (8000590 <main+0x2b4>)
 80003ae:	f001 fd97 	bl	8001ee0 <HAL_OSPI_Command>
 80003b2:	4603      	mov	r3, r0
 80003b4:	2b00      	cmp	r3, #0
 80003b6:	d001      	beq.n	80003bc <main+0xe0>
  {
    Error_Handler();
 80003b8:	f000 fa72 	bl	80008a0 <Error_Handler>
  }

  if (HAL_OSPI_Transmit(&hospi1, TX_Buffer, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80003bc:	f241 3288 	movw	r2, #5000	; 0x1388
 80003c0:	4972      	ldr	r1, [pc, #456]	; (800058c <main+0x2b0>)
 80003c2:	4873      	ldr	r0, [pc, #460]	; (8000590 <main+0x2b4>)
 80003c4:	f001 fe19 	bl	8001ffa <HAL_OSPI_Transmit>
 80003c8:	4603      	mov	r3, r0
 80003ca:	2b00      	cmp	r3, #0
 80003cc:	d001      	beq.n	80003d2 <main+0xf6>
  {
    Error_Handler();
 80003ce:	f000 fa67 	bl	80008a0 <Error_Handler>
  }

  /*  Tuning Sequence ------------------------------------------------ */
  //StartTest();
  printf(" ###################### Start Tuning ######################### \n");
 80003d2:	4870      	ldr	r0, [pc, #448]	; (8000594 <main+0x2b8>)
 80003d4:	f005 fb7a 	bl	8005acc <puts>
  for( jj=0; jj<(DLYB_MAX_SELECT*DLYB_MAX_UNIT); jj++ )
 80003d8:	4b6f      	ldr	r3, [pc, #444]	; (8000598 <main+0x2bc>)
 80003da:	2200      	movs	r2, #0
 80003dc:	601a      	str	r2, [r3, #0]
 80003de:	e0c6      	b.n	800056e <main+0x292>
  {
    ko=0;/*it will mentions if test is ok or not*/
 80003e0:	4b6e      	ldr	r3, [pc, #440]	; (800059c <main+0x2c0>)
 80003e2:	2200      	movs	r2, #0
 80003e4:	601a      	str	r2, [r3, #0]

    /* Search the combination SEL / UNIT to obtain the total delay jj*/
    for( sel=1; sel<(DLYB_MAX_SELECT+1); sel++ )
 80003e6:	4b6e      	ldr	r3, [pc, #440]	; (80005a0 <main+0x2c4>)
 80003e8:	2201      	movs	r2, #1
 80003ea:	601a      	str	r2, [r3, #0]
 80003ec:	e020      	b.n	8000430 <main+0x154>
    {
      if( ((jj%sel)==0) && ((jj/sel)<DLYB_MAX_UNIT) )
 80003ee:	4b6a      	ldr	r3, [pc, #424]	; (8000598 <main+0x2bc>)
 80003f0:	681b      	ldr	r3, [r3, #0]
 80003f2:	4a6b      	ldr	r2, [pc, #428]	; (80005a0 <main+0x2c4>)
 80003f4:	6812      	ldr	r2, [r2, #0]
 80003f6:	fbb3 f1f2 	udiv	r1, r3, r2
 80003fa:	fb01 f202 	mul.w	r2, r1, r2
 80003fe:	1a9b      	subs	r3, r3, r2
 8000400:	2b00      	cmp	r3, #0
 8000402:	d110      	bne.n	8000426 <main+0x14a>
 8000404:	4b64      	ldr	r3, [pc, #400]	; (8000598 <main+0x2bc>)
 8000406:	681a      	ldr	r2, [r3, #0]
 8000408:	4b65      	ldr	r3, [pc, #404]	; (80005a0 <main+0x2c4>)
 800040a:	681b      	ldr	r3, [r3, #0]
 800040c:	fbb2 f3f3 	udiv	r3, r2, r3
 8000410:	2b7f      	cmp	r3, #127	; 0x7f
 8000412:	d808      	bhi.n	8000426 <main+0x14a>
      {
        unit = jj/sel;
 8000414:	4b60      	ldr	r3, [pc, #384]	; (8000598 <main+0x2bc>)
 8000416:	681a      	ldr	r2, [r3, #0]
 8000418:	4b61      	ldr	r3, [pc, #388]	; (80005a0 <main+0x2c4>)
 800041a:	681b      	ldr	r3, [r3, #0]
 800041c:	fbb2 f3f3 	udiv	r3, r2, r3
 8000420:	4a60      	ldr	r2, [pc, #384]	; (80005a4 <main+0x2c8>)
 8000422:	6013      	str	r3, [r2, #0]
        break;
 8000424:	e008      	b.n	8000438 <main+0x15c>
    for( sel=1; sel<(DLYB_MAX_SELECT+1); sel++ )
 8000426:	4b5e      	ldr	r3, [pc, #376]	; (80005a0 <main+0x2c4>)
 8000428:	681b      	ldr	r3, [r3, #0]
 800042a:	3301      	adds	r3, #1
 800042c:	4a5c      	ldr	r2, [pc, #368]	; (80005a0 <main+0x2c4>)
 800042e:	6013      	str	r3, [r2, #0]
 8000430:	4b5b      	ldr	r3, [pc, #364]	; (80005a0 <main+0x2c4>)
 8000432:	681b      	ldr	r3, [r3, #0]
 8000434:	2b0c      	cmp	r3, #12
 8000436:	d9da      	bls.n	80003ee <main+0x112>
      }
    }
    if( sel==(DLYB_MAX_SELECT+1) ) continue;  /* value not reachable */
 8000438:	4b59      	ldr	r3, [pc, #356]	; (80005a0 <main+0x2c4>)
 800043a:	681b      	ldr	r3, [r3, #0]
 800043c:	2b0d      	cmp	r3, #13
 800043e:	f000 8090 	beq.w	8000562 <main+0x286>

    /* Delay Block Configuration */
    dlyb_cfg.PhaseSel =sel;
 8000442:	4b57      	ldr	r3, [pc, #348]	; (80005a0 <main+0x2c4>)
 8000444:	681b      	ldr	r3, [r3, #0]
 8000446:	4a58      	ldr	r2, [pc, #352]	; (80005a8 <main+0x2cc>)
 8000448:	6053      	str	r3, [r2, #4]
    dlyb_cfg.Units =unit;
 800044a:	4b56      	ldr	r3, [pc, #344]	; (80005a4 <main+0x2c8>)
 800044c:	681b      	ldr	r3, [r3, #0]
 800044e:	4a56      	ldr	r2, [pc, #344]	; (80005a8 <main+0x2cc>)
 8000450:	6013      	str	r3, [r2, #0]

    /* DeInit OCTOSPI ------------------------------------------------ */
    HAL_OSPI_DeInit(&hospi1);
 8000452:	484f      	ldr	r0, [pc, #316]	; (8000590 <main+0x2b4>)
 8000454:	f001 fbda 	bl	8001c0c <HAL_OSPI_DeInit>

    /* Re-init octospi to clear communication configuration */
    MX_OCTOSPI1_Init();
 8000458:	f000 f932 	bl	80006c0 <MX_OCTOSPI1_Init>

    /*Set Delay Block configuration*/
    HAL_OSPI_DLYB_SetConfig(&hospi1,&dlyb_cfg);
 800045c:	4952      	ldr	r1, [pc, #328]	; (80005a8 <main+0x2cc>)
 800045e:	484c      	ldr	r0, [pc, #304]	; (8000590 <main+0x2b4>)
 8000460:	f002 ff58 	bl	8003314 <HAL_OSPI_DLYB_SetConfig>

    /* Reading Sequence (repeating 100 time read operation) ------------------ */
    for(k=0;k<100;k++)
 8000464:	4b51      	ldr	r3, [pc, #324]	; (80005ac <main+0x2d0>)
 8000466:	2200      	movs	r2, #0
 8000468:	601a      	str	r2, [r3, #0]
 800046a:	e058      	b.n	800051e <main+0x242>
    {
      for( ii=BUFFER_LENGTH; ii>0; ii-- )
 800046c:	4b50      	ldr	r3, [pc, #320]	; (80005b0 <main+0x2d4>)
 800046e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8000472:	601a      	str	r2, [r3, #0]
 8000474:	e00a      	b.n	800048c <main+0x1b0>
      {RX_Buffer[ii-1] =0;}
 8000476:	4b4e      	ldr	r3, [pc, #312]	; (80005b0 <main+0x2d4>)
 8000478:	681b      	ldr	r3, [r3, #0]
 800047a:	3b01      	subs	r3, #1
 800047c:	4a4d      	ldr	r2, [pc, #308]	; (80005b4 <main+0x2d8>)
 800047e:	2100      	movs	r1, #0
 8000480:	54d1      	strb	r1, [r2, r3]
      for( ii=BUFFER_LENGTH; ii>0; ii-- )
 8000482:	4b4b      	ldr	r3, [pc, #300]	; (80005b0 <main+0x2d4>)
 8000484:	681b      	ldr	r3, [r3, #0]
 8000486:	3b01      	subs	r3, #1
 8000488:	4a49      	ldr	r2, [pc, #292]	; (80005b0 <main+0x2d4>)
 800048a:	6013      	str	r3, [r2, #0]
 800048c:	4b48      	ldr	r3, [pc, #288]	; (80005b0 <main+0x2d4>)
 800048e:	681b      	ldr	r3, [r3, #0]
 8000490:	2b00      	cmp	r3, #0
 8000492:	d1f0      	bne.n	8000476 <main+0x19a>


      sCommand.Instruction = READ_CMD;
 8000494:	2300      	movs	r3, #0
 8000496:	60fb      	str	r3, [r7, #12]
      sCommand.DummyCycles = DUMMY_CLOCK_CYCLES_READ;
 8000498:	2305      	movs	r3, #5
 800049a:	64bb      	str	r3, [r7, #72]	; 0x48
      sCommand.DQSMode     = HAL_OSPI_DQS_ENABLE;
 800049c:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 80004a0:	64fb      	str	r3, [r7, #76]	; 0x4c

      if (HAL_OSPI_Command(&hospi1, &sCommand, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80004a2:	1d3b      	adds	r3, r7, #4
 80004a4:	f241 3288 	movw	r2, #5000	; 0x1388
 80004a8:	4619      	mov	r1, r3
 80004aa:	4839      	ldr	r0, [pc, #228]	; (8000590 <main+0x2b4>)
 80004ac:	f001 fd18 	bl	8001ee0 <HAL_OSPI_Command>
 80004b0:	4603      	mov	r3, r0
 80004b2:	2b00      	cmp	r3, #0
 80004b4:	d001      	beq.n	80004ba <main+0x1de>
      {
        Error_Handler();
 80004b6:	f000 f9f3 	bl	80008a0 <Error_Handler>
      }

      if (HAL_OSPI_Receive(&hospi1, RX_Buffer, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80004ba:	f241 3288 	movw	r2, #5000	; 0x1388
 80004be:	493d      	ldr	r1, [pc, #244]	; (80005b4 <main+0x2d8>)
 80004c0:	4833      	ldr	r0, [pc, #204]	; (8000590 <main+0x2b4>)
 80004c2:	f001 fe0d 	bl	80020e0 <HAL_OSPI_Receive>
 80004c6:	4603      	mov	r3, r0
 80004c8:	2b00      	cmp	r3, #0
 80004ca:	d005      	beq.n	80004d8 <main+0x1fc>
      {
        ko ++;
 80004cc:	4b33      	ldr	r3, [pc, #204]	; (800059c <main+0x2c0>)
 80004ce:	681b      	ldr	r3, [r3, #0]
 80004d0:	3301      	adds	r3, #1
 80004d2:	4a32      	ldr	r2, [pc, #200]	; (800059c <main+0x2c0>)
 80004d4:	6013      	str	r3, [r2, #0]
        break;
 80004d6:	e026      	b.n	8000526 <main+0x24a>
      }

      /* 3- Result comparison ----------------------------------------------- */
      for (index = 0; index < BUFFER_LENGTH; index++)
 80004d8:	2300      	movs	r3, #0
 80004da:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
 80004de:	e014      	b.n	800050a <main+0x22e>
      {
        if (RX_Buffer[index] != TX_Buffer[index])
 80004e0:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
 80004e4:	4a33      	ldr	r2, [pc, #204]	; (80005b4 <main+0x2d8>)
 80004e6:	5cd2      	ldrb	r2, [r2, r3]
 80004e8:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
 80004ec:	4927      	ldr	r1, [pc, #156]	; (800058c <main+0x2b0>)
 80004ee:	5ccb      	ldrb	r3, [r1, r3]
 80004f0:	429a      	cmp	r2, r3
 80004f2:	d005      	beq.n	8000500 <main+0x224>
        {
          ko ++;
 80004f4:	4b29      	ldr	r3, [pc, #164]	; (800059c <main+0x2c0>)
 80004f6:	681b      	ldr	r3, [r3, #0]
 80004f8:	3301      	adds	r3, #1
 80004fa:	4a28      	ldr	r2, [pc, #160]	; (800059c <main+0x2c0>)
 80004fc:	6013      	str	r3, [r2, #0]
          break;
 80004fe:	e009      	b.n	8000514 <main+0x238>
      for (index = 0; index < BUFFER_LENGTH; index++)
 8000500:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
 8000504:	3301      	adds	r3, #1
 8000506:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
 800050a:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
 800050e:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8000512:	d3e5      	bcc.n	80004e0 <main+0x204>
    for(k=0;k<100;k++)
 8000514:	4b25      	ldr	r3, [pc, #148]	; (80005ac <main+0x2d0>)
 8000516:	681b      	ldr	r3, [r3, #0]
 8000518:	3301      	adds	r3, #1
 800051a:	4a24      	ldr	r2, [pc, #144]	; (80005ac <main+0x2d0>)
 800051c:	6013      	str	r3, [r2, #0]
 800051e:	4b23      	ldr	r3, [pc, #140]	; (80005ac <main+0x2d0>)
 8000520:	681b      	ldr	r3, [r3, #0]
 8000522:	2b63      	cmp	r3, #99	; 0x63
 8000524:	d9a2      	bls.n	800046c <main+0x190>
        }
      }
    }

    /* Toggle Green led, Tuning is processing-------------------------------- */
    BSP_LED_Toggle(LED7);
 8000526:	2001      	movs	r0, #1
 8000528:	f000 fca8 	bl	8000e7c <BSP_LED_Toggle>
    HAL_Delay (10);
 800052c:	200a      	movs	r0, #10
 800052e:	f000 fd7f 	bl	8001030 <HAL_Delay>

    /* Print Result --------------------------------------------------------- */
    if (ko>0)
 8000532:	4b1a      	ldr	r3, [pc, #104]	; (800059c <main+0x2c0>)
 8000534:	681b      	ldr	r3, [r3, #0]
 8000536:	2b00      	cmp	r3, #0
 8000538:	d009      	beq.n	800054e <main+0x272>
    {
      printf (" delay= %u, Sel = %u , Unit = %u , Test FAILED \n",jj, sel, unit);
 800053a:	4b17      	ldr	r3, [pc, #92]	; (8000598 <main+0x2bc>)
 800053c:	6819      	ldr	r1, [r3, #0]
 800053e:	4b18      	ldr	r3, [pc, #96]	; (80005a0 <main+0x2c4>)
 8000540:	681a      	ldr	r2, [r3, #0]
 8000542:	4b18      	ldr	r3, [pc, #96]	; (80005a4 <main+0x2c8>)
 8000544:	681b      	ldr	r3, [r3, #0]
 8000546:	481c      	ldr	r0, [pc, #112]	; (80005b8 <main+0x2dc>)
 8000548:	f005 fa5a 	bl	8005a00 <iprintf>
 800054c:	e00a      	b.n	8000564 <main+0x288>
    }
    else
    {
      printf (" delay= %u, Sel = %u , Unit = %u , Test PASSED \n",jj, sel, unit);
 800054e:	4b12      	ldr	r3, [pc, #72]	; (8000598 <main+0x2bc>)
 8000550:	6819      	ldr	r1, [r3, #0]
 8000552:	4b13      	ldr	r3, [pc, #76]	; (80005a0 <main+0x2c4>)
 8000554:	681a      	ldr	r2, [r3, #0]
 8000556:	4b13      	ldr	r3, [pc, #76]	; (80005a4 <main+0x2c8>)
 8000558:	681b      	ldr	r3, [r3, #0]
 800055a:	4818      	ldr	r0, [pc, #96]	; (80005bc <main+0x2e0>)
 800055c:	f005 fa50 	bl	8005a00 <iprintf>
 8000560:	e000      	b.n	8000564 <main+0x288>
    if( sel==(DLYB_MAX_SELECT+1) ) continue;  /* value not reachable */
 8000562:	bf00      	nop
  for( jj=0; jj<(DLYB_MAX_SELECT*DLYB_MAX_UNIT); jj++ )
 8000564:	4b0c      	ldr	r3, [pc, #48]	; (8000598 <main+0x2bc>)
 8000566:	681b      	ldr	r3, [r3, #0]
 8000568:	3301      	adds	r3, #1
 800056a:	4a0b      	ldr	r2, [pc, #44]	; (8000598 <main+0x2bc>)
 800056c:	6013      	str	r3, [r2, #0]
 800056e:	4b0a      	ldr	r3, [pc, #40]	; (8000598 <main+0x2bc>)
 8000570:	681b      	ldr	r3, [r3, #0]
 8000572:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8000576:	f4ff af33 	bcc.w	80003e0 <main+0x104>
    }
  }

  /* End Tuning------------------------------------------------ */
  printf (" ###################### End Tuning #########################\n");
 800057a:	4811      	ldr	r0, [pc, #68]	; (80005c0 <main+0x2e4>)
 800057c:	f005 faa6 	bl	8005acc <puts>
  BSP_LED_On(LED7);
 8000580:	2001      	movs	r0, #1
 8000582:	f000 fc3f 	bl	8000e04 <BSP_LED_On>
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 8000586:	e7fe      	b.n	8000586 <main+0x2aa>
 8000588:	08006d14 	.word	0x08006d14
 800058c:	20000110 	.word	0x20000110
 8000590:	20000094 	.word	0x20000094
 8000594:	08006d2c 	.word	0x08006d2c
 8000598:	20000108 	.word	0x20000108
 800059c:	200000f8 	.word	0x200000f8
 80005a0:	20000100 	.word	0x20000100
 80005a4:	20000104 	.word	0x20000104
 80005a8:	200000f0 	.word	0x200000f0
 80005ac:	200000fc 	.word	0x200000fc
 80005b0:	2000010c 	.word	0x2000010c
 80005b4:	20000910 	.word	0x20000910
 80005b8:	08006d6c 	.word	0x08006d6c
 80005bc:	08006da0 	.word	0x08006da0
 80005c0:	08006dd4 	.word	0x08006dd4

080005c4 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80005c4:	b580      	push	{r7, lr}
 80005c6:	b09e      	sub	sp, #120	; 0x78
 80005c8:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80005ca:	f107 0318 	add.w	r3, r7, #24
 80005ce:	2260      	movs	r2, #96	; 0x60
 80005d0:	2100      	movs	r1, #0
 80005d2:	4618      	mov	r0, r3
 80005d4:	f005 fa82 	bl	8005adc <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80005d8:	463b      	mov	r3, r7
 80005da:	2200      	movs	r2, #0
 80005dc:	601a      	str	r2, [r3, #0]
 80005de:	605a      	str	r2, [r3, #4]
 80005e0:	609a      	str	r2, [r3, #8]
 80005e2:	60da      	str	r2, [r3, #12]
 80005e4:	611a      	str	r2, [r3, #16]
 80005e6:	615a      	str	r2, [r3, #20]

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
 80005e8:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 80005ec:	f002 feda 	bl	80033a4 <HAL_PWREx_ControlVoltageScaling>
 80005f0:	4603      	mov	r3, r0
 80005f2:	2b00      	cmp	r3, #0
 80005f4:	d001      	beq.n	80005fa <SystemClock_Config+0x36>
  {
    Error_Handler();
 80005f6:	f000 f953 	bl	80008a0 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
 80005fa:	2310      	movs	r3, #16
 80005fc:	61bb      	str	r3, [r7, #24]
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 80005fe:	2301      	movs	r3, #1
 8000600:	637b      	str	r3, [r7, #52]	; 0x34
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 8000602:	2310      	movs	r3, #16
 8000604:	63bb      	str	r3, [r7, #56]	; 0x38
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_4;
 8000606:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800060a:	63fb      	str	r3, [r7, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800060c:	2302      	movs	r3, #2
 800060e:	653b      	str	r3, [r7, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
 8000610:	2301      	movs	r3, #1
 8000612:	657b      	str	r3, [r7, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLMBOOST = RCC_PLLMBOOST_DIV1;
 8000614:	2300      	movs	r3, #0
 8000616:	65fb      	str	r3, [r7, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLM = 1;
 8000618:	2301      	movs	r3, #1
 800061a:	65bb      	str	r3, [r7, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLN = 80;
 800061c:	2350      	movs	r3, #80	; 0x50
 800061e:	663b      	str	r3, [r7, #96]	; 0x60
  RCC_OscInitStruct.PLL.PLLP = 2;
 8000620:	2302      	movs	r3, #2
 8000622:	667b      	str	r3, [r7, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLQ = 2;
 8000624:	2302      	movs	r3, #2
 8000626:	66bb      	str	r3, [r7, #104]	; 0x68
  RCC_OscInitStruct.PLL.PLLR = 2;
 8000628:	2302      	movs	r3, #2
 800062a:	66fb      	str	r3, [r7, #108]	; 0x6c
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLLVCIRANGE_0;
 800062c:	2300      	movs	r3, #0
 800062e:	673b      	str	r3, [r7, #112]	; 0x70
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
 8000630:	2300      	movs	r3, #0
 8000632:	677b      	str	r3, [r7, #116]	; 0x74
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000634:	f107 0318 	add.w	r3, r7, #24
 8000638:	4618      	mov	r0, r3
 800063a:	f002 ff9f 	bl	800357c <HAL_RCC_OscConfig>
 800063e:	4603      	mov	r3, r0
 8000640:	2b00      	cmp	r3, #0
 8000642:	d001      	beq.n	8000648 <SystemClock_Config+0x84>
  {
    Error_Handler();
 8000644:	f000 f92c 	bl	80008a0 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000648:	231f      	movs	r3, #31
 800064a:	603b      	str	r3, [r7, #0]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_PCLK3;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800064c:	2303      	movs	r3, #3
 800064e:	607b      	str	r3, [r7, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000650:	2300      	movs	r3, #0
 8000652:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8000654:	2300      	movs	r3, #0
 8000656:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000658:	2300      	movs	r3, #0
 800065a:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB3CLKDivider = RCC_HCLK_DIV1;
 800065c:	2300      	movs	r3, #0
 800065e:	617b      	str	r3, [r7, #20]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8000660:	463b      	mov	r3, r7
 8000662:	2104      	movs	r1, #4
 8000664:	4618      	mov	r0, r3
 8000666:	f003 fe65 	bl	8004334 <HAL_RCC_ClockConfig>
 800066a:	4603      	mov	r3, r0
 800066c:	2b00      	cmp	r3, #0
 800066e:	d001      	beq.n	8000674 <SystemClock_Config+0xb0>
  {
    Error_Handler();
 8000670:	f000 f916 	bl	80008a0 <Error_Handler>
  }
}
 8000674:	bf00      	nop
 8000676:	3778      	adds	r7, #120	; 0x78
 8000678:	46bd      	mov	sp, r7
 800067a:	bd80      	pop	{r7, pc}

0800067c <SystemPower_Config>:
/**
  * @brief Power Configuration
  * @retval None
  */
static void SystemPower_Config(void)
{
 800067c:	b580      	push	{r7, lr}
 800067e:	af00      	add	r7, sp, #0

  /*
   * Disable the internal Pull-Up in Dead Battery pins of UCPD peripheral
   */
  HAL_PWREx_DisableUCPDDeadBattery();
 8000680:	f002 ff6c 	bl	800355c <HAL_PWREx_DisableUCPDDeadBattery>

  /*
   * Switch to SMPS regulator instead of LDO
   */
  if (HAL_PWREx_ConfigSupply(PWR_SMPS_SUPPLY) != HAL_OK)
 8000684:	2002      	movs	r0, #2
 8000686:	f002 ff19 	bl	80034bc <HAL_PWREx_ConfigSupply>
 800068a:	4603      	mov	r3, r0
 800068c:	2b00      	cmp	r3, #0
 800068e:	d001      	beq.n	8000694 <SystemPower_Config+0x18>
  {
    Error_Handler();
 8000690:	f000 f906 	bl	80008a0 <Error_Handler>
  }
/* USER CODE BEGIN PWR */
/* USER CODE END PWR */
}
 8000694:	bf00      	nop
 8000696:	bd80      	pop	{r7, pc}

08000698 <MX_ICACHE_Init>:
  * @brief ICACHE Initialization Function
  * @param None
  * @retval None
  */
static void MX_ICACHE_Init(void)
{
 8000698:	b580      	push	{r7, lr}
 800069a:	af00      	add	r7, sp, #0

  /* USER CODE END ICACHE_Init 1 */

  /** Enable instruction cache in 1-way (direct mapped cache)
  */
  if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
 800069c:	2000      	movs	r0, #0
 800069e:	f001 f9b9 	bl	8001a14 <HAL_ICACHE_ConfigAssociativityMode>
 80006a2:	4603      	mov	r3, r0
 80006a4:	2b00      	cmp	r3, #0
 80006a6:	d001      	beq.n	80006ac <MX_ICACHE_Init+0x14>
  {
    Error_Handler();
 80006a8:	f000 f8fa 	bl	80008a0 <Error_Handler>
  }
  if (HAL_ICACHE_Enable() != HAL_OK)
 80006ac:	f001 f9d2 	bl	8001a54 <HAL_ICACHE_Enable>
 80006b0:	4603      	mov	r3, r0
 80006b2:	2b00      	cmp	r3, #0
 80006b4:	d001      	beq.n	80006ba <MX_ICACHE_Init+0x22>
  {
    Error_Handler();
 80006b6:	f000 f8f3 	bl	80008a0 <Error_Handler>
  }
  /* USER CODE BEGIN ICACHE_Init 2 */

  /* USER CODE END ICACHE_Init 2 */

}
 80006ba:	bf00      	nop
 80006bc:	bd80      	pop	{r7, pc}
	...

080006c0 <MX_OCTOSPI1_Init>:
  * @brief OCTOSPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_OCTOSPI1_Init(void)
{
 80006c0:	b580      	push	{r7, lr}
 80006c2:	b088      	sub	sp, #32
 80006c4:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN OCTOSPI1_Init 0 */

  /* USER CODE END OCTOSPI1_Init 0 */

  OSPIM_CfgTypeDef sOspiManagerCfg = {0};
 80006c6:	f107 0308 	add.w	r3, r7, #8
 80006ca:	2200      	movs	r2, #0
 80006cc:	601a      	str	r2, [r3, #0]
 80006ce:	605a      	str	r2, [r3, #4]
 80006d0:	609a      	str	r2, [r3, #8]
 80006d2:	60da      	str	r2, [r3, #12]
 80006d4:	611a      	str	r2, [r3, #16]
 80006d6:	615a      	str	r2, [r3, #20]
  HAL_OSPI_DLYB_CfgTypeDef HAL_OSPI_DLYB_Cfg_Struct = {0};
 80006d8:	463b      	mov	r3, r7
 80006da:	2200      	movs	r2, #0
 80006dc:	601a      	str	r2, [r3, #0]
 80006de:	605a      	str	r2, [r3, #4]

  /* USER CODE BEGIN OCTOSPI1_Init 1 */

  /* USER CODE END OCTOSPI1_Init 1 */
  /* OCTOSPI1 parameter configuration*/
  hospi1.Instance = OCTOSPI1;
 80006e0:	4b32      	ldr	r3, [pc, #200]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 80006e2:	4a33      	ldr	r2, [pc, #204]	; (80007b0 <MX_OCTOSPI1_Init+0xf0>)
 80006e4:	601a      	str	r2, [r3, #0]
  hospi1.Init.FifoThreshold = 4;
 80006e6:	4b31      	ldr	r3, [pc, #196]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 80006e8:	2204      	movs	r2, #4
 80006ea:	605a      	str	r2, [r3, #4]
  hospi1.Init.DualQuad = HAL_OSPI_DUALQUAD_DISABLE;
 80006ec:	4b2f      	ldr	r3, [pc, #188]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 80006ee:	2200      	movs	r2, #0
 80006f0:	609a      	str	r2, [r3, #8]
  hospi1.Init.MemoryType = HAL_OSPI_MEMTYPE_APMEMORY;
 80006f2:	4b2e      	ldr	r3, [pc, #184]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 80006f4:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 80006f8:	60da      	str	r2, [r3, #12]
  hospi1.Init.DeviceSize = 23;
 80006fa:	4b2c      	ldr	r3, [pc, #176]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 80006fc:	2217      	movs	r2, #23
 80006fe:	611a      	str	r2, [r3, #16]
  hospi1.Init.ChipSelectHighTime = 1;
 8000700:	4b2a      	ldr	r3, [pc, #168]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 8000702:	2201      	movs	r2, #1
 8000704:	615a      	str	r2, [r3, #20]
  hospi1.Init.FreeRunningClock = HAL_OSPI_FREERUNCLK_DISABLE;
 8000706:	4b29      	ldr	r3, [pc, #164]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 8000708:	2200      	movs	r2, #0
 800070a:	619a      	str	r2, [r3, #24]
  hospi1.Init.ClockMode = HAL_OSPI_CLOCK_MODE_0;
 800070c:	4b27      	ldr	r3, [pc, #156]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 800070e:	2200      	movs	r2, #0
 8000710:	61da      	str	r2, [r3, #28]
  hospi1.Init.WrapSize = HAL_OSPI_WRAP_32_BYTES;
 8000712:	4b26      	ldr	r3, [pc, #152]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 8000714:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 8000718:	621a      	str	r2, [r3, #32]
  hospi1.Init.ClockPrescaler = 2;
 800071a:	4b24      	ldr	r3, [pc, #144]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 800071c:	2202      	movs	r2, #2
 800071e:	625a      	str	r2, [r3, #36]	; 0x24
  hospi1.Init.SampleShifting = HAL_OSPI_SAMPLE_SHIFTING_NONE;
 8000720:	4b22      	ldr	r3, [pc, #136]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 8000722:	2200      	movs	r2, #0
 8000724:	629a      	str	r2, [r3, #40]	; 0x28
  hospi1.Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_ENABLE;
 8000726:	4b21      	ldr	r3, [pc, #132]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 8000728:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800072c:	62da      	str	r2, [r3, #44]	; 0x2c
  hospi1.Init.ChipSelectBoundary = 10;
 800072e:	4b1f      	ldr	r3, [pc, #124]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 8000730:	220a      	movs	r2, #10
 8000732:	631a      	str	r2, [r3, #48]	; 0x30
  hospi1.Init.DelayBlockBypass = HAL_OSPI_DELAY_BLOCK_USED;
 8000734:	4b1d      	ldr	r3, [pc, #116]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 8000736:	2200      	movs	r2, #0
 8000738:	635a      	str	r2, [r3, #52]	; 0x34
  hospi1.Init.MaxTran = 0;
 800073a:	4b1c      	ldr	r3, [pc, #112]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 800073c:	2200      	movs	r2, #0
 800073e:	639a      	str	r2, [r3, #56]	; 0x38
  hospi1.Init.Refresh = 0;
 8000740:	4b1a      	ldr	r3, [pc, #104]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 8000742:	2200      	movs	r2, #0
 8000744:	63da      	str	r2, [r3, #60]	; 0x3c
  if (HAL_OSPI_Init(&hospi1) != HAL_OK)
 8000746:	4819      	ldr	r0, [pc, #100]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 8000748:	f001 f9a4 	bl	8001a94 <HAL_OSPI_Init>
 800074c:	4603      	mov	r3, r0
 800074e:	2b00      	cmp	r3, #0
 8000750:	d001      	beq.n	8000756 <MX_OCTOSPI1_Init+0x96>
  {
    Error_Handler();
 8000752:	f000 f8a5 	bl	80008a0 <Error_Handler>
  }
  sOspiManagerCfg.ClkPort = 1;
 8000756:	2301      	movs	r3, #1
 8000758:	60bb      	str	r3, [r7, #8]
  sOspiManagerCfg.DQSPort = 1;
 800075a:	2301      	movs	r3, #1
 800075c:	60fb      	str	r3, [r7, #12]
  sOspiManagerCfg.NCSPort = 1;
 800075e:	2301      	movs	r3, #1
 8000760:	613b      	str	r3, [r7, #16]
  sOspiManagerCfg.IOLowPort = HAL_OSPIM_IOPORT_1_LOW;
 8000762:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8000766:	617b      	str	r3, [r7, #20]
  sOspiManagerCfg.IOHighPort = HAL_OSPIM_IOPORT_1_HIGH;
 8000768:	4b12      	ldr	r3, [pc, #72]	; (80007b4 <MX_OCTOSPI1_Init+0xf4>)
 800076a:	61bb      	str	r3, [r7, #24]
  if (HAL_OSPIM_Config(&hospi1, &sOspiManagerCfg, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800076c:	f107 0308 	add.w	r3, r7, #8
 8000770:	f241 3288 	movw	r2, #5000	; 0x1388
 8000774:	4619      	mov	r1, r3
 8000776:	480d      	ldr	r0, [pc, #52]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 8000778:	f001 fe2a 	bl	80023d0 <HAL_OSPIM_Config>
 800077c:	4603      	mov	r3, r0
 800077e:	2b00      	cmp	r3, #0
 8000780:	d001      	beq.n	8000786 <MX_OCTOSPI1_Init+0xc6>
  {
    Error_Handler();
 8000782:	f000 f88d 	bl	80008a0 <Error_Handler>
  }
  HAL_OSPI_DLYB_Cfg_Struct.Units = 0;
 8000786:	2300      	movs	r3, #0
 8000788:	603b      	str	r3, [r7, #0]
  HAL_OSPI_DLYB_Cfg_Struct.PhaseSel = 0;
 800078a:	2300      	movs	r3, #0
 800078c:	607b      	str	r3, [r7, #4]
  if (HAL_OSPI_DLYB_SetConfig(&hospi1, &HAL_OSPI_DLYB_Cfg_Struct) != HAL_OK)
 800078e:	463b      	mov	r3, r7
 8000790:	4619      	mov	r1, r3
 8000792:	4806      	ldr	r0, [pc, #24]	; (80007ac <MX_OCTOSPI1_Init+0xec>)
 8000794:	f002 fdbe 	bl	8003314 <HAL_OSPI_DLYB_SetConfig>
 8000798:	4603      	mov	r3, r0
 800079a:	2b00      	cmp	r3, #0
 800079c:	d001      	beq.n	80007a2 <MX_OCTOSPI1_Init+0xe2>
  {
    Error_Handler();
 800079e:	f000 f87f 	bl	80008a0 <Error_Handler>
  }
  /* USER CODE BEGIN OCTOSPI1_Init 2 */

  /* USER CODE END OCTOSPI1_Init 2 */

}
 80007a2:	bf00      	nop
 80007a4:	3720      	adds	r7, #32
 80007a6:	46bd      	mov	sp, r7
 80007a8:	bd80      	pop	{r7, pc}
 80007aa:	bf00      	nop
 80007ac:	20000094 	.word	0x20000094
 80007b0:	420d1400 	.word	0x420d1400
 80007b4:	01000001 	.word	0x01000001

080007b8 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 80007b8:	b480      	push	{r7}
 80007ba:	b089      	sub	sp, #36	; 0x24
 80007bc:	af00      	add	r7, sp, #0
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOI_CLK_ENABLE();
 80007be:	4b37      	ldr	r3, [pc, #220]	; (800089c <MX_GPIO_Init+0xe4>)
 80007c0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80007c4:	4a35      	ldr	r2, [pc, #212]	; (800089c <MX_GPIO_Init+0xe4>)
 80007c6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80007ca:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 80007ce:	4b33      	ldr	r3, [pc, #204]	; (800089c <MX_GPIO_Init+0xe4>)
 80007d0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80007d4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80007d8:	61fb      	str	r3, [r7, #28]
 80007da:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 80007dc:	4b2f      	ldr	r3, [pc, #188]	; (800089c <MX_GPIO_Init+0xe4>)
 80007de:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80007e2:	4a2e      	ldr	r2, [pc, #184]	; (800089c <MX_GPIO_Init+0xe4>)
 80007e4:	f043 0310 	orr.w	r3, r3, #16
 80007e8:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 80007ec:	4b2b      	ldr	r3, [pc, #172]	; (800089c <MX_GPIO_Init+0xe4>)
 80007ee:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80007f2:	f003 0310 	and.w	r3, r3, #16
 80007f6:	61bb      	str	r3, [r7, #24]
 80007f8:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80007fa:	4b28      	ldr	r3, [pc, #160]	; (800089c <MX_GPIO_Init+0xe4>)
 80007fc:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000800:	4a26      	ldr	r2, [pc, #152]	; (800089c <MX_GPIO_Init+0xe4>)
 8000802:	f043 0308 	orr.w	r3, r3, #8
 8000806:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 800080a:	4b24      	ldr	r3, [pc, #144]	; (800089c <MX_GPIO_Init+0xe4>)
 800080c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000810:	f003 0308 	and.w	r3, r3, #8
 8000814:	617b      	str	r3, [r7, #20]
 8000816:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8000818:	4b20      	ldr	r3, [pc, #128]	; (800089c <MX_GPIO_Init+0xe4>)
 800081a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800081e:	4a1f      	ldr	r2, [pc, #124]	; (800089c <MX_GPIO_Init+0xe4>)
 8000820:	f043 0320 	orr.w	r3, r3, #32
 8000824:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 8000828:	4b1c      	ldr	r3, [pc, #112]	; (800089c <MX_GPIO_Init+0xe4>)
 800082a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800082e:	f003 0320 	and.w	r3, r3, #32
 8000832:	613b      	str	r3, [r7, #16]
 8000834:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8000836:	4b19      	ldr	r3, [pc, #100]	; (800089c <MX_GPIO_Init+0xe4>)
 8000838:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800083c:	4a17      	ldr	r2, [pc, #92]	; (800089c <MX_GPIO_Init+0xe4>)
 800083e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000842:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 8000846:	4b15      	ldr	r3, [pc, #84]	; (800089c <MX_GPIO_Init+0xe4>)
 8000848:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800084c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000850:	60fb      	str	r3, [r7, #12]
 8000852:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000854:	4b11      	ldr	r3, [pc, #68]	; (800089c <MX_GPIO_Init+0xe4>)
 8000856:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800085a:	4a10      	ldr	r2, [pc, #64]	; (800089c <MX_GPIO_Init+0xe4>)
 800085c:	f043 0304 	orr.w	r3, r3, #4
 8000860:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 8000864:	4b0d      	ldr	r3, [pc, #52]	; (800089c <MX_GPIO_Init+0xe4>)
 8000866:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800086a:	f003 0304 	and.w	r3, r3, #4
 800086e:	60bb      	str	r3, [r7, #8]
 8000870:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000872:	4b0a      	ldr	r3, [pc, #40]	; (800089c <MX_GPIO_Init+0xe4>)
 8000874:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000878:	4a08      	ldr	r2, [pc, #32]	; (800089c <MX_GPIO_Init+0xe4>)
 800087a:	f043 0302 	orr.w	r3, r3, #2
 800087e:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 8000882:	4b06      	ldr	r3, [pc, #24]	; (800089c <MX_GPIO_Init+0xe4>)
 8000884:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000888:	f003 0302 	and.w	r3, r3, #2
 800088c:	607b      	str	r3, [r7, #4]
 800088e:	687b      	ldr	r3, [r7, #4]

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}
 8000890:	bf00      	nop
 8000892:	3724      	adds	r7, #36	; 0x24
 8000894:	46bd      	mov	sp, r7
 8000896:	f85d 7b04 	ldr.w	r7, [sp], #4
 800089a:	4770      	bx	lr
 800089c:	46020c00 	.word	0x46020c00

080008a0 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 80008a0:	b580      	push	{r7, lr}
 80008a2:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80008a4:	b672      	cpsid	i
}
 80008a6:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
    HAL_Delay(100);
 80008a8:	2064      	movs	r0, #100	; 0x64
 80008aa:	f000 fbc1 	bl	8001030 <HAL_Delay>
    BSP_LED_Toggle(LED_RED);
 80008ae:	2000      	movs	r0, #0
 80008b0:	f000 fae4 	bl	8000e7c <BSP_LED_Toggle>
    HAL_Delay(100);
 80008b4:	e7f8      	b.n	80008a8 <Error_Handler+0x8>
	...

080008b8 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80008b8:	b480      	push	{r7}
 80008ba:	b083      	sub	sp, #12
 80008bc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */
  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
 80008be:	4b0a      	ldr	r3, [pc, #40]	; (80008e8 <HAL_MspInit+0x30>)
 80008c0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80008c4:	4a08      	ldr	r2, [pc, #32]	; (80008e8 <HAL_MspInit+0x30>)
 80008c6:	f043 0304 	orr.w	r3, r3, #4
 80008ca:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 80008ce:	4b06      	ldr	r3, [pc, #24]	; (80008e8 <HAL_MspInit+0x30>)
 80008d0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80008d4:	f003 0304 	and.w	r3, r3, #4
 80008d8:	607b      	str	r3, [r7, #4]
 80008da:	687b      	ldr	r3, [r7, #4]

  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */
  /* USER CODE END MspInit 1 */
}
 80008dc:	bf00      	nop
 80008de:	370c      	adds	r7, #12
 80008e0:	46bd      	mov	sp, r7
 80008e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80008e6:	4770      	bx	lr
 80008e8:	46020c00 	.word	0x46020c00

080008ec <HAL_OSPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hospi: OSPI handle pointer
* @retval None
*/
void HAL_OSPI_MspInit(OSPI_HandleTypeDef* hospi)
{
 80008ec:	b580      	push	{r7, lr}
 80008ee:	b0c4      	sub	sp, #272	; 0x110
 80008f0:	af00      	add	r7, sp, #0
 80008f2:	f507 7388 	add.w	r3, r7, #272	; 0x110
 80008f6:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 80008fa:	6018      	str	r0, [r3, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80008fc:	f107 03fc 	add.w	r3, r7, #252	; 0xfc
 8000900:	2200      	movs	r2, #0
 8000902:	601a      	str	r2, [r3, #0]
 8000904:	605a      	str	r2, [r3, #4]
 8000906:	609a      	str	r2, [r3, #8]
 8000908:	60da      	str	r2, [r3, #12]
 800090a:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 800090c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8000910:	22c8      	movs	r2, #200	; 0xc8
 8000912:	2100      	movs	r1, #0
 8000914:	4618      	mov	r0, r3
 8000916:	f005 f8e1 	bl	8005adc <memset>
  if(hospi->Instance==OCTOSPI1)
 800091a:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800091e:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8000922:	681b      	ldr	r3, [r3, #0]
 8000924:	681b      	ldr	r3, [r3, #0]
 8000926:	4aa8      	ldr	r2, [pc, #672]	; (8000bc8 <HAL_OSPI_MspInit+0x2dc>)
 8000928:	4293      	cmp	r3, r2
 800092a:	f040 8147 	bne.w	8000bbc <HAL_OSPI_MspInit+0x2d0>
  /* USER CODE BEGIN OCTOSPI1_MspInit 0 */
  /* USER CODE END OCTOSPI1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_OSPI;
 800092e:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 8000932:	f04f 0300 	mov.w	r3, #0
 8000936:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
    PeriphClkInit.OspiClockSelection = RCC_OSPICLKSOURCE_SYSCLK;
 800093a:	2300      	movs	r3, #0
 800093c:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000940:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8000944:	4618      	mov	r0, r3
 8000946:	f004 f889 	bl	8004a5c <HAL_RCCEx_PeriphCLKConfig>
 800094a:	4603      	mov	r3, r0
 800094c:	2b00      	cmp	r3, #0
 800094e:	d001      	beq.n	8000954 <HAL_OSPI_MspInit+0x68>
    {
      Error_Handler();
 8000950:	f7ff ffa6 	bl	80008a0 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_OSPIM_CLK_ENABLE();
 8000954:	4b9d      	ldr	r3, [pc, #628]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 8000956:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800095a:	4a9c      	ldr	r2, [pc, #624]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 800095c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8000960:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 8000964:	4b99      	ldr	r3, [pc, #612]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 8000966:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800096a:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800096e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8000970:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    __HAL_RCC_OSPI1_CLK_ENABLE();
 8000972:	4b96      	ldr	r3, [pc, #600]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 8000974:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8000978:	4a94      	ldr	r2, [pc, #592]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 800097a:	f043 0310 	orr.w	r3, r3, #16
 800097e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8000982:	4b92      	ldr	r3, [pc, #584]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 8000984:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8000988:	f003 0310 	and.w	r3, r3, #16
 800098c:	62bb      	str	r3, [r7, #40]	; 0x28
 800098e:	6abb      	ldr	r3, [r7, #40]	; 0x28

    __HAL_RCC_GPIOI_CLK_ENABLE();
 8000990:	4b8e      	ldr	r3, [pc, #568]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 8000992:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000996:	4a8d      	ldr	r2, [pc, #564]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 8000998:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800099c:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 80009a0:	4b8a      	ldr	r3, [pc, #552]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 80009a2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80009a6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80009aa:	627b      	str	r3, [r7, #36]	; 0x24
 80009ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80009ae:	4b87      	ldr	r3, [pc, #540]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 80009b0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80009b4:	4a85      	ldr	r2, [pc, #532]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 80009b6:	f043 0310 	orr.w	r3, r3, #16
 80009ba:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 80009be:	4b83      	ldr	r3, [pc, #524]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 80009c0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80009c4:	f003 0310 	and.w	r3, r3, #16
 80009c8:	623b      	str	r3, [r7, #32]
 80009ca:	6a3b      	ldr	r3, [r7, #32]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80009cc:	4b7f      	ldr	r3, [pc, #508]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 80009ce:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80009d2:	4a7e      	ldr	r2, [pc, #504]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 80009d4:	f043 0308 	orr.w	r3, r3, #8
 80009d8:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 80009dc:	4b7b      	ldr	r3, [pc, #492]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 80009de:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80009e2:	f003 0308 	and.w	r3, r3, #8
 80009e6:	61fb      	str	r3, [r7, #28]
 80009e8:	69fb      	ldr	r3, [r7, #28]
    __HAL_RCC_GPIOF_CLK_ENABLE();
 80009ea:	4b78      	ldr	r3, [pc, #480]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 80009ec:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80009f0:	4a76      	ldr	r2, [pc, #472]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 80009f2:	f043 0320 	orr.w	r3, r3, #32
 80009f6:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 80009fa:	4b74      	ldr	r3, [pc, #464]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 80009fc:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000a00:	f003 0320 	and.w	r3, r3, #32
 8000a04:	61bb      	str	r3, [r7, #24]
 8000a06:	69bb      	ldr	r3, [r7, #24]
    __HAL_RCC_GPIOH_CLK_ENABLE();
 8000a08:	4b70      	ldr	r3, [pc, #448]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 8000a0a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000a0e:	4a6f      	ldr	r2, [pc, #444]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 8000a10:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000a14:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 8000a18:	4b6c      	ldr	r3, [pc, #432]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 8000a1a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000a1e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000a22:	617b      	str	r3, [r7, #20]
 8000a24:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8000a26:	4b69      	ldr	r3, [pc, #420]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 8000a28:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000a2c:	4a67      	ldr	r2, [pc, #412]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 8000a2e:	f043 0304 	orr.w	r3, r3, #4
 8000a32:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 8000a36:	4b65      	ldr	r3, [pc, #404]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 8000a38:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000a3c:	f003 0204 	and.w	r2, r3, #4
 8000a40:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8000a44:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8000a48:	601a      	str	r2, [r3, #0]
 8000a4a:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8000a4e:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8000a52:	681b      	ldr	r3, [r3, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8000a54:	4b5d      	ldr	r3, [pc, #372]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 8000a56:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000a5a:	4a5c      	ldr	r2, [pc, #368]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 8000a5c:	f043 0302 	orr.w	r3, r3, #2
 8000a60:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 8000a64:	4b59      	ldr	r3, [pc, #356]	; (8000bcc <HAL_OSPI_MspInit+0x2e0>)
 8000a66:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000a6a:	f003 0202 	and.w	r2, r3, #2
 8000a6e:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8000a72:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8000a76:	601a      	str	r2, [r3, #0]
 8000a78:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8000a7c:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8000a80:	681b      	ldr	r3, [r3, #0]
    PF6     ------> OCTOSPIM_P1_IO3
    PC3     ------> OCTOSPIM_P1_IO6
    PB10     ------> OCTOSPIM_P1_CLK
    PB11     ------> OCTOSPIM_P1_NCS
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 8000a82:	2301      	movs	r3, #1
 8000a84:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000a88:	2302      	movs	r3, #2
 8000a8a:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000a8e:	2300      	movs	r3, #0
 8000a90:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000a94:	2302      	movs	r3, #2
 8000a96:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    GPIO_InitStruct.Alternate = GPIO_AF3_OCTOSPI1;
 8000a9a:	2303      	movs	r3, #3
 8000a9c:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8000aa0:	f107 03fc 	add.w	r3, r7, #252	; 0xfc
 8000aa4:	4619      	mov	r1, r3
 8000aa6:	484a      	ldr	r0, [pc, #296]	; (8000bd0 <HAL_OSPI_MspInit+0x2e4>)
 8000aa8:	f000 fccc 	bl	8001444 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_3;
 8000aac:	2308      	movs	r3, #8
 8000aae:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000ab2:	2302      	movs	r3, #2
 8000ab4:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000ab8:	2300      	movs	r3, #0
 8000aba:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000abe:	2302      	movs	r3, #2
 8000ac0:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    GPIO_InitStruct.Alternate = GPIO_AF3_OCTOSPI1;
 8000ac4:	2303      	movs	r3, #3
 8000ac6:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8000aca:	f107 03fc 	add.w	r3, r7, #252	; 0xfc
 8000ace:	4619      	mov	r1, r3
 8000ad0:	4840      	ldr	r0, [pc, #256]	; (8000bd4 <HAL_OSPI_MspInit+0x2e8>)
 8000ad2:	f000 fcb7 	bl	8001444 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_7;
 8000ad6:	2380      	movs	r3, #128	; 0x80
 8000ad8:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000adc:	2302      	movs	r3, #2
 8000ade:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000ae2:	2300      	movs	r3, #0
 8000ae4:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000ae8:	2302      	movs	r3, #2
 8000aea:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    GPIO_InitStruct.Alternate = GPIO_AF10_OCTOSPI1;
 8000aee:	230a      	movs	r3, #10
 8000af0:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8000af4:	f107 03fc 	add.w	r3, r7, #252	; 0xfc
 8000af8:	4619      	mov	r1, r3
 8000afa:	4837      	ldr	r0, [pc, #220]	; (8000bd8 <HAL_OSPI_MspInit+0x2ec>)
 8000afc:	f000 fca2 	bl	8001444 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_7|GPIO_PIN_9|GPIO_PIN_6;
 8000b00:	f44f 7370 	mov.w	r3, #960	; 0x3c0
 8000b04:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000b08:	2302      	movs	r3, #2
 8000b0a:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000b0e:	2300      	movs	r3, #0
 8000b10:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000b14:	2302      	movs	r3, #2
 8000b16:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    GPIO_InitStruct.Alternate = GPIO_AF10_OCTOSPI1;
 8000b1a:	230a      	movs	r3, #10
 8000b1c:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8000b20:	f107 03fc 	add.w	r3, r7, #252	; 0xfc
 8000b24:	4619      	mov	r1, r3
 8000b26:	482d      	ldr	r0, [pc, #180]	; (8000bdc <HAL_OSPI_MspInit+0x2f0>)
 8000b28:	f000 fc8c 	bl	8001444 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8000b2c:	2304      	movs	r3, #4
 8000b2e:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000b32:	2302      	movs	r3, #2
 8000b34:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000b38:	2300      	movs	r3, #0
 8000b3a:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000b3e:	2302      	movs	r3, #2
 8000b40:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    GPIO_InitStruct.Alternate = GPIO_AF3_OCTOSPI1;
 8000b44:	2303      	movs	r3, #3
 8000b46:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8000b4a:	f107 03fc 	add.w	r3, r7, #252	; 0xfc
 8000b4e:	4619      	mov	r1, r3
 8000b50:	4823      	ldr	r0, [pc, #140]	; (8000be0 <HAL_OSPI_MspInit+0x2f4>)
 8000b52:	f000 fc77 	bl	8001444 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_3;
 8000b56:	2308      	movs	r3, #8
 8000b58:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000b5c:	2302      	movs	r3, #2
 8000b5e:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000b62:	2300      	movs	r3, #0
 8000b64:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000b68:	2302      	movs	r3, #2
 8000b6a:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    GPIO_InitStruct.Alternate = GPIO_AF10_OCTOSPI1;
 8000b6e:	230a      	movs	r3, #10
 8000b70:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000b74:	f107 03fc 	add.w	r3, r7, #252	; 0xfc
 8000b78:	4619      	mov	r1, r3
 8000b7a:	481a      	ldr	r0, [pc, #104]	; (8000be4 <HAL_OSPI_MspInit+0x2f8>)
 8000b7c:	f000 fc62 	bl	8001444 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 8000b80:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8000b84:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000b88:	2302      	movs	r3, #2
 8000b8a:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000b8e:	2300      	movs	r3, #0
 8000b90:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000b94:	2302      	movs	r3, #2
 8000b96:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    GPIO_InitStruct.Alternate = GPIO_AF10_OCTOSPI1;
 8000b9a:	230a      	movs	r3, #10
 8000b9c:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000ba0:	f107 03fc 	add.w	r3, r7, #252	; 0xfc
 8000ba4:	4619      	mov	r1, r3
 8000ba6:	4810      	ldr	r0, [pc, #64]	; (8000be8 <HAL_OSPI_MspInit+0x2fc>)
 8000ba8:	f000 fc4c 	bl	8001444 <HAL_GPIO_Init>

    /* OCTOSPI1 interrupt Init */
    HAL_NVIC_SetPriority(OCTOSPI1_IRQn, 0, 0);
 8000bac:	2200      	movs	r2, #0
 8000bae:	2100      	movs	r1, #0
 8000bb0:	204c      	movs	r0, #76	; 0x4c
 8000bb2:	f000 fb60 	bl	8001276 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OCTOSPI1_IRQn);
 8000bb6:	204c      	movs	r0, #76	; 0x4c
 8000bb8:	f000 fb77 	bl	80012aa <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN OCTOSPI1_MspInit 1 */
  /* USER CODE END OCTOSPI1_MspInit 1 */
  }

}
 8000bbc:	bf00      	nop
 8000bbe:	f507 7788 	add.w	r7, r7, #272	; 0x110
 8000bc2:	46bd      	mov	sp, r7
 8000bc4:	bd80      	pop	{r7, pc}
 8000bc6:	bf00      	nop
 8000bc8:	420d1400 	.word	0x420d1400
 8000bcc:	46020c00 	.word	0x46020c00
 8000bd0:	42022000 	.word	0x42022000
 8000bd4:	42021000 	.word	0x42021000
 8000bd8:	42020c00 	.word	0x42020c00
 8000bdc:	42021400 	.word	0x42021400
 8000be0:	42021c00 	.word	0x42021c00
 8000be4:	42020800 	.word	0x42020800
 8000be8:	42020400 	.word	0x42020400

08000bec <HAL_OSPI_MspDeInit>:
* This function freeze the hardware resources used in this example
* @param hospi: OSPI handle pointer
* @retval None
*/
void HAL_OSPI_MspDeInit(OSPI_HandleTypeDef* hospi)
{
 8000bec:	b580      	push	{r7, lr}
 8000bee:	b082      	sub	sp, #8
 8000bf0:	af00      	add	r7, sp, #0
 8000bf2:	6078      	str	r0, [r7, #4]
  if(hospi->Instance==OCTOSPI1)
 8000bf4:	687b      	ldr	r3, [r7, #4]
 8000bf6:	681b      	ldr	r3, [r3, #0]
 8000bf8:	4a1b      	ldr	r2, [pc, #108]	; (8000c68 <HAL_OSPI_MspDeInit+0x7c>)
 8000bfa:	4293      	cmp	r3, r2
 8000bfc:	d130      	bne.n	8000c60 <HAL_OSPI_MspDeInit+0x74>
  {
  /* USER CODE BEGIN OCTOSPI1_MspDeInit 0 */
  /* USER CODE END OCTOSPI1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_OSPIM_CLK_DISABLE();
 8000bfe:	4b1b      	ldr	r3, [pc, #108]	; (8000c6c <HAL_OSPI_MspDeInit+0x80>)
 8000c00:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000c04:	4a19      	ldr	r2, [pc, #100]	; (8000c6c <HAL_OSPI_MspDeInit+0x80>)
 8000c06:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8000c0a:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    __HAL_RCC_OSPI1_CLK_DISABLE();
 8000c0e:	4b17      	ldr	r3, [pc, #92]	; (8000c6c <HAL_OSPI_MspDeInit+0x80>)
 8000c10:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8000c14:	4a15      	ldr	r2, [pc, #84]	; (8000c6c <HAL_OSPI_MspDeInit+0x80>)
 8000c16:	f023 0310 	bic.w	r3, r3, #16
 8000c1a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
    PF6     ------> OCTOSPIM_P1_IO3
    PC3     ------> OCTOSPIM_P1_IO6
    PB10     ------> OCTOSPIM_P1_CLK
    PB11     ------> OCTOSPIM_P1_NCS
    */
    HAL_GPIO_DeInit(GPIOI, GPIO_PIN_0);
 8000c1e:	2101      	movs	r1, #1
 8000c20:	4813      	ldr	r0, [pc, #76]	; (8000c70 <HAL_OSPI_MspDeInit+0x84>)
 8000c22:	f000 fde7 	bl	80017f4 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOE, GPIO_PIN_3);
 8000c26:	2108      	movs	r1, #8
 8000c28:	4812      	ldr	r0, [pc, #72]	; (8000c74 <HAL_OSPI_MspDeInit+0x88>)
 8000c2a:	f000 fde3 	bl	80017f4 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_7);
 8000c2e:	2180      	movs	r1, #128	; 0x80
 8000c30:	4811      	ldr	r0, [pc, #68]	; (8000c78 <HAL_OSPI_MspDeInit+0x8c>)
 8000c32:	f000 fddf 	bl	80017f4 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOF, GPIO_PIN_8|GPIO_PIN_7|GPIO_PIN_9|GPIO_PIN_6);
 8000c36:	f44f 7170 	mov.w	r1, #960	; 0x3c0
 8000c3a:	4810      	ldr	r0, [pc, #64]	; (8000c7c <HAL_OSPI_MspDeInit+0x90>)
 8000c3c:	f000 fdda 	bl	80017f4 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOH, GPIO_PIN_2);
 8000c40:	2104      	movs	r1, #4
 8000c42:	480f      	ldr	r0, [pc, #60]	; (8000c80 <HAL_OSPI_MspDeInit+0x94>)
 8000c44:	f000 fdd6 	bl	80017f4 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOC, GPIO_PIN_3);
 8000c48:	2108      	movs	r1, #8
 8000c4a:	480e      	ldr	r0, [pc, #56]	; (8000c84 <HAL_OSPI_MspDeInit+0x98>)
 8000c4c:	f000 fdd2 	bl	80017f4 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);
 8000c50:	f44f 6140 	mov.w	r1, #3072	; 0xc00
 8000c54:	480c      	ldr	r0, [pc, #48]	; (8000c88 <HAL_OSPI_MspDeInit+0x9c>)
 8000c56:	f000 fdcd 	bl	80017f4 <HAL_GPIO_DeInit>

    /* OCTOSPI1 interrupt DeInit */
    HAL_NVIC_DisableIRQ(OCTOSPI1_IRQn);
 8000c5a:	204c      	movs	r0, #76	; 0x4c
 8000c5c:	f000 fb33 	bl	80012c6 <HAL_NVIC_DisableIRQ>
  /* USER CODE BEGIN OCTOSPI1_MspDeInit 1 */
  /* USER CODE END OCTOSPI1_MspDeInit 1 */
  }

}
 8000c60:	bf00      	nop
 8000c62:	3708      	adds	r7, #8
 8000c64:	46bd      	mov	sp, r7
 8000c66:	bd80      	pop	{r7, pc}
 8000c68:	420d1400 	.word	0x420d1400
 8000c6c:	46020c00 	.word	0x46020c00
 8000c70:	42022000 	.word	0x42022000
 8000c74:	42021000 	.word	0x42021000
 8000c78:	42020c00 	.word	0x42020c00
 8000c7c:	42021400 	.word	0x42021400
 8000c80:	42021c00 	.word	0x42021c00
 8000c84:	42020800 	.word	0x42020800
 8000c88:	42020400 	.word	0x42020400

08000c8c <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8000c8c:	b480      	push	{r7}
 8000c8e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8000c90:	e7fe      	b.n	8000c90 <NMI_Handler+0x4>

08000c92 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8000c92:	b480      	push	{r7}
 8000c94:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8000c96:	e7fe      	b.n	8000c96 <HardFault_Handler+0x4>

08000c98 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8000c98:	b480      	push	{r7}
 8000c9a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8000c9c:	e7fe      	b.n	8000c9c <MemManage_Handler+0x4>

08000c9e <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8000c9e:	b480      	push	{r7}
 8000ca0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8000ca2:	e7fe      	b.n	8000ca2 <BusFault_Handler+0x4>

08000ca4 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8000ca4:	b480      	push	{r7}
 8000ca6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8000ca8:	e7fe      	b.n	8000ca8 <UsageFault_Handler+0x4>

08000caa <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8000caa:	b480      	push	{r7}
 8000cac:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8000cae:	bf00      	nop
 8000cb0:	46bd      	mov	sp, r7
 8000cb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000cb6:	4770      	bx	lr

08000cb8 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8000cb8:	b480      	push	{r7}
 8000cba:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8000cbc:	bf00      	nop
 8000cbe:	46bd      	mov	sp, r7
 8000cc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000cc4:	4770      	bx	lr

08000cc6 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8000cc6:	b480      	push	{r7}
 8000cc8:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8000cca:	bf00      	nop
 8000ccc:	46bd      	mov	sp, r7
 8000cce:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000cd2:	4770      	bx	lr

08000cd4 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8000cd4:	b580      	push	{r7, lr}
 8000cd6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8000cd8:	f000 f98a 	bl	8000ff0 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8000cdc:	bf00      	nop
 8000cde:	bd80      	pop	{r7, pc}

08000ce0 <OCTOSPI1_IRQHandler>:

/**
  * @brief This function handles OCTOSPI1 global interrupt.
  */
void OCTOSPI1_IRQHandler(void)
{
 8000ce0:	b580      	push	{r7, lr}
 8000ce2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OCTOSPI1_IRQn 0 */

  /* USER CODE END OCTOSPI1_IRQn 0 */
  HAL_OSPI_IRQHandler(&hospi1);
 8000ce4:	4802      	ldr	r0, [pc, #8]	; (8000cf0 <OCTOSPI1_IRQHandler+0x10>)
 8000ce6:	f000 ffb9 	bl	8001c5c <HAL_OSPI_IRQHandler>
  /* USER CODE BEGIN OCTOSPI1_IRQn 1 */

  /* USER CODE END OCTOSPI1_IRQn 1 */
}
 8000cea:	bf00      	nop
 8000cec:	bd80      	pop	{r7, pc}
 8000cee:	bf00      	nop
 8000cf0:	20000094 	.word	0x20000094

08000cf4 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8000cf4:	b580      	push	{r7, lr}
 8000cf6:	b086      	sub	sp, #24
 8000cf8:	af00      	add	r7, sp, #0
 8000cfa:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8000cfc:	4a14      	ldr	r2, [pc, #80]	; (8000d50 <_sbrk+0x5c>)
 8000cfe:	4b15      	ldr	r3, [pc, #84]	; (8000d54 <_sbrk+0x60>)
 8000d00:	1ad3      	subs	r3, r2, r3
 8000d02:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8000d04:	697b      	ldr	r3, [r7, #20]
 8000d06:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8000d08:	4b13      	ldr	r3, [pc, #76]	; (8000d58 <_sbrk+0x64>)
 8000d0a:	681b      	ldr	r3, [r3, #0]
 8000d0c:	2b00      	cmp	r3, #0
 8000d0e:	d102      	bne.n	8000d16 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8000d10:	4b11      	ldr	r3, [pc, #68]	; (8000d58 <_sbrk+0x64>)
 8000d12:	4a12      	ldr	r2, [pc, #72]	; (8000d5c <_sbrk+0x68>)
 8000d14:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8000d16:	4b10      	ldr	r3, [pc, #64]	; (8000d58 <_sbrk+0x64>)
 8000d18:	681a      	ldr	r2, [r3, #0]
 8000d1a:	687b      	ldr	r3, [r7, #4]
 8000d1c:	4413      	add	r3, r2
 8000d1e:	693a      	ldr	r2, [r7, #16]
 8000d20:	429a      	cmp	r2, r3
 8000d22:	d207      	bcs.n	8000d34 <_sbrk+0x40>
  {
    errno = ENOMEM;
 8000d24:	f004 fee2 	bl	8005aec <__errno>
 8000d28:	4603      	mov	r3, r0
 8000d2a:	220c      	movs	r2, #12
 8000d2c:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 8000d2e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000d32:	e009      	b.n	8000d48 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 8000d34:	4b08      	ldr	r3, [pc, #32]	; (8000d58 <_sbrk+0x64>)
 8000d36:	681b      	ldr	r3, [r3, #0]
 8000d38:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 8000d3a:	4b07      	ldr	r3, [pc, #28]	; (8000d58 <_sbrk+0x64>)
 8000d3c:	681a      	ldr	r2, [r3, #0]
 8000d3e:	687b      	ldr	r3, [r7, #4]
 8000d40:	4413      	add	r3, r2
 8000d42:	4a05      	ldr	r2, [pc, #20]	; (8000d58 <_sbrk+0x64>)
 8000d44:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 8000d46:	68fb      	ldr	r3, [r7, #12]
}
 8000d48:	4618      	mov	r0, r3
 8000d4a:	3718      	adds	r7, #24
 8000d4c:	46bd      	mov	sp, r7
 8000d4e:	bd80      	pop	{r7, pc}
 8000d50:	200c0000 	.word	0x200c0000
 8000d54:	00000400 	.word	0x00000400
 8000d58:	20001110 	.word	0x20001110
 8000d5c:	20001310 	.word	0x20001310

08000d60 <BSP_LED_Init>:
  *            @arg  LED6
  *            @arg  LED7
  * @retval BSP status
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 8000d60:	b580      	push	{r7, lr}
 8000d62:	b08a      	sub	sp, #40	; 0x28
 8000d64:	af00      	add	r7, sp, #0
 8000d66:	4603      	mov	r3, r0
 8000d68:	71fb      	strb	r3, [r7, #7]
  int32_t ret = BSP_ERROR_NONE;
 8000d6a:	2300      	movs	r3, #0
 8000d6c:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitTypeDef  gpio_init_structure;

  /* Enable the GPIO_LED clock */
  LED6_GPIO_CLK_ENABLE();
 8000d6e:	4b22      	ldr	r3, [pc, #136]	; (8000df8 <BSP_LED_Init+0x98>)
 8000d70:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000d74:	4a20      	ldr	r2, [pc, #128]	; (8000df8 <BSP_LED_Init+0x98>)
 8000d76:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000d7a:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 8000d7e:	4b1e      	ldr	r3, [pc, #120]	; (8000df8 <BSP_LED_Init+0x98>)
 8000d80:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000d84:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000d88:	60fb      	str	r3, [r7, #12]
 8000d8a:	68fb      	ldr	r3, [r7, #12]
  LED7_GPIO_CLK_ENABLE();
 8000d8c:	4b1a      	ldr	r3, [pc, #104]	; (8000df8 <BSP_LED_Init+0x98>)
 8000d8e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000d92:	4a19      	ldr	r2, [pc, #100]	; (8000df8 <BSP_LED_Init+0x98>)
 8000d94:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000d98:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 8000d9c:	4b16      	ldr	r3, [pc, #88]	; (8000df8 <BSP_LED_Init+0x98>)
 8000d9e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8000da2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000da6:	60bb      	str	r3, [r7, #8]
 8000da8:	68bb      	ldr	r3, [r7, #8]

  /* Configure the GPIO_LED pin */
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
 8000daa:	2301      	movs	r3, #1
 8000dac:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Pull = GPIO_NOPULL;
 8000dae:	2300      	movs	r3, #0
 8000db0:	61bb      	str	r3, [r7, #24]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 8000db2:	2302      	movs	r3, #2
 8000db4:	61fb      	str	r3, [r7, #28]
  gpio_init_structure.Pin = LED_PIN [Led];
 8000db6:	79fb      	ldrb	r3, [r7, #7]
 8000db8:	4a10      	ldr	r2, [pc, #64]	; (8000dfc <BSP_LED_Init+0x9c>)
 8000dba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000dbe:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 8000dc0:	79fb      	ldrb	r3, [r7, #7]
 8000dc2:	4a0f      	ldr	r2, [pc, #60]	; (8000e00 <BSP_LED_Init+0xa0>)
 8000dc4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000dc8:	f107 0210 	add.w	r2, r7, #16
 8000dcc:	4611      	mov	r1, r2
 8000dce:	4618      	mov	r0, r3
 8000dd0:	f000 fb38 	bl	8001444 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(LED_PORT [Led], (uint16_t)LED_PIN[Led], GPIO_PIN_SET);
 8000dd4:	79fb      	ldrb	r3, [r7, #7]
 8000dd6:	4a0a      	ldr	r2, [pc, #40]	; (8000e00 <BSP_LED_Init+0xa0>)
 8000dd8:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8000ddc:	79fb      	ldrb	r3, [r7, #7]
 8000dde:	4a07      	ldr	r2, [pc, #28]	; (8000dfc <BSP_LED_Init+0x9c>)
 8000de0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000de4:	b29b      	uxth	r3, r3
 8000de6:	2201      	movs	r2, #1
 8000de8:	4619      	mov	r1, r3
 8000dea:	f000 fde1 	bl	80019b0 <HAL_GPIO_WritePin>

  return ret;
 8000dee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8000df0:	4618      	mov	r0, r3
 8000df2:	3728      	adds	r7, #40	; 0x28
 8000df4:	46bd      	mov	sp, r7
 8000df6:	bd80      	pop	{r7, pc}
 8000df8:	46020c00 	.word	0x46020c00
 8000dfc:	08006e14 	.word	0x08006e14
 8000e00:	20000000 	.word	0x20000000

08000e04 <BSP_LED_On>:
  *            @arg  LED6
  *            @arg  LED7
  * @retval BSP status
  */
int32_t BSP_LED_On(Led_TypeDef Led)
{
 8000e04:	b580      	push	{r7, lr}
 8000e06:	b084      	sub	sp, #16
 8000e08:	af00      	add	r7, sp, #0
 8000e0a:	4603      	mov	r3, r0
 8000e0c:	71fb      	strb	r3, [r7, #7]
  int32_t ret;

  HAL_GPIO_WritePin(LED_PORT [Led], (uint16_t)LED_PIN [Led], GPIO_PIN_RESET);
 8000e0e:	79fb      	ldrb	r3, [r7, #7]
 8000e10:	4a09      	ldr	r2, [pc, #36]	; (8000e38 <BSP_LED_On+0x34>)
 8000e12:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8000e16:	79fb      	ldrb	r3, [r7, #7]
 8000e18:	4a08      	ldr	r2, [pc, #32]	; (8000e3c <BSP_LED_On+0x38>)
 8000e1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000e1e:	b29b      	uxth	r3, r3
 8000e20:	2200      	movs	r2, #0
 8000e22:	4619      	mov	r1, r3
 8000e24:	f000 fdc4 	bl	80019b0 <HAL_GPIO_WritePin>
  ret = BSP_ERROR_NONE;
 8000e28:	2300      	movs	r3, #0
 8000e2a:	60fb      	str	r3, [r7, #12]

  return ret;
 8000e2c:	68fb      	ldr	r3, [r7, #12]
}
 8000e2e:	4618      	mov	r0, r3
 8000e30:	3710      	adds	r7, #16
 8000e32:	46bd      	mov	sp, r7
 8000e34:	bd80      	pop	{r7, pc}
 8000e36:	bf00      	nop
 8000e38:	20000000 	.word	0x20000000
 8000e3c:	08006e14 	.word	0x08006e14

08000e40 <BSP_LED_Off>:
  *            @arg  LED6
  *            @arg  LED7
  * @retval BSP status
  */
int32_t BSP_LED_Off(Led_TypeDef Led)
{
 8000e40:	b580      	push	{r7, lr}
 8000e42:	b084      	sub	sp, #16
 8000e44:	af00      	add	r7, sp, #0
 8000e46:	4603      	mov	r3, r0
 8000e48:	71fb      	strb	r3, [r7, #7]
  int32_t ret;

  HAL_GPIO_WritePin(LED_PORT [Led], (uint16_t)LED_PIN [Led], GPIO_PIN_SET);
 8000e4a:	79fb      	ldrb	r3, [r7, #7]
 8000e4c:	4a09      	ldr	r2, [pc, #36]	; (8000e74 <BSP_LED_Off+0x34>)
 8000e4e:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8000e52:	79fb      	ldrb	r3, [r7, #7]
 8000e54:	4a08      	ldr	r2, [pc, #32]	; (8000e78 <BSP_LED_Off+0x38>)
 8000e56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000e5a:	b29b      	uxth	r3, r3
 8000e5c:	2201      	movs	r2, #1
 8000e5e:	4619      	mov	r1, r3
 8000e60:	f000 fda6 	bl	80019b0 <HAL_GPIO_WritePin>
  ret = BSP_ERROR_NONE;
 8000e64:	2300      	movs	r3, #0
 8000e66:	60fb      	str	r3, [r7, #12]

  return ret;
 8000e68:	68fb      	ldr	r3, [r7, #12]
}
 8000e6a:	4618      	mov	r0, r3
 8000e6c:	3710      	adds	r7, #16
 8000e6e:	46bd      	mov	sp, r7
 8000e70:	bd80      	pop	{r7, pc}
 8000e72:	bf00      	nop
 8000e74:	20000000 	.word	0x20000000
 8000e78:	08006e14 	.word	0x08006e14

08000e7c <BSP_LED_Toggle>:
  *            @arg  LED5
  *            @arg  LED7
  * @retval BSP status
  */
int32_t BSP_LED_Toggle(Led_TypeDef Led)
{
 8000e7c:	b580      	push	{r7, lr}
 8000e7e:	b084      	sub	sp, #16
 8000e80:	af00      	add	r7, sp, #0
 8000e82:	4603      	mov	r3, r0
 8000e84:	71fb      	strb	r3, [r7, #7]
  int32_t ret;

  HAL_GPIO_TogglePin(LED_PORT[Led], (uint16_t)LED_PIN[Led]);
 8000e86:	79fb      	ldrb	r3, [r7, #7]
 8000e88:	4a09      	ldr	r2, [pc, #36]	; (8000eb0 <BSP_LED_Toggle+0x34>)
 8000e8a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8000e8e:	79fb      	ldrb	r3, [r7, #7]
 8000e90:	4908      	ldr	r1, [pc, #32]	; (8000eb4 <BSP_LED_Toggle+0x38>)
 8000e92:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8000e96:	b29b      	uxth	r3, r3
 8000e98:	4619      	mov	r1, r3
 8000e9a:	4610      	mov	r0, r2
 8000e9c:	f000 fda0 	bl	80019e0 <HAL_GPIO_TogglePin>
  ret = BSP_ERROR_NONE;
 8000ea0:	2300      	movs	r3, #0
 8000ea2:	60fb      	str	r3, [r7, #12]

  return ret;
 8000ea4:	68fb      	ldr	r3, [r7, #12]
}
 8000ea6:	4618      	mov	r0, r3
 8000ea8:	3710      	adds	r7, #16
 8000eaa:	46bd      	mov	sp, r7
 8000eac:	bd80      	pop	{r7, pc}
 8000eae:	bf00      	nop
 8000eb0:	20000000 	.word	0x20000000
 8000eb4:	08006e14 	.word	0x08006e14

08000eb8 <SystemInit>:
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
 8000eb8:	b480      	push	{r7}
 8000eba:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
   SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 8000ebc:	4b18      	ldr	r3, [pc, #96]	; (8000f20 <SystemInit+0x68>)
 8000ebe:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8000ec2:	4a17      	ldr	r2, [pc, #92]	; (8000f20 <SystemInit+0x68>)
 8000ec4:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8000ec8:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR = RCC_CR_MSISON;
 8000ecc:	4b15      	ldr	r3, [pc, #84]	; (8000f24 <SystemInit+0x6c>)
 8000ece:	2201      	movs	r2, #1
 8000ed0:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR1 = 0U;
 8000ed2:	4b14      	ldr	r3, [pc, #80]	; (8000f24 <SystemInit+0x6c>)
 8000ed4:	2200      	movs	r2, #0
 8000ed6:	61da      	str	r2, [r3, #28]
  RCC->CFGR2 = 0U;
 8000ed8:	4b12      	ldr	r3, [pc, #72]	; (8000f24 <SystemInit+0x6c>)
 8000eda:	2200      	movs	r2, #0
 8000edc:	621a      	str	r2, [r3, #32]
  RCC->CFGR3 = 0U;
 8000ede:	4b11      	ldr	r3, [pc, #68]	; (8000f24 <SystemInit+0x6c>)
 8000ee0:	2200      	movs	r2, #0
 8000ee2:	625a      	str	r2, [r3, #36]	; 0x24

  /* Reset HSEON, CSSON , HSION, PLLxON bits */
  RCC->CR &= ~(RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLL1ON | RCC_CR_PLL2ON | RCC_CR_PLL3ON);
 8000ee4:	4b0f      	ldr	r3, [pc, #60]	; (8000f24 <SystemInit+0x6c>)
 8000ee6:	681b      	ldr	r3, [r3, #0]
 8000ee8:	4a0e      	ldr	r2, [pc, #56]	; (8000f24 <SystemInit+0x6c>)
 8000eea:	f023 53a8 	bic.w	r3, r3, #352321536	; 0x15000000
 8000eee:	f423 2310 	bic.w	r3, r3, #589824	; 0x90000
 8000ef2:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLL1CFGR = 0U;
 8000ef4:	4b0b      	ldr	r3, [pc, #44]	; (8000f24 <SystemInit+0x6c>)
 8000ef6:	2200      	movs	r2, #0
 8000ef8:	629a      	str	r2, [r3, #40]	; 0x28

  /* Reset HSEBYP bit */
  RCC->CR &= ~(RCC_CR_HSEBYP);
 8000efa:	4b0a      	ldr	r3, [pc, #40]	; (8000f24 <SystemInit+0x6c>)
 8000efc:	681b      	ldr	r3, [r3, #0]
 8000efe:	4a09      	ldr	r2, [pc, #36]	; (8000f24 <SystemInit+0x6c>)
 8000f00:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000f04:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0U;
 8000f06:	4b07      	ldr	r3, [pc, #28]	; (8000f24 <SystemInit+0x6c>)
 8000f08:	2200      	movs	r2, #0
 8000f0a:	651a      	str	r2, [r3, #80]	; 0x50

  /* Configure the Vector Table location add offset address ------------------*/
  #ifdef VECT_TAB_SRAM
    SCB->VTOR = SRAM1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
  #else
    SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000f0c:	4b04      	ldr	r3, [pc, #16]	; (8000f20 <SystemInit+0x68>)
 8000f0e:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000f12:	609a      	str	r2, [r3, #8]
  #endif
}
 8000f14:	bf00      	nop
 8000f16:	46bd      	mov	sp, r7
 8000f18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000f1c:	4770      	bx	lr
 8000f1e:	bf00      	nop
 8000f20:	e000ed00 	.word	0xe000ed00
 8000f24:	46020c00 	.word	0x46020c00

08000f28 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000f28:	b580      	push	{r7, lr}
 8000f2a:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch */
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000f2c:	4b11      	ldr	r3, [pc, #68]	; (8000f74 <HAL_Init+0x4c>)
 8000f2e:	681b      	ldr	r3, [r3, #0]
 8000f30:	4a10      	ldr	r2, [pc, #64]	; (8000f74 <HAL_Init+0x4c>)
 8000f32:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000f36:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000f38:	2003      	movs	r0, #3
 8000f3a:	f000 f991 	bl	8001260 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 8000f3e:	f003 fbeb 	bl	8004718 <HAL_RCC_GetSysClockFreq>
 8000f42:	4602      	mov	r2, r0
 8000f44:	4b0c      	ldr	r3, [pc, #48]	; (8000f78 <HAL_Init+0x50>)
 8000f46:	6a1b      	ldr	r3, [r3, #32]
 8000f48:	f003 030f 	and.w	r3, r3, #15
 8000f4c:	490b      	ldr	r1, [pc, #44]	; (8000f7c <HAL_Init+0x54>)
 8000f4e:	5ccb      	ldrb	r3, [r1, r3]
 8000f50:	fa22 f303 	lsr.w	r3, r2, r3
 8000f54:	4a0a      	ldr	r2, [pc, #40]	; (8000f80 <HAL_Init+0x58>)
 8000f56:	6013      	str	r3, [r2, #0]

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8000f58:	200f      	movs	r0, #15
 8000f5a:	f000 f813 	bl	8000f84 <HAL_InitTick>
 8000f5e:	4603      	mov	r3, r0
 8000f60:	2b00      	cmp	r3, #0
 8000f62:	d001      	beq.n	8000f68 <HAL_Init+0x40>
  {
    return HAL_ERROR;
 8000f64:	2301      	movs	r3, #1
 8000f66:	e002      	b.n	8000f6e <HAL_Init+0x46>
  }

  /* Init the low level hardware */
  HAL_MspInit();
 8000f68:	f7ff fca6 	bl	80008b8 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 8000f6c:	2300      	movs	r3, #0
}
 8000f6e:	4618      	mov	r0, r3
 8000f70:	bd80      	pop	{r7, pc}
 8000f72:	bf00      	nop
 8000f74:	40022000 	.word	0x40022000
 8000f78:	46020c00 	.word	0x46020c00
 8000f7c:	08006e1c 	.word	0x08006e1c
 8000f80:	20000008 	.word	0x20000008

08000f84 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000f84:	b580      	push	{r7, lr}
 8000f86:	b082      	sub	sp, #8
 8000f88:	af00      	add	r7, sp, #0
 8000f8a:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
 8000f8c:	4b15      	ldr	r3, [pc, #84]	; (8000fe4 <HAL_InitTick+0x60>)
 8000f8e:	781b      	ldrb	r3, [r3, #0]
 8000f90:	2b00      	cmp	r3, #0
 8000f92:	d101      	bne.n	8000f98 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
 8000f94:	2301      	movs	r3, #1
 8000f96:	e021      	b.n	8000fdc <HAL_InitTick+0x58>
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
 8000f98:	4b13      	ldr	r3, [pc, #76]	; (8000fe8 <HAL_InitTick+0x64>)
 8000f9a:	681a      	ldr	r2, [r3, #0]
 8000f9c:	4b11      	ldr	r3, [pc, #68]	; (8000fe4 <HAL_InitTick+0x60>)
 8000f9e:	781b      	ldrb	r3, [r3, #0]
 8000fa0:	4619      	mov	r1, r3
 8000fa2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000fa6:	fbb3 f3f1 	udiv	r3, r3, r1
 8000faa:	fbb2 f3f3 	udiv	r3, r2, r3
 8000fae:	4618      	mov	r0, r3
 8000fb0:	f000 f997 	bl	80012e2 <HAL_SYSTICK_Config>
 8000fb4:	4603      	mov	r3, r0
 8000fb6:	2b00      	cmp	r3, #0
 8000fb8:	d001      	beq.n	8000fbe <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
 8000fba:	2301      	movs	r3, #1
 8000fbc:	e00e      	b.n	8000fdc <HAL_InitTick+0x58>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000fbe:	687b      	ldr	r3, [r7, #4]
 8000fc0:	2b0f      	cmp	r3, #15
 8000fc2:	d80a      	bhi.n	8000fda <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8000fc4:	2200      	movs	r2, #0
 8000fc6:	6879      	ldr	r1, [r7, #4]
 8000fc8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000fcc:	f000 f953 	bl	8001276 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8000fd0:	4a06      	ldr	r2, [pc, #24]	; (8000fec <HAL_InitTick+0x68>)
 8000fd2:	687b      	ldr	r3, [r7, #4]
 8000fd4:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 8000fd6:	2300      	movs	r3, #0
 8000fd8:	e000      	b.n	8000fdc <HAL_InitTick+0x58>
    return HAL_ERROR;
 8000fda:	2301      	movs	r3, #1
}
 8000fdc:	4618      	mov	r0, r3
 8000fde:	3708      	adds	r7, #8
 8000fe0:	46bd      	mov	sp, r7
 8000fe2:	bd80      	pop	{r7, pc}
 8000fe4:	20000010 	.word	0x20000010
 8000fe8:	20000008 	.word	0x20000008
 8000fec:	2000000c 	.word	0x2000000c

08000ff0 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8000ff0:	b480      	push	{r7}
 8000ff2:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 8000ff4:	4b06      	ldr	r3, [pc, #24]	; (8001010 <HAL_IncTick+0x20>)
 8000ff6:	781b      	ldrb	r3, [r3, #0]
 8000ff8:	461a      	mov	r2, r3
 8000ffa:	4b06      	ldr	r3, [pc, #24]	; (8001014 <HAL_IncTick+0x24>)
 8000ffc:	681b      	ldr	r3, [r3, #0]
 8000ffe:	4413      	add	r3, r2
 8001000:	4a04      	ldr	r2, [pc, #16]	; (8001014 <HAL_IncTick+0x24>)
 8001002:	6013      	str	r3, [r2, #0]
}
 8001004:	bf00      	nop
 8001006:	46bd      	mov	sp, r7
 8001008:	f85d 7b04 	ldr.w	r7, [sp], #4
 800100c:	4770      	bx	lr
 800100e:	bf00      	nop
 8001010:	20000010 	.word	0x20000010
 8001014:	20001114 	.word	0x20001114

08001018 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8001018:	b480      	push	{r7}
 800101a:	af00      	add	r7, sp, #0
  return uwTick;
 800101c:	4b03      	ldr	r3, [pc, #12]	; (800102c <HAL_GetTick+0x14>)
 800101e:	681b      	ldr	r3, [r3, #0]
}
 8001020:	4618      	mov	r0, r3
 8001022:	46bd      	mov	sp, r7
 8001024:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001028:	4770      	bx	lr
 800102a:	bf00      	nop
 800102c:	20001114 	.word	0x20001114

08001030 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8001030:	b580      	push	{r7, lr}
 8001032:	b084      	sub	sp, #16
 8001034:	af00      	add	r7, sp, #0
 8001036:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8001038:	f7ff ffee 	bl	8001018 <HAL_GetTick>
 800103c:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 800103e:	687b      	ldr	r3, [r7, #4]
 8001040:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8001042:	68fb      	ldr	r3, [r7, #12]
 8001044:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8001048:	d005      	beq.n	8001056 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 800104a:	4b0a      	ldr	r3, [pc, #40]	; (8001074 <HAL_Delay+0x44>)
 800104c:	781b      	ldrb	r3, [r3, #0]
 800104e:	461a      	mov	r2, r3
 8001050:	68fb      	ldr	r3, [r7, #12]
 8001052:	4413      	add	r3, r2
 8001054:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8001056:	bf00      	nop
 8001058:	f7ff ffde 	bl	8001018 <HAL_GetTick>
 800105c:	4602      	mov	r2, r0
 800105e:	68bb      	ldr	r3, [r7, #8]
 8001060:	1ad3      	subs	r3, r2, r3
 8001062:	68fa      	ldr	r2, [r7, #12]
 8001064:	429a      	cmp	r2, r3
 8001066:	d8f7      	bhi.n	8001058 <HAL_Delay+0x28>
  {
  }
}
 8001068:	bf00      	nop
 800106a:	bf00      	nop
 800106c:	3710      	adds	r7, #16
 800106e:	46bd      	mov	sp, r7
 8001070:	bd80      	pop	{r7, pc}
 8001072:	bf00      	nop
 8001074:	20000010 	.word	0x20000010

08001078 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001078:	b480      	push	{r7}
 800107a:	b085      	sub	sp, #20
 800107c:	af00      	add	r7, sp, #0
 800107e:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8001080:	687b      	ldr	r3, [r7, #4]
 8001082:	f003 0307 	and.w	r3, r3, #7
 8001086:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001088:	4b0c      	ldr	r3, [pc, #48]	; (80010bc <__NVIC_SetPriorityGrouping+0x44>)
 800108a:	68db      	ldr	r3, [r3, #12]
 800108c:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800108e:	68ba      	ldr	r2, [r7, #8]
 8001090:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8001094:	4013      	ands	r3, r2
 8001096:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8001098:	68fb      	ldr	r3, [r7, #12]
 800109a:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800109c:	68bb      	ldr	r3, [r7, #8]
 800109e:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 80010a0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80010a4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80010a8:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 80010aa:	4a04      	ldr	r2, [pc, #16]	; (80010bc <__NVIC_SetPriorityGrouping+0x44>)
 80010ac:	68bb      	ldr	r3, [r7, #8]
 80010ae:	60d3      	str	r3, [r2, #12]
}
 80010b0:	bf00      	nop
 80010b2:	3714      	adds	r7, #20
 80010b4:	46bd      	mov	sp, r7
 80010b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80010ba:	4770      	bx	lr
 80010bc:	e000ed00 	.word	0xe000ed00

080010c0 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 80010c0:	b480      	push	{r7}
 80010c2:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80010c4:	4b04      	ldr	r3, [pc, #16]	; (80010d8 <__NVIC_GetPriorityGrouping+0x18>)
 80010c6:	68db      	ldr	r3, [r3, #12]
 80010c8:	0a1b      	lsrs	r3, r3, #8
 80010ca:	f003 0307 	and.w	r3, r3, #7
}
 80010ce:	4618      	mov	r0, r3
 80010d0:	46bd      	mov	sp, r7
 80010d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80010d6:	4770      	bx	lr
 80010d8:	e000ed00 	.word	0xe000ed00

080010dc <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80010dc:	b480      	push	{r7}
 80010de:	b083      	sub	sp, #12
 80010e0:	af00      	add	r7, sp, #0
 80010e2:	4603      	mov	r3, r0
 80010e4:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80010e6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80010ea:	2b00      	cmp	r3, #0
 80010ec:	db0b      	blt.n	8001106 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80010ee:	79fb      	ldrb	r3, [r7, #7]
 80010f0:	f003 021f 	and.w	r2, r3, #31
 80010f4:	4907      	ldr	r1, [pc, #28]	; (8001114 <__NVIC_EnableIRQ+0x38>)
 80010f6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80010fa:	095b      	lsrs	r3, r3, #5
 80010fc:	2001      	movs	r0, #1
 80010fe:	fa00 f202 	lsl.w	r2, r0, r2
 8001102:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8001106:	bf00      	nop
 8001108:	370c      	adds	r7, #12
 800110a:	46bd      	mov	sp, r7
 800110c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001110:	4770      	bx	lr
 8001112:	bf00      	nop
 8001114:	e000e100 	.word	0xe000e100

08001118 <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8001118:	b480      	push	{r7}
 800111a:	b083      	sub	sp, #12
 800111c:	af00      	add	r7, sp, #0
 800111e:	4603      	mov	r3, r0
 8001120:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001122:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001126:	2b00      	cmp	r3, #0
 8001128:	db12      	blt.n	8001150 <__NVIC_DisableIRQ+0x38>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800112a:	79fb      	ldrb	r3, [r7, #7]
 800112c:	f003 021f 	and.w	r2, r3, #31
 8001130:	490a      	ldr	r1, [pc, #40]	; (800115c <__NVIC_DisableIRQ+0x44>)
 8001132:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001136:	095b      	lsrs	r3, r3, #5
 8001138:	2001      	movs	r0, #1
 800113a:	fa00 f202 	lsl.w	r2, r0, r2
 800113e:	3320      	adds	r3, #32
 8001140:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 8001144:	f3bf 8f4f 	dsb	sy
}
 8001148:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 800114a:	f3bf 8f6f 	isb	sy
}
 800114e:	bf00      	nop
    __DSB();
    __ISB();
  }
}
 8001150:	bf00      	nop
 8001152:	370c      	adds	r7, #12
 8001154:	46bd      	mov	sp, r7
 8001156:	f85d 7b04 	ldr.w	r7, [sp], #4
 800115a:	4770      	bx	lr
 800115c:	e000e100 	.word	0xe000e100

08001160 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8001160:	b480      	push	{r7}
 8001162:	b083      	sub	sp, #12
 8001164:	af00      	add	r7, sp, #0
 8001166:	4603      	mov	r3, r0
 8001168:	6039      	str	r1, [r7, #0]
 800116a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800116c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001170:	2b00      	cmp	r3, #0
 8001172:	db0a      	blt.n	800118a <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001174:	683b      	ldr	r3, [r7, #0]
 8001176:	b2da      	uxtb	r2, r3
 8001178:	490c      	ldr	r1, [pc, #48]	; (80011ac <__NVIC_SetPriority+0x4c>)
 800117a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800117e:	0112      	lsls	r2, r2, #4
 8001180:	b2d2      	uxtb	r2, r2
 8001182:	440b      	add	r3, r1
 8001184:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8001188:	e00a      	b.n	80011a0 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800118a:	683b      	ldr	r3, [r7, #0]
 800118c:	b2da      	uxtb	r2, r3
 800118e:	4908      	ldr	r1, [pc, #32]	; (80011b0 <__NVIC_SetPriority+0x50>)
 8001190:	79fb      	ldrb	r3, [r7, #7]
 8001192:	f003 030f 	and.w	r3, r3, #15
 8001196:	3b04      	subs	r3, #4
 8001198:	0112      	lsls	r2, r2, #4
 800119a:	b2d2      	uxtb	r2, r2
 800119c:	440b      	add	r3, r1
 800119e:	761a      	strb	r2, [r3, #24]
}
 80011a0:	bf00      	nop
 80011a2:	370c      	adds	r7, #12
 80011a4:	46bd      	mov	sp, r7
 80011a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80011aa:	4770      	bx	lr
 80011ac:	e000e100 	.word	0xe000e100
 80011b0:	e000ed00 	.word	0xe000ed00

080011b4 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80011b4:	b480      	push	{r7}
 80011b6:	b089      	sub	sp, #36	; 0x24
 80011b8:	af00      	add	r7, sp, #0
 80011ba:	60f8      	str	r0, [r7, #12]
 80011bc:	60b9      	str	r1, [r7, #8]
 80011be:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 80011c0:	68fb      	ldr	r3, [r7, #12]
 80011c2:	f003 0307 	and.w	r3, r3, #7
 80011c6:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80011c8:	69fb      	ldr	r3, [r7, #28]
 80011ca:	f1c3 0307 	rsb	r3, r3, #7
 80011ce:	2b04      	cmp	r3, #4
 80011d0:	bf28      	it	cs
 80011d2:	2304      	movcs	r3, #4
 80011d4:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80011d6:	69fb      	ldr	r3, [r7, #28]
 80011d8:	3304      	adds	r3, #4
 80011da:	2b06      	cmp	r3, #6
 80011dc:	d902      	bls.n	80011e4 <NVIC_EncodePriority+0x30>
 80011de:	69fb      	ldr	r3, [r7, #28]
 80011e0:	3b03      	subs	r3, #3
 80011e2:	e000      	b.n	80011e6 <NVIC_EncodePriority+0x32>
 80011e4:	2300      	movs	r3, #0
 80011e6:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80011e8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80011ec:	69bb      	ldr	r3, [r7, #24]
 80011ee:	fa02 f303 	lsl.w	r3, r2, r3
 80011f2:	43da      	mvns	r2, r3
 80011f4:	68bb      	ldr	r3, [r7, #8]
 80011f6:	401a      	ands	r2, r3
 80011f8:	697b      	ldr	r3, [r7, #20]
 80011fa:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80011fc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8001200:	697b      	ldr	r3, [r7, #20]
 8001202:	fa01 f303 	lsl.w	r3, r1, r3
 8001206:	43d9      	mvns	r1, r3
 8001208:	687b      	ldr	r3, [r7, #4]
 800120a:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800120c:	4313      	orrs	r3, r2
         );
}
 800120e:	4618      	mov	r0, r3
 8001210:	3724      	adds	r7, #36	; 0x24
 8001212:	46bd      	mov	sp, r7
 8001214:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001218:	4770      	bx	lr
	...

0800121c <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 800121c:	b580      	push	{r7, lr}
 800121e:	b082      	sub	sp, #8
 8001220:	af00      	add	r7, sp, #0
 8001222:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8001224:	687b      	ldr	r3, [r7, #4]
 8001226:	3b01      	subs	r3, #1
 8001228:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 800122c:	d301      	bcc.n	8001232 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 800122e:	2301      	movs	r3, #1
 8001230:	e00f      	b.n	8001252 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001232:	4a0a      	ldr	r2, [pc, #40]	; (800125c <SysTick_Config+0x40>)
 8001234:	687b      	ldr	r3, [r7, #4]
 8001236:	3b01      	subs	r3, #1
 8001238:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800123a:	210f      	movs	r1, #15
 800123c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001240:	f7ff ff8e 	bl	8001160 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001244:	4b05      	ldr	r3, [pc, #20]	; (800125c <SysTick_Config+0x40>)
 8001246:	2200      	movs	r2, #0
 8001248:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800124a:	4b04      	ldr	r3, [pc, #16]	; (800125c <SysTick_Config+0x40>)
 800124c:	2207      	movs	r2, #7
 800124e:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8001250:	2300      	movs	r3, #0
}
 8001252:	4618      	mov	r0, r3
 8001254:	3708      	adds	r7, #8
 8001256:	46bd      	mov	sp, r7
 8001258:	bd80      	pop	{r7, pc}
 800125a:	bf00      	nop
 800125c:	e000e010 	.word	0xe000e010

08001260 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001260:	b580      	push	{r7, lr}
 8001262:	b082      	sub	sp, #8
 8001264:	af00      	add	r7, sp, #0
 8001266:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8001268:	6878      	ldr	r0, [r7, #4]
 800126a:	f7ff ff05 	bl	8001078 <__NVIC_SetPriorityGrouping>
}
 800126e:	bf00      	nop
 8001270:	3708      	adds	r7, #8
 8001272:	46bd      	mov	sp, r7
 8001274:	bd80      	pop	{r7, pc}

08001276 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8001276:	b580      	push	{r7, lr}
 8001278:	b086      	sub	sp, #24
 800127a:	af00      	add	r7, sp, #0
 800127c:	4603      	mov	r3, r0
 800127e:	60b9      	str	r1, [r7, #8]
 8001280:	607a      	str	r2, [r7, #4]
 8001282:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 8001284:	f7ff ff1c 	bl	80010c0 <__NVIC_GetPriorityGrouping>
 8001288:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 800128a:	687a      	ldr	r2, [r7, #4]
 800128c:	68b9      	ldr	r1, [r7, #8]
 800128e:	6978      	ldr	r0, [r7, #20]
 8001290:	f7ff ff90 	bl	80011b4 <NVIC_EncodePriority>
 8001294:	4602      	mov	r2, r0
 8001296:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800129a:	4611      	mov	r1, r2
 800129c:	4618      	mov	r0, r3
 800129e:	f7ff ff5f 	bl	8001160 <__NVIC_SetPriority>
}
 80012a2:	bf00      	nop
 80012a4:	3718      	adds	r7, #24
 80012a6:	46bd      	mov	sp, r7
 80012a8:	bd80      	pop	{r7, pc}

080012aa <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate
  *          CMSIS device file (stm32u5xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80012aa:	b580      	push	{r7, lr}
 80012ac:	b082      	sub	sp, #8
 80012ae:	af00      	add	r7, sp, #0
 80012b0:	4603      	mov	r3, r0
 80012b2:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 80012b4:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80012b8:	4618      	mov	r0, r3
 80012ba:	f7ff ff0f 	bl	80010dc <__NVIC_EnableIRQ>
}
 80012be:	bf00      	nop
 80012c0:	3708      	adds	r7, #8
 80012c2:	46bd      	mov	sp, r7
 80012c4:	bd80      	pop	{r7, pc}

080012c6 <HAL_NVIC_DisableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate
  *          CMSIS device file (stm32u5xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 80012c6:	b580      	push	{r7, lr}
 80012c8:	b082      	sub	sp, #8
 80012ca:	af00      	add	r7, sp, #0
 80012cc:	4603      	mov	r3, r0
 80012ce:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
 80012d0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80012d4:	4618      	mov	r0, r3
 80012d6:	f7ff ff1f 	bl	8001118 <__NVIC_DisableIRQ>
}
 80012da:	bf00      	nop
 80012dc:	3708      	adds	r7, #8
 80012de:	46bd      	mov	sp, r7
 80012e0:	bd80      	pop	{r7, pc}

080012e2 <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80012e2:	b580      	push	{r7, lr}
 80012e4:	b082      	sub	sp, #8
 80012e6:	af00      	add	r7, sp, #0
 80012e8:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
 80012ea:	6878      	ldr	r0, [r7, #4]
 80012ec:	f7ff ff96 	bl	800121c <SysTick_Config>
 80012f0:	4603      	mov	r3, r0
}
 80012f2:	4618      	mov	r0, r3
 80012f4:	3708      	adds	r7, #8
 80012f6:	46bd      	mov	sp, r7
 80012f8:	bd80      	pop	{r7, pc}

080012fa <HAL_DMA_Abort>:
  *         is suspended while a data transfer is on-going, the current data will be transferred and the channel will be
  *         effectively suspended only after the transfer of any on-going data is finished.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *const hdma)
{
 80012fa:	b580      	push	{r7, lr}
 80012fc:	b084      	sub	sp, #16
 80012fe:	af00      	add	r7, sp, #0
 8001300:	6078      	str	r0, [r7, #4]
  /* Get tick number */
  uint32_t tickstart =  HAL_GetTick();
 8001302:	f7ff fe89 	bl	8001018 <HAL_GetTick>
 8001306:	60f8      	str	r0, [r7, #12]

  /* Check the DMA peripheral handle parameter */
  if (hdma == NULL)
 8001308:	687b      	ldr	r3, [r7, #4]
 800130a:	2b00      	cmp	r3, #0
 800130c:	d101      	bne.n	8001312 <HAL_DMA_Abort+0x18>
  {
    return HAL_ERROR;
 800130e:	2301      	movs	r3, #1
 8001310:	e06b      	b.n	80013ea <HAL_DMA_Abort+0xf0>
  }

  /* Check DMA channel state */
  if (hdma->State != HAL_DMA_STATE_BUSY)
 8001312:	687b      	ldr	r3, [r7, #4]
 8001314:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 8001318:	b2db      	uxtb	r3, r3
 800131a:	2b02      	cmp	r3, #2
 800131c:	d008      	beq.n	8001330 <HAL_DMA_Abort+0x36>
  {
    /* Update the DMA channel error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800131e:	687b      	ldr	r3, [r7, #4]
 8001320:	2220      	movs	r2, #32
 8001322:	659a      	str	r2, [r3, #88]	; 0x58

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8001324:	687b      	ldr	r3, [r7, #4]
 8001326:	2200      	movs	r2, #0
 8001328:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

    return HAL_ERROR;
 800132c:	2301      	movs	r3, #1
 800132e:	e05c      	b.n	80013ea <HAL_DMA_Abort+0xf0>
  }
  else
  {
    /* Suspend the channel */
    hdma->Instance->CCR |= DMA_CCR_SUSP;
 8001330:	687b      	ldr	r3, [r7, #4]
 8001332:	681b      	ldr	r3, [r3, #0]
 8001334:	695a      	ldr	r2, [r3, #20]
 8001336:	687b      	ldr	r3, [r7, #4]
 8001338:	681b      	ldr	r3, [r3, #0]
 800133a:	f042 0204 	orr.w	r2, r2, #4
 800133e:	615a      	str	r2, [r3, #20]

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_SUSPEND;
 8001340:	687b      	ldr	r3, [r7, #4]
 8001342:	2205      	movs	r2, #5
 8001344:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

    /* Check if the DMA Channel is suspended */
    while ((hdma->Instance->CSR & DMA_CSR_SUSPF) == 0U)
 8001348:	e020      	b.n	800138c <HAL_DMA_Abort+0x92>
    {
      /* Check for the Timeout */
      if ((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
 800134a:	f7ff fe65 	bl	8001018 <HAL_GetTick>
 800134e:	4602      	mov	r2, r0
 8001350:	68fb      	ldr	r3, [r7, #12]
 8001352:	1ad3      	subs	r3, r2, r3
 8001354:	2b05      	cmp	r3, #5
 8001356:	d919      	bls.n	800138c <HAL_DMA_Abort+0x92>
      {
        /* Update the DMA channel error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
 8001358:	687b      	ldr	r3, [r7, #4]
 800135a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800135c:	f043 0210 	orr.w	r2, r3, #16
 8001360:	687b      	ldr	r3, [r7, #4]
 8001362:	659a      	str	r2, [r3, #88]	; 0x58

        /* Update the DMA channel state */
        hdma->State = HAL_DMA_STATE_ERROR;
 8001364:	687b      	ldr	r3, [r7, #4]
 8001366:	2203      	movs	r2, #3
 8001368:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

        /* Check DMA channel transfer mode */
        if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
 800136c:	687b      	ldr	r3, [r7, #4]
 800136e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001370:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8001374:	2b00      	cmp	r3, #0
 8001376:	d003      	beq.n	8001380 <HAL_DMA_Abort+0x86>
        {
          /* Update the linked-list queue state */
          hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
 8001378:	687b      	ldr	r3, [r7, #4]
 800137a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800137c:	2201      	movs	r2, #1
 800137e:	731a      	strb	r2, [r3, #12]
        }

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 8001380:	687b      	ldr	r3, [r7, #4]
 8001382:	2200      	movs	r2, #0
 8001384:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

        return HAL_ERROR;
 8001388:	2301      	movs	r3, #1
 800138a:	e02e      	b.n	80013ea <HAL_DMA_Abort+0xf0>
    while ((hdma->Instance->CSR & DMA_CSR_SUSPF) == 0U)
 800138c:	687b      	ldr	r3, [r7, #4]
 800138e:	681b      	ldr	r3, [r3, #0]
 8001390:	691b      	ldr	r3, [r3, #16]
 8001392:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8001396:	2b00      	cmp	r3, #0
 8001398:	d0d7      	beq.n	800134a <HAL_DMA_Abort+0x50>
      }
    }

    /* Reset the channel */
    hdma->Instance->CCR |= DMA_CCR_RESET;
 800139a:	687b      	ldr	r3, [r7, #4]
 800139c:	681b      	ldr	r3, [r3, #0]
 800139e:	695a      	ldr	r2, [r3, #20]
 80013a0:	687b      	ldr	r3, [r7, #4]
 80013a2:	681b      	ldr	r3, [r3, #0]
 80013a4:	f042 0202 	orr.w	r2, r2, #2
 80013a8:	615a      	str	r2, [r3, #20]

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_ABORT;
 80013aa:	687b      	ldr	r3, [r7, #4]
 80013ac:	2204      	movs	r2, #4
 80013ae:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

    /* Clear all status flags */
    __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC | DMA_FLAG_HT | DMA_FLAG_DTE | DMA_FLAG_ULE | DMA_FLAG_USE | DMA_FLAG_SUSP |
 80013b2:	687b      	ldr	r3, [r7, #4]
 80013b4:	681b      	ldr	r3, [r3, #0]
 80013b6:	f44f 42fe 	mov.w	r2, #32512	; 0x7f00
 80013ba:	60da      	str	r2, [r3, #12]
                                DMA_FLAG_TO));

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_READY;
 80013bc:	687b      	ldr	r3, [r7, #4]
 80013be:	2201      	movs	r2, #1
 80013c0:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

    /* Check DMA channel transfer mode */
    if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
 80013c4:	687b      	ldr	r3, [r7, #4]
 80013c6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80013c8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80013cc:	2b00      	cmp	r3, #0
 80013ce:	d007      	beq.n	80013e0 <HAL_DMA_Abort+0xe6>
    {
      /* Update the linked-list queue state */
      hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
 80013d0:	687b      	ldr	r3, [r7, #4]
 80013d2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80013d4:	2201      	movs	r2, #1
 80013d6:	731a      	strb	r2, [r3, #12]

      /* Clear remaining data size to ensure loading linked-list from memory next start */
      hdma->Instance->CBR1 = 0U;
 80013d8:	687b      	ldr	r3, [r7, #4]
 80013da:	681b      	ldr	r3, [r3, #0]
 80013dc:	2200      	movs	r2, #0
 80013de:	649a      	str	r2, [r3, #72]	; 0x48
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80013e0:	687b      	ldr	r3, [r7, #4]
 80013e2:	2200      	movs	r2, #0
 80013e4:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
  }

  return HAL_OK;
 80013e8:	2300      	movs	r3, #0
}
 80013ea:	4618      	mov	r0, r3
 80013ec:	3710      	adds	r7, #16
 80013ee:	46bd      	mov	sp, r7
 80013f0:	bd80      	pop	{r7, pc}

080013f2 <HAL_DMA_Abort_IT>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *const hdma)
{
 80013f2:	b480      	push	{r7}
 80013f4:	b083      	sub	sp, #12
 80013f6:	af00      	add	r7, sp, #0
 80013f8:	6078      	str	r0, [r7, #4]
  /* Check the DMA peripheral handle parameter */
  if (hdma == NULL)
 80013fa:	687b      	ldr	r3, [r7, #4]
 80013fc:	2b00      	cmp	r3, #0
 80013fe:	d101      	bne.n	8001404 <HAL_DMA_Abort_IT+0x12>
  {
    return HAL_ERROR;
 8001400:	2301      	movs	r3, #1
 8001402:	e019      	b.n	8001438 <HAL_DMA_Abort_IT+0x46>
  }

  /* Check DMA channel state */
  if (hdma->State != HAL_DMA_STATE_BUSY)
 8001404:	687b      	ldr	r3, [r7, #4]
 8001406:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 800140a:	b2db      	uxtb	r3, r3
 800140c:	2b02      	cmp	r3, #2
 800140e:	d004      	beq.n	800141a <HAL_DMA_Abort_IT+0x28>
  {
    /* Update the DMA channel error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8001410:	687b      	ldr	r3, [r7, #4]
 8001412:	2220      	movs	r2, #32
 8001414:	659a      	str	r2, [r3, #88]	; 0x58

    return HAL_ERROR;
 8001416:	2301      	movs	r3, #1
 8001418:	e00e      	b.n	8001438 <HAL_DMA_Abort_IT+0x46>
  }
  else
  {
    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_ABORT;
 800141a:	687b      	ldr	r3, [r7, #4]
 800141c:	2204      	movs	r2, #4
 800141e:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

    /* Suspend the channel and activate suspend interrupt */
    hdma->Instance->CCR |= (DMA_CCR_SUSP | DMA_CCR_SUSPIE);
 8001422:	687b      	ldr	r3, [r7, #4]
 8001424:	681b      	ldr	r3, [r3, #0]
 8001426:	695b      	ldr	r3, [r3, #20]
 8001428:	687a      	ldr	r2, [r7, #4]
 800142a:	6812      	ldr	r2, [r2, #0]
 800142c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001430:	f043 0304 	orr.w	r3, r3, #4
 8001434:	6153      	str	r3, [r2, #20]
  }

  return HAL_OK;
 8001436:	2300      	movs	r3, #0
}
 8001438:	4618      	mov	r0, r3
 800143a:	370c      	adds	r7, #12
 800143c:	46bd      	mov	sp, r7
 800143e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001442:	4770      	bx	lr

08001444 <HAL_GPIO_Init>:
  * @param  pGPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *pGPIO_Init)
{
 8001444:	b480      	push	{r7}
 8001446:	b089      	sub	sp, #36	; 0x24
 8001448:	af00      	add	r7, sp, #0
 800144a:	6078      	str	r0, [r7, #4]
 800144c:	6039      	str	r1, [r7, #0]
  uint32_t tmp;
  uint32_t iocurrent;
  uint32_t pin_position;
  uint32_t position = 0U;
 800144e:	2300      	movs	r3, #0
 8001450:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(pGPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(pGPIO_Init->Mode));

  /* Save GPIO port address */
  p_gpio = GPIOx;
 8001452:	687b      	ldr	r3, [r7, #4]
 8001454:	613b      	str	r3, [r7, #16]

  /* Configure the port pins */
  while (((pGPIO_Init->Pin) >> position) != 0U)
 8001456:	e1ba      	b.n	80017ce <HAL_GPIO_Init+0x38a>
  {
    /* Get current io position */
    iocurrent = (pGPIO_Init->Pin) & (1UL << position);
 8001458:	683b      	ldr	r3, [r7, #0]
 800145a:	681a      	ldr	r2, [r3, #0]
 800145c:	2101      	movs	r1, #1
 800145e:	697b      	ldr	r3, [r7, #20]
 8001460:	fa01 f303 	lsl.w	r3, r1, r3
 8001464:	4013      	ands	r3, r2
 8001466:	60fb      	str	r3, [r7, #12]

    /* Save Pin Position */
    pin_position = position;
 8001468:	697b      	ldr	r3, [r7, #20]
 800146a:	61bb      	str	r3, [r7, #24]

    if (iocurrent != 0U)
 800146c:	68fb      	ldr	r3, [r7, #12]
 800146e:	2b00      	cmp	r3, #0
 8001470:	f000 81aa 	beq.w	80017c8 <HAL_GPIO_Init+0x384>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if (GPIOx == LPGPIO1)
 8001474:	687b      	ldr	r3, [r7, #4]
 8001476:	4a55      	ldr	r2, [pc, #340]	; (80015cc <HAL_GPIO_Init+0x188>)
 8001478:	4293      	cmp	r3, r2
 800147a:	d15d      	bne.n	8001538 <HAL_GPIO_Init+0xf4>
      {
        /* MODER configuration */
        tmp = GPIOx->MODER;
 800147c:	687b      	ldr	r3, [r7, #4]
 800147e:	681b      	ldr	r3, [r3, #0]
 8001480:	61fb      	str	r3, [r7, #28]
        tmp &= ~(LPGPIO_MODER_MOD0 << position);
 8001482:	2201      	movs	r2, #1
 8001484:	697b      	ldr	r3, [r7, #20]
 8001486:	fa02 f303 	lsl.w	r3, r2, r3
 800148a:	43db      	mvns	r3, r3
 800148c:	69fa      	ldr	r2, [r7, #28]
 800148e:	4013      	ands	r3, r2
 8001490:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE_OUTPUT_PP) << position);
 8001492:	683b      	ldr	r3, [r7, #0]
 8001494:	685b      	ldr	r3, [r3, #4]
 8001496:	f003 0201 	and.w	r2, r3, #1
 800149a:	697b      	ldr	r3, [r7, #20]
 800149c:	fa02 f303 	lsl.w	r3, r2, r3
 80014a0:	69fa      	ldr	r2, [r7, #28]
 80014a2:	4313      	orrs	r3, r2
 80014a4:	61fb      	str	r3, [r7, #28]
        GPIOx->MODER = tmp;
 80014a6:	687b      	ldr	r3, [r7, #4]
 80014a8:	69fa      	ldr	r2, [r7, #28]
 80014aa:	601a      	str	r2, [r3, #0]

        /* Save GPIO Port and pin index */
        p_gpio = LPGPIO_Map[position].GPIO_PORT;
 80014ac:	4a48      	ldr	r2, [pc, #288]	; (80015d0 <HAL_GPIO_Init+0x18c>)
 80014ae:	697b      	ldr	r3, [r7, #20]
 80014b0:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 80014b4:	613b      	str	r3, [r7, #16]
        pin_position = LPGPIO_Map[position].Pin_Pos;
 80014b6:	4a46      	ldr	r2, [pc, #280]	; (80015d0 <HAL_GPIO_Init+0x18c>)
 80014b8:	697b      	ldr	r3, [r7, #20]
 80014ba:	00db      	lsls	r3, r3, #3
 80014bc:	4413      	add	r3, r2
 80014be:	685b      	ldr	r3, [r3, #4]
 80014c0:	61bb      	str	r3, [r7, #24]

        /* Configure Alternate function mapped with the current IO */
        tmp = p_gpio->AFR[(pin_position) >> 3U];
 80014c2:	69bb      	ldr	r3, [r7, #24]
 80014c4:	08da      	lsrs	r2, r3, #3
 80014c6:	693b      	ldr	r3, [r7, #16]
 80014c8:	3208      	adds	r2, #8
 80014ca:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80014ce:	61fb      	str	r3, [r7, #28]
        tmp &= ~(0x0FUL << (((pin_position) & 0x07U) * 4U));
 80014d0:	69bb      	ldr	r3, [r7, #24]
 80014d2:	f003 0307 	and.w	r3, r3, #7
 80014d6:	009b      	lsls	r3, r3, #2
 80014d8:	220f      	movs	r2, #15
 80014da:	fa02 f303 	lsl.w	r3, r2, r3
 80014de:	43db      	mvns	r3, r3
 80014e0:	69fa      	ldr	r2, [r7, #28]
 80014e2:	4013      	ands	r3, r2
 80014e4:	61fb      	str	r3, [r7, #28]
        tmp |= ((GPIO_AF11_LPGPIO1 & 0x0FUL) << (((pin_position) & 0x07U) * 4U));
 80014e6:	69bb      	ldr	r3, [r7, #24]
 80014e8:	f003 0307 	and.w	r3, r3, #7
 80014ec:	009b      	lsls	r3, r3, #2
 80014ee:	220b      	movs	r2, #11
 80014f0:	fa02 f303 	lsl.w	r3, r2, r3
 80014f4:	69fa      	ldr	r2, [r7, #28]
 80014f6:	4313      	orrs	r3, r2
 80014f8:	61fb      	str	r3, [r7, #28]
        p_gpio->AFR[(pin_position) >> 3U] = tmp;
 80014fa:	69bb      	ldr	r3, [r7, #24]
 80014fc:	08da      	lsrs	r2, r3, #3
 80014fe:	693b      	ldr	r3, [r7, #16]
 8001500:	3208      	adds	r2, #8
 8001502:	69f9      	ldr	r1, [r7, #28]
 8001504:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

        /* Configure IO Direction mode (Alternate) */
        tmp = p_gpio->MODER;
 8001508:	693b      	ldr	r3, [r7, #16]
 800150a:	681b      	ldr	r3, [r3, #0]
 800150c:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * 2U));
 800150e:	69bb      	ldr	r3, [r7, #24]
 8001510:	005b      	lsls	r3, r3, #1
 8001512:	2203      	movs	r2, #3
 8001514:	fa02 f303 	lsl.w	r3, r2, r3
 8001518:	43db      	mvns	r3, r3
 800151a:	69fa      	ldr	r2, [r7, #28]
 800151c:	4013      	ands	r3, r2
 800151e:	61fb      	str	r3, [r7, #28]
        tmp |= ((GPIO_MODE_AF_PP & 0x0FUL) << (pin_position * 2U));
 8001520:	69bb      	ldr	r3, [r7, #24]
 8001522:	005b      	lsls	r3, r3, #1
 8001524:	2202      	movs	r2, #2
 8001526:	fa02 f303 	lsl.w	r3, r2, r3
 800152a:	69fa      	ldr	r2, [r7, #28]
 800152c:	4313      	orrs	r3, r2
 800152e:	61fb      	str	r3, [r7, #28]
        p_gpio->MODER = tmp;
 8001530:	693b      	ldr	r3, [r7, #16]
 8001532:	69fa      	ldr	r2, [r7, #28]
 8001534:	601a      	str	r2, [r3, #0]
 8001536:	e067      	b.n	8001608 <HAL_GPIO_Init+0x1c4>
      }
      else if ((pGPIO_Init->Mode == GPIO_MODE_AF_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001538:	683b      	ldr	r3, [r7, #0]
 800153a:	685b      	ldr	r3, [r3, #4]
 800153c:	2b02      	cmp	r3, #2
 800153e:	d003      	beq.n	8001548 <HAL_GPIO_Init+0x104>
 8001540:	683b      	ldr	r3, [r7, #0]
 8001542:	685b      	ldr	r3, [r3, #4]
 8001544:	2b12      	cmp	r3, #18
 8001546:	d145      	bne.n	80015d4 <HAL_GPIO_Init+0x190>
        assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(pGPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        tmp = GPIOx->AFR[position >> 3U];
 8001548:	697b      	ldr	r3, [r7, #20]
 800154a:	08da      	lsrs	r2, r3, #3
 800154c:	687b      	ldr	r3, [r7, #4]
 800154e:	3208      	adds	r2, #8
 8001550:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8001554:	61fb      	str	r3, [r7, #28]
        tmp &= ~(0x0FUL << ((position & 0x07U) * 4U));
 8001556:	697b      	ldr	r3, [r7, #20]
 8001558:	f003 0307 	and.w	r3, r3, #7
 800155c:	009b      	lsls	r3, r3, #2
 800155e:	220f      	movs	r2, #15
 8001560:	fa02 f303 	lsl.w	r3, r2, r3
 8001564:	43db      	mvns	r3, r3
 8001566:	69fa      	ldr	r2, [r7, #28]
 8001568:	4013      	ands	r3, r2
 800156a:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Alternate & 0x0FUL) << ((position & 0x07U) * 4U));
 800156c:	683b      	ldr	r3, [r7, #0]
 800156e:	691b      	ldr	r3, [r3, #16]
 8001570:	f003 020f 	and.w	r2, r3, #15
 8001574:	697b      	ldr	r3, [r7, #20]
 8001576:	f003 0307 	and.w	r3, r3, #7
 800157a:	009b      	lsls	r3, r3, #2
 800157c:	fa02 f303 	lsl.w	r3, r2, r3
 8001580:	69fa      	ldr	r2, [r7, #28]
 8001582:	4313      	orrs	r3, r2
 8001584:	61fb      	str	r3, [r7, #28]
        GPIOx->AFR[position >> 3U] = tmp;
 8001586:	697b      	ldr	r3, [r7, #20]
 8001588:	08da      	lsrs	r2, r3, #3
 800158a:	687b      	ldr	r3, [r7, #4]
 800158c:	3208      	adds	r2, #8
 800158e:	69f9      	ldr	r1, [r7, #28]
 8001590:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

        /* Configure IO Direction mode (Alternate) */
        tmp = p_gpio->MODER;
 8001594:	693b      	ldr	r3, [r7, #16]
 8001596:	681b      	ldr	r3, [r3, #0]
 8001598:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * 2U));
 800159a:	69bb      	ldr	r3, [r7, #24]
 800159c:	005b      	lsls	r3, r3, #1
 800159e:	2203      	movs	r2, #3
 80015a0:	fa02 f303 	lsl.w	r3, r2, r3
 80015a4:	43db      	mvns	r3, r3
 80015a6:	69fa      	ldr	r2, [r7, #28]
 80015a8:	4013      	ands	r3, r2
 80015aa:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (pin_position * 2U));
 80015ac:	683b      	ldr	r3, [r7, #0]
 80015ae:	685b      	ldr	r3, [r3, #4]
 80015b0:	f003 0203 	and.w	r2, r3, #3
 80015b4:	69bb      	ldr	r3, [r7, #24]
 80015b6:	005b      	lsls	r3, r3, #1
 80015b8:	fa02 f303 	lsl.w	r3, r2, r3
 80015bc:	69fa      	ldr	r2, [r7, #28]
 80015be:	4313      	orrs	r3, r2
 80015c0:	61fb      	str	r3, [r7, #28]
        p_gpio->MODER = tmp;
 80015c2:	693b      	ldr	r3, [r7, #16]
 80015c4:	69fa      	ldr	r2, [r7, #28]
 80015c6:	601a      	str	r2, [r3, #0]
 80015c8:	e01e      	b.n	8001608 <HAL_GPIO_Init+0x1c4>
 80015ca:	bf00      	nop
 80015cc:	46020000 	.word	0x46020000
 80015d0:	08006e6c 	.word	0x08006e6c
      {
        /* Check the parameters */
        assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));

        /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
        tmp = p_gpio->MODER;
 80015d4:	693b      	ldr	r3, [r7, #16]
 80015d6:	681b      	ldr	r3, [r3, #0]
 80015d8:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * 2U));
 80015da:	69bb      	ldr	r3, [r7, #24]
 80015dc:	005b      	lsls	r3, r3, #1
 80015de:	2203      	movs	r2, #3
 80015e0:	fa02 f303 	lsl.w	r3, r2, r3
 80015e4:	43db      	mvns	r3, r3
 80015e6:	69fa      	ldr	r2, [r7, #28]
 80015e8:	4013      	ands	r3, r2
 80015ea:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (pin_position * 2U));
 80015ec:	683b      	ldr	r3, [r7, #0]
 80015ee:	685b      	ldr	r3, [r3, #4]
 80015f0:	f003 0203 	and.w	r2, r3, #3
 80015f4:	69bb      	ldr	r3, [r7, #24]
 80015f6:	005b      	lsls	r3, r3, #1
 80015f8:	fa02 f303 	lsl.w	r3, r2, r3
 80015fc:	69fa      	ldr	r2, [r7, #28]
 80015fe:	4313      	orrs	r3, r2
 8001600:	61fb      	str	r3, [r7, #28]
        p_gpio->MODER = tmp;
 8001602:	693b      	ldr	r3, [r7, #16]
 8001604:	69fa      	ldr	r2, [r7, #28]
 8001606:	601a      	str	r2, [r3, #0]
      }

      /* In case of Output or Alternate function mode selection */
      if ((pGPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001608:	683b      	ldr	r3, [r7, #0]
 800160a:	685b      	ldr	r3, [r3, #4]
 800160c:	2b01      	cmp	r3, #1
 800160e:	d00b      	beq.n	8001628 <HAL_GPIO_Init+0x1e4>
 8001610:	683b      	ldr	r3, [r7, #0]
 8001612:	685b      	ldr	r3, [r3, #4]
 8001614:	2b02      	cmp	r3, #2
 8001616:	d007      	beq.n	8001628 <HAL_GPIO_Init+0x1e4>
          (pGPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001618:	683b      	ldr	r3, [r7, #0]
 800161a:	685b      	ldr	r3, [r3, #4]
      if ((pGPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800161c:	2b11      	cmp	r3, #17
 800161e:	d003      	beq.n	8001628 <HAL_GPIO_Init+0x1e4>
          (pGPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001620:	683b      	ldr	r3, [r7, #0]
 8001622:	685b      	ldr	r3, [r3, #4]
 8001624:	2b12      	cmp	r3, #18
 8001626:	d130      	bne.n	800168a <HAL_GPIO_Init+0x246>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(pGPIO_Init->Speed));

        /* Configure the IO Speed */
        tmp = p_gpio->OSPEEDR;
 8001628:	693b      	ldr	r3, [r7, #16]
 800162a:	689b      	ldr	r3, [r3, #8]
 800162c:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_OSPEEDR_OSPEED0 << (pin_position * 2U));
 800162e:	69bb      	ldr	r3, [r7, #24]
 8001630:	005b      	lsls	r3, r3, #1
 8001632:	2203      	movs	r2, #3
 8001634:	fa02 f303 	lsl.w	r3, r2, r3
 8001638:	43db      	mvns	r3, r3
 800163a:	69fa      	ldr	r2, [r7, #28]
 800163c:	4013      	ands	r3, r2
 800163e:	61fb      	str	r3, [r7, #28]
        tmp |= (pGPIO_Init->Speed << (pin_position * 2U));
 8001640:	683b      	ldr	r3, [r7, #0]
 8001642:	68da      	ldr	r2, [r3, #12]
 8001644:	69bb      	ldr	r3, [r7, #24]
 8001646:	005b      	lsls	r3, r3, #1
 8001648:	fa02 f303 	lsl.w	r3, r2, r3
 800164c:	69fa      	ldr	r2, [r7, #28]
 800164e:	4313      	orrs	r3, r2
 8001650:	61fb      	str	r3, [r7, #28]
        p_gpio->OSPEEDR = tmp;
 8001652:	693b      	ldr	r3, [r7, #16]
 8001654:	69fa      	ldr	r2, [r7, #28]
 8001656:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        tmp = p_gpio->OTYPER;
 8001658:	693b      	ldr	r3, [r7, #16]
 800165a:	685b      	ldr	r3, [r3, #4]
 800165c:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_OTYPER_OT0 << pin_position);
 800165e:	2201      	movs	r2, #1
 8001660:	69bb      	ldr	r3, [r7, #24]
 8001662:	fa02 f303 	lsl.w	r3, r2, r3
 8001666:	43db      	mvns	r3, r3
 8001668:	69fa      	ldr	r2, [r7, #28]
 800166a:	4013      	ands	r3, r2
 800166c:	61fb      	str	r3, [r7, #28]
        tmp |= (((pGPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << pin_position);
 800166e:	683b      	ldr	r3, [r7, #0]
 8001670:	685b      	ldr	r3, [r3, #4]
 8001672:	091b      	lsrs	r3, r3, #4
 8001674:	f003 0201 	and.w	r2, r3, #1
 8001678:	69bb      	ldr	r3, [r7, #24]
 800167a:	fa02 f303 	lsl.w	r3, r2, r3
 800167e:	69fa      	ldr	r2, [r7, #28]
 8001680:	4313      	orrs	r3, r2
 8001682:	61fb      	str	r3, [r7, #28]
        p_gpio->OTYPER = tmp;
 8001684:	693b      	ldr	r3, [r7, #16]
 8001686:	69fa      	ldr	r2, [r7, #28]
 8001688:	605a      	str	r2, [r3, #4]
      }

      if (pGPIO_Init->Mode != GPIO_MODE_ANALOG)
 800168a:	683b      	ldr	r3, [r7, #0]
 800168c:	685b      	ldr	r3, [r3, #4]
 800168e:	2b03      	cmp	r3, #3
 8001690:	d017      	beq.n	80016c2 <HAL_GPIO_Init+0x27e>
      {
        /* Check the Pull parameters */
        assert_param(IS_GPIO_PULL(pGPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        tmp = p_gpio->PUPDR;
 8001692:	693b      	ldr	r3, [r7, #16]
 8001694:	68db      	ldr	r3, [r3, #12]
 8001696:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_PUPDR_PUPD0 << (pin_position * 2U));
 8001698:	69bb      	ldr	r3, [r7, #24]
 800169a:	005b      	lsls	r3, r3, #1
 800169c:	2203      	movs	r2, #3
 800169e:	fa02 f303 	lsl.w	r3, r2, r3
 80016a2:	43db      	mvns	r3, r3
 80016a4:	69fa      	ldr	r2, [r7, #28]
 80016a6:	4013      	ands	r3, r2
 80016a8:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Pull) << (pin_position * 2U));
 80016aa:	683b      	ldr	r3, [r7, #0]
 80016ac:	689a      	ldr	r2, [r3, #8]
 80016ae:	69bb      	ldr	r3, [r7, #24]
 80016b0:	005b      	lsls	r3, r3, #1
 80016b2:	fa02 f303 	lsl.w	r3, r2, r3
 80016b6:	69fa      	ldr	r2, [r7, #28]
 80016b8:	4313      	orrs	r3, r2
 80016ba:	61fb      	str	r3, [r7, #28]
        p_gpio->PUPDR = tmp;
 80016bc:	693b      	ldr	r3, [r7, #16]
 80016be:	69fa      	ldr	r2, [r7, #28]
 80016c0:	60da      	str	r2, [r3, #12]
      }

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((pGPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80016c2:	683b      	ldr	r3, [r7, #0]
 80016c4:	685b      	ldr	r3, [r3, #4]
 80016c6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80016ca:	2b00      	cmp	r3, #0
 80016cc:	d07c      	beq.n	80017c8 <HAL_GPIO_Init+0x384>
      {
        tmp = EXTI->EXTICR[position >> 2U];
 80016ce:	4a47      	ldr	r2, [pc, #284]	; (80017ec <HAL_GPIO_Init+0x3a8>)
 80016d0:	697b      	ldr	r3, [r7, #20]
 80016d2:	089b      	lsrs	r3, r3, #2
 80016d4:	3318      	adds	r3, #24
 80016d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80016da:	61fb      	str	r3, [r7, #28]
        tmp &= ~((0x0FUL) << (8U * (position & 0x03U)));
 80016dc:	697b      	ldr	r3, [r7, #20]
 80016de:	f003 0303 	and.w	r3, r3, #3
 80016e2:	00db      	lsls	r3, r3, #3
 80016e4:	220f      	movs	r2, #15
 80016e6:	fa02 f303 	lsl.w	r3, r2, r3
 80016ea:	43db      	mvns	r3, r3
 80016ec:	69fa      	ldr	r2, [r7, #28]
 80016ee:	4013      	ands	r3, r2
 80016f0:	61fb      	str	r3, [r7, #28]
        tmp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 80016f2:	687b      	ldr	r3, [r7, #4]
 80016f4:	0a9a      	lsrs	r2, r3, #10
 80016f6:	4b3e      	ldr	r3, [pc, #248]	; (80017f0 <HAL_GPIO_Init+0x3ac>)
 80016f8:	4013      	ands	r3, r2
 80016fa:	697a      	ldr	r2, [r7, #20]
 80016fc:	f002 0203 	and.w	r2, r2, #3
 8001700:	00d2      	lsls	r2, r2, #3
 8001702:	4093      	lsls	r3, r2
 8001704:	69fa      	ldr	r2, [r7, #28]
 8001706:	4313      	orrs	r3, r2
 8001708:	61fb      	str	r3, [r7, #28]
        EXTI->EXTICR[position >> 2U] = tmp;
 800170a:	4938      	ldr	r1, [pc, #224]	; (80017ec <HAL_GPIO_Init+0x3a8>)
 800170c:	697b      	ldr	r3, [r7, #20]
 800170e:	089b      	lsrs	r3, r3, #2
 8001710:	3318      	adds	r3, #24
 8001712:	69fa      	ldr	r2, [r7, #28]
 8001714:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        tmp = EXTI->RTSR1;
 8001718:	4b34      	ldr	r3, [pc, #208]	; (80017ec <HAL_GPIO_Init+0x3a8>)
 800171a:	681b      	ldr	r3, [r3, #0]
 800171c:	61fb      	str	r3, [r7, #28]
        tmp &= ~((uint32_t)iocurrent);
 800171e:	68fb      	ldr	r3, [r7, #12]
 8001720:	43db      	mvns	r3, r3
 8001722:	69fa      	ldr	r2, [r7, #28]
 8001724:	4013      	ands	r3, r2
 8001726:	61fb      	str	r3, [r7, #28]
        if ((pGPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001728:	683b      	ldr	r3, [r7, #0]
 800172a:	685b      	ldr	r3, [r3, #4]
 800172c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8001730:	2b00      	cmp	r3, #0
 8001732:	d003      	beq.n	800173c <HAL_GPIO_Init+0x2f8>
        {
          tmp |= iocurrent;
 8001734:	69fa      	ldr	r2, [r7, #28]
 8001736:	68fb      	ldr	r3, [r7, #12]
 8001738:	4313      	orrs	r3, r2
 800173a:	61fb      	str	r3, [r7, #28]
        }
        EXTI->RTSR1 = tmp;
 800173c:	4a2b      	ldr	r2, [pc, #172]	; (80017ec <HAL_GPIO_Init+0x3a8>)
 800173e:	69fb      	ldr	r3, [r7, #28]
 8001740:	6013      	str	r3, [r2, #0]

        tmp = EXTI->FTSR1;
 8001742:	4b2a      	ldr	r3, [pc, #168]	; (80017ec <HAL_GPIO_Init+0x3a8>)
 8001744:	685b      	ldr	r3, [r3, #4]
 8001746:	61fb      	str	r3, [r7, #28]
        tmp &= ~((uint32_t)iocurrent);
 8001748:	68fb      	ldr	r3, [r7, #12]
 800174a:	43db      	mvns	r3, r3
 800174c:	69fa      	ldr	r2, [r7, #28]
 800174e:	4013      	ands	r3, r2
 8001750:	61fb      	str	r3, [r7, #28]
        if ((pGPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001752:	683b      	ldr	r3, [r7, #0]
 8001754:	685b      	ldr	r3, [r3, #4]
 8001756:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800175a:	2b00      	cmp	r3, #0
 800175c:	d003      	beq.n	8001766 <HAL_GPIO_Init+0x322>
        {
          tmp |= iocurrent;
 800175e:	69fa      	ldr	r2, [r7, #28]
 8001760:	68fb      	ldr	r3, [r7, #12]
 8001762:	4313      	orrs	r3, r2
 8001764:	61fb      	str	r3, [r7, #28]
        }
        EXTI->FTSR1 = tmp;
 8001766:	4a21      	ldr	r2, [pc, #132]	; (80017ec <HAL_GPIO_Init+0x3a8>)
 8001768:	69fb      	ldr	r3, [r7, #28]
 800176a:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        tmp = EXTI->EMR1;
 800176c:	4b1f      	ldr	r3, [pc, #124]	; (80017ec <HAL_GPIO_Init+0x3a8>)
 800176e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8001772:	61fb      	str	r3, [r7, #28]
        tmp &= ~((uint32_t)iocurrent);
 8001774:	68fb      	ldr	r3, [r7, #12]
 8001776:	43db      	mvns	r3, r3
 8001778:	69fa      	ldr	r2, [r7, #28]
 800177a:	4013      	ands	r3, r2
 800177c:	61fb      	str	r3, [r7, #28]
        if ((pGPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800177e:	683b      	ldr	r3, [r7, #0]
 8001780:	685b      	ldr	r3, [r3, #4]
 8001782:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001786:	2b00      	cmp	r3, #0
 8001788:	d003      	beq.n	8001792 <HAL_GPIO_Init+0x34e>
        {
          tmp |= iocurrent;
 800178a:	69fa      	ldr	r2, [r7, #28]
 800178c:	68fb      	ldr	r3, [r7, #12]
 800178e:	4313      	orrs	r3, r2
 8001790:	61fb      	str	r3, [r7, #28]
        }
        EXTI->EMR1 = tmp;
 8001792:	4a16      	ldr	r2, [pc, #88]	; (80017ec <HAL_GPIO_Init+0x3a8>)
 8001794:	69fb      	ldr	r3, [r7, #28]
 8001796:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84

        tmp = EXTI->IMR1;
 800179a:	4b14      	ldr	r3, [pc, #80]	; (80017ec <HAL_GPIO_Init+0x3a8>)
 800179c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80017a0:	61fb      	str	r3, [r7, #28]
        tmp &= ~((uint32_t)iocurrent);
 80017a2:	68fb      	ldr	r3, [r7, #12]
 80017a4:	43db      	mvns	r3, r3
 80017a6:	69fa      	ldr	r2, [r7, #28]
 80017a8:	4013      	ands	r3, r2
 80017aa:	61fb      	str	r3, [r7, #28]
        if ((pGPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80017ac:	683b      	ldr	r3, [r7, #0]
 80017ae:	685b      	ldr	r3, [r3, #4]
 80017b0:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80017b4:	2b00      	cmp	r3, #0
 80017b6:	d003      	beq.n	80017c0 <HAL_GPIO_Init+0x37c>
        {
          tmp |= iocurrent;
 80017b8:	69fa      	ldr	r2, [r7, #28]
 80017ba:	68fb      	ldr	r3, [r7, #12]
 80017bc:	4313      	orrs	r3, r2
 80017be:	61fb      	str	r3, [r7, #28]
        }
        EXTI->IMR1 = tmp;
 80017c0:	4a0a      	ldr	r2, [pc, #40]	; (80017ec <HAL_GPIO_Init+0x3a8>)
 80017c2:	69fb      	ldr	r3, [r7, #28]
 80017c4:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
      }
    }
    position++;
 80017c8:	697b      	ldr	r3, [r7, #20]
 80017ca:	3301      	adds	r3, #1
 80017cc:	617b      	str	r3, [r7, #20]
  while (((pGPIO_Init->Pin) >> position) != 0U)
 80017ce:	683b      	ldr	r3, [r7, #0]
 80017d0:	681a      	ldr	r2, [r3, #0]
 80017d2:	697b      	ldr	r3, [r7, #20]
 80017d4:	fa22 f303 	lsr.w	r3, r2, r3
 80017d8:	2b00      	cmp	r3, #0
 80017da:	f47f ae3d 	bne.w	8001458 <HAL_GPIO_Init+0x14>
  }
}
 80017de:	bf00      	nop
 80017e0:	bf00      	nop
 80017e2:	3724      	adds	r7, #36	; 0x24
 80017e4:	46bd      	mov	sp, r7
 80017e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017ea:	4770      	bx	lr
 80017ec:	46022000 	.word	0x46022000
 80017f0:	002f7f7f 	.word	0x002f7f7f

080017f4 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 80017f4:	b480      	push	{r7}
 80017f6:	b089      	sub	sp, #36	; 0x24
 80017f8:	af00      	add	r7, sp, #0
 80017fa:	6078      	str	r0, [r7, #4]
 80017fc:	6039      	str	r1, [r7, #0]
  uint32_t tmp;
  uint32_t iocurrent;
  uint32_t pin_position;
  uint32_t position = 0U;
 80017fe:	2300      	movs	r3, #0
 8001800:	61bb      	str	r3, [r7, #24]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Save GPIO port address */
  p_gpio = GPIOx;
 8001802:	687b      	ldr	r3, [r7, #4]
 8001804:	617b      	str	r3, [r7, #20]

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0U)
 8001806:	e0bc      	b.n	8001982 <HAL_GPIO_DeInit+0x18e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1UL << position);
 8001808:	2201      	movs	r2, #1
 800180a:	69bb      	ldr	r3, [r7, #24]
 800180c:	fa02 f303 	lsl.w	r3, r2, r3
 8001810:	683a      	ldr	r2, [r7, #0]
 8001812:	4013      	ands	r3, r2
 8001814:	613b      	str	r3, [r7, #16]

    /*Save Pin Position */
    pin_position = position;
 8001816:	69bb      	ldr	r3, [r7, #24]
 8001818:	61fb      	str	r3, [r7, #28]

    if (iocurrent != 0U)
 800181a:	693b      	ldr	r3, [r7, #16]
 800181c:	2b00      	cmp	r3, #0
 800181e:	f000 80ad 	beq.w	800197c <HAL_GPIO_DeInit+0x188>
    {
      /* In case of LPGPIO port selected */
      if (GPIOx == LPGPIO1)
 8001822:	687b      	ldr	r3, [r7, #4]
 8001824:	4a5e      	ldr	r2, [pc, #376]	; (80019a0 <HAL_GPIO_DeInit+0x1ac>)
 8001826:	4293      	cmp	r3, r2
 8001828:	d115      	bne.n	8001856 <HAL_GPIO_DeInit+0x62>
      {
        /* Configure LP/IO in Input Mode */
        p_gpio  = LPGPIO_Map[pin_position].GPIO_PORT;
 800182a:	4a5e      	ldr	r2, [pc, #376]	; (80019a4 <HAL_GPIO_DeInit+0x1b0>)
 800182c:	69fb      	ldr	r3, [r7, #28]
 800182e:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8001832:	617b      	str	r3, [r7, #20]
        pin_position = LPGPIO_Map[position].Pin_Pos;
 8001834:	4a5b      	ldr	r2, [pc, #364]	; (80019a4 <HAL_GPIO_DeInit+0x1b0>)
 8001836:	69bb      	ldr	r3, [r7, #24]
 8001838:	00db      	lsls	r3, r3, #3
 800183a:	4413      	add	r3, r2
 800183c:	685b      	ldr	r3, [r3, #4]
 800183e:	61fb      	str	r3, [r7, #28]
        LPGPIO1->MODER &= ~(1U << pin_position);
 8001840:	4b57      	ldr	r3, [pc, #348]	; (80019a0 <HAL_GPIO_DeInit+0x1ac>)
 8001842:	681a      	ldr	r2, [r3, #0]
 8001844:	2101      	movs	r1, #1
 8001846:	69fb      	ldr	r3, [r7, #28]
 8001848:	fa01 f303 	lsl.w	r3, r1, r3
 800184c:	43db      	mvns	r3, r3
 800184e:	4954      	ldr	r1, [pc, #336]	; (80019a0 <HAL_GPIO_DeInit+0x1ac>)
 8001850:	4013      	ands	r3, r2
 8001852:	600b      	str	r3, [r1, #0]
 8001854:	e053      	b.n	80018fe <HAL_GPIO_DeInit+0x10a>
        /* Check the parameters */
        assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));

        /*------------------------- EXTI Mode Configuration --------------------*/
        /* Clear the External Interrupt or Event for the current IO */
        tmp = EXTI->EXTICR[position >> 2U];
 8001856:	4a54      	ldr	r2, [pc, #336]	; (80019a8 <HAL_GPIO_DeInit+0x1b4>)
 8001858:	69bb      	ldr	r3, [r7, #24]
 800185a:	089b      	lsrs	r3, r3, #2
 800185c:	3318      	adds	r3, #24
 800185e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001862:	60fb      	str	r3, [r7, #12]
        tmp &= ((0x0FUL) << (8U * (position & 0x03U)));
 8001864:	69bb      	ldr	r3, [r7, #24]
 8001866:	f003 0303 	and.w	r3, r3, #3
 800186a:	00db      	lsls	r3, r3, #3
 800186c:	220f      	movs	r2, #15
 800186e:	fa02 f303 	lsl.w	r3, r2, r3
 8001872:	68fa      	ldr	r2, [r7, #12]
 8001874:	4013      	ands	r3, r2
 8001876:	60fb      	str	r3, [r7, #12]
        if (tmp == (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U))))
 8001878:	687b      	ldr	r3, [r7, #4]
 800187a:	0a9a      	lsrs	r2, r3, #10
 800187c:	4b4b      	ldr	r3, [pc, #300]	; (80019ac <HAL_GPIO_DeInit+0x1b8>)
 800187e:	4013      	ands	r3, r2
 8001880:	69ba      	ldr	r2, [r7, #24]
 8001882:	f002 0203 	and.w	r2, r2, #3
 8001886:	00d2      	lsls	r2, r2, #3
 8001888:	4093      	lsls	r3, r2
 800188a:	68fa      	ldr	r2, [r7, #12]
 800188c:	429a      	cmp	r2, r3
 800188e:	d136      	bne.n	80018fe <HAL_GPIO_DeInit+0x10a>
        {
          /* Clear EXTI line configuration */
          EXTI->IMR1 &= ~(iocurrent);
 8001890:	4b45      	ldr	r3, [pc, #276]	; (80019a8 <HAL_GPIO_DeInit+0x1b4>)
 8001892:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8001896:	693b      	ldr	r3, [r7, #16]
 8001898:	43db      	mvns	r3, r3
 800189a:	4943      	ldr	r1, [pc, #268]	; (80019a8 <HAL_GPIO_DeInit+0x1b4>)
 800189c:	4013      	ands	r3, r2
 800189e:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
          EXTI->EMR1 &= ~(iocurrent);
 80018a2:	4b41      	ldr	r3, [pc, #260]	; (80019a8 <HAL_GPIO_DeInit+0x1b4>)
 80018a4:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 80018a8:	693b      	ldr	r3, [r7, #16]
 80018aa:	43db      	mvns	r3, r3
 80018ac:	493e      	ldr	r1, [pc, #248]	; (80019a8 <HAL_GPIO_DeInit+0x1b4>)
 80018ae:	4013      	ands	r3, r2
 80018b0:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84

          /* Clear Rising Falling edge configuration */
          EXTI->RTSR1 &= ~(iocurrent);
 80018b4:	4b3c      	ldr	r3, [pc, #240]	; (80019a8 <HAL_GPIO_DeInit+0x1b4>)
 80018b6:	681a      	ldr	r2, [r3, #0]
 80018b8:	693b      	ldr	r3, [r7, #16]
 80018ba:	43db      	mvns	r3, r3
 80018bc:	493a      	ldr	r1, [pc, #232]	; (80019a8 <HAL_GPIO_DeInit+0x1b4>)
 80018be:	4013      	ands	r3, r2
 80018c0:	600b      	str	r3, [r1, #0]
          EXTI->FTSR1 &= ~(iocurrent);
 80018c2:	4b39      	ldr	r3, [pc, #228]	; (80019a8 <HAL_GPIO_DeInit+0x1b4>)
 80018c4:	685a      	ldr	r2, [r3, #4]
 80018c6:	693b      	ldr	r3, [r7, #16]
 80018c8:	43db      	mvns	r3, r3
 80018ca:	4937      	ldr	r1, [pc, #220]	; (80019a8 <HAL_GPIO_DeInit+0x1b4>)
 80018cc:	4013      	ands	r3, r2
 80018ce:	604b      	str	r3, [r1, #4]

          tmp = (0x0FUL) << (8U * (position & 0x03U));
 80018d0:	69bb      	ldr	r3, [r7, #24]
 80018d2:	f003 0303 	and.w	r3, r3, #3
 80018d6:	00db      	lsls	r3, r3, #3
 80018d8:	220f      	movs	r2, #15
 80018da:	fa02 f303 	lsl.w	r3, r2, r3
 80018de:	60fb      	str	r3, [r7, #12]
          EXTI->EXTICR[position >> 2U] &= ~tmp;
 80018e0:	4a31      	ldr	r2, [pc, #196]	; (80019a8 <HAL_GPIO_DeInit+0x1b4>)
 80018e2:	69bb      	ldr	r3, [r7, #24]
 80018e4:	089b      	lsrs	r3, r3, #2
 80018e6:	3318      	adds	r3, #24
 80018e8:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 80018ec:	68fb      	ldr	r3, [r7, #12]
 80018ee:	43da      	mvns	r2, r3
 80018f0:	482d      	ldr	r0, [pc, #180]	; (80019a8 <HAL_GPIO_DeInit+0x1b4>)
 80018f2:	69bb      	ldr	r3, [r7, #24]
 80018f4:	089b      	lsrs	r3, r3, #2
 80018f6:	400a      	ands	r2, r1
 80018f8:	3318      	adds	r3, #24
 80018fa:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
        }
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      p_gpio->MODER |= (GPIO_MODER_MODE0 << (pin_position * 2U));
 80018fe:	697b      	ldr	r3, [r7, #20]
 8001900:	681a      	ldr	r2, [r3, #0]
 8001902:	69fb      	ldr	r3, [r7, #28]
 8001904:	005b      	lsls	r3, r3, #1
 8001906:	2103      	movs	r1, #3
 8001908:	fa01 f303 	lsl.w	r3, r1, r3
 800190c:	431a      	orrs	r2, r3
 800190e:	697b      	ldr	r3, [r7, #20]
 8001910:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      p_gpio->AFR[pin_position >> 3U] &= ~(0x0FUL << ((pin_position & 0x07U) * 4U));
 8001912:	69fb      	ldr	r3, [r7, #28]
 8001914:	08da      	lsrs	r2, r3, #3
 8001916:	697b      	ldr	r3, [r7, #20]
 8001918:	3208      	adds	r2, #8
 800191a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800191e:	69fb      	ldr	r3, [r7, #28]
 8001920:	f003 0307 	and.w	r3, r3, #7
 8001924:	009b      	lsls	r3, r3, #2
 8001926:	220f      	movs	r2, #15
 8001928:	fa02 f303 	lsl.w	r3, r2, r3
 800192c:	43db      	mvns	r3, r3
 800192e:	69fa      	ldr	r2, [r7, #28]
 8001930:	08d2      	lsrs	r2, r2, #3
 8001932:	4019      	ands	r1, r3
 8001934:	697b      	ldr	r3, [r7, #20]
 8001936:	3208      	adds	r2, #8
 8001938:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Configure the default value for IO Speed */
      p_gpio->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (pin_position * 2U));
 800193c:	697b      	ldr	r3, [r7, #20]
 800193e:	689a      	ldr	r2, [r3, #8]
 8001940:	69fb      	ldr	r3, [r7, #28]
 8001942:	005b      	lsls	r3, r3, #1
 8001944:	2103      	movs	r1, #3
 8001946:	fa01 f303 	lsl.w	r3, r1, r3
 800194a:	43db      	mvns	r3, r3
 800194c:	401a      	ands	r2, r3
 800194e:	697b      	ldr	r3, [r7, #20]
 8001950:	609a      	str	r2, [r3, #8]

      /* Configure the default value IO Output Type */
      p_gpio->OTYPER  &= ~(GPIO_OTYPER_OT0 << pin_position);
 8001952:	697b      	ldr	r3, [r7, #20]
 8001954:	685a      	ldr	r2, [r3, #4]
 8001956:	2101      	movs	r1, #1
 8001958:	69fb      	ldr	r3, [r7, #28]
 800195a:	fa01 f303 	lsl.w	r3, r1, r3
 800195e:	43db      	mvns	r3, r3
 8001960:	401a      	ands	r2, r3
 8001962:	697b      	ldr	r3, [r7, #20]
 8001964:	605a      	str	r2, [r3, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      p_gpio->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (pin_position * 2U));
 8001966:	697b      	ldr	r3, [r7, #20]
 8001968:	68da      	ldr	r2, [r3, #12]
 800196a:	69fb      	ldr	r3, [r7, #28]
 800196c:	005b      	lsls	r3, r3, #1
 800196e:	2103      	movs	r1, #3
 8001970:	fa01 f303 	lsl.w	r3, r1, r3
 8001974:	43db      	mvns	r3, r3
 8001976:	401a      	ands	r2, r3
 8001978:	697b      	ldr	r3, [r7, #20]
 800197a:	60da      	str	r2, [r3, #12]
    }

    position++;
 800197c:	69bb      	ldr	r3, [r7, #24]
 800197e:	3301      	adds	r3, #1
 8001980:	61bb      	str	r3, [r7, #24]
  while ((GPIO_Pin >> position) != 0U)
 8001982:	683a      	ldr	r2, [r7, #0]
 8001984:	69bb      	ldr	r3, [r7, #24]
 8001986:	fa22 f303 	lsr.w	r3, r2, r3
 800198a:	2b00      	cmp	r3, #0
 800198c:	f47f af3c 	bne.w	8001808 <HAL_GPIO_DeInit+0x14>
  }
}
 8001990:	bf00      	nop
 8001992:	bf00      	nop
 8001994:	3724      	adds	r7, #36	; 0x24
 8001996:	46bd      	mov	sp, r7
 8001998:	f85d 7b04 	ldr.w	r7, [sp], #4
 800199c:	4770      	bx	lr
 800199e:	bf00      	nop
 80019a0:	46020000 	.word	0x46020000
 80019a4:	08006e6c 	.word	0x08006e6c
 80019a8:	46022000 	.word	0x46022000
 80019ac:	002f7f7f 	.word	0x002f7f7f

080019b0 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 80019b0:	b480      	push	{r7}
 80019b2:	b083      	sub	sp, #12
 80019b4:	af00      	add	r7, sp, #0
 80019b6:	6078      	str	r0, [r7, #4]
 80019b8:	460b      	mov	r3, r1
 80019ba:	807b      	strh	r3, [r7, #2]
 80019bc:	4613      	mov	r3, r2
 80019be:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 80019c0:	787b      	ldrb	r3, [r7, #1]
 80019c2:	2b00      	cmp	r3, #0
 80019c4:	d003      	beq.n	80019ce <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 80019c6:	887a      	ldrh	r2, [r7, #2]
 80019c8:	687b      	ldr	r3, [r7, #4]
 80019ca:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR  = (uint32_t)GPIO_Pin;
  }
}
 80019cc:	e002      	b.n	80019d4 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR  = (uint32_t)GPIO_Pin;
 80019ce:	887a      	ldrh	r2, [r7, #2]
 80019d0:	687b      	ldr	r3, [r7, #4]
 80019d2:	629a      	str	r2, [r3, #40]	; 0x28
}
 80019d4:	bf00      	nop
 80019d6:	370c      	adds	r7, #12
 80019d8:	46bd      	mov	sp, r7
 80019da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80019de:	4770      	bx	lr

080019e0 <HAL_GPIO_TogglePin>:
  * @param  GPIO_Pin specifies the pin to be toggled.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 80019e0:	b480      	push	{r7}
 80019e2:	b085      	sub	sp, #20
 80019e4:	af00      	add	r7, sp, #0
 80019e6:	6078      	str	r0, [r7, #4]
 80019e8:	460b      	mov	r3, r1
 80019ea:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 80019ec:	687b      	ldr	r3, [r7, #4]
 80019ee:	695b      	ldr	r3, [r3, #20]
 80019f0:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 80019f2:	887a      	ldrh	r2, [r7, #2]
 80019f4:	68fb      	ldr	r3, [r7, #12]
 80019f6:	4013      	ands	r3, r2
 80019f8:	041a      	lsls	r2, r3, #16
 80019fa:	68fb      	ldr	r3, [r7, #12]
 80019fc:	43d9      	mvns	r1, r3
 80019fe:	887b      	ldrh	r3, [r7, #2]
 8001a00:	400b      	ands	r3, r1
 8001a02:	431a      	orrs	r2, r3
 8001a04:	687b      	ldr	r3, [r7, #4]
 8001a06:	619a      	str	r2, [r3, #24]
}
 8001a08:	bf00      	nop
 8001a0a:	3714      	adds	r7, #20
 8001a0c:	46bd      	mov	sp, r7
 8001a0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a12:	4770      	bx	lr

08001a14 <HAL_ICACHE_ConfigAssociativityMode>:
  *            @arg ICACHE_1WAY   1-way cache (direct mapped cache)
  *            @arg ICACHE_2WAYS  2-ways set associative cache (default)
  * @retval HAL status (HAL_OK/HAL_ERROR)
  */
HAL_StatusTypeDef HAL_ICACHE_ConfigAssociativityMode(uint32_t AssociativityMode)
{
 8001a14:	b480      	push	{r7}
 8001a16:	b085      	sub	sp, #20
 8001a18:	af00      	add	r7, sp, #0
 8001a1a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8001a1c:	2300      	movs	r3, #0
 8001a1e:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_ICACHE_ASSOCIATIVITY_MODE(AssociativityMode));

  /* Check cache is not enabled */
  if (READ_BIT(ICACHE->CR, ICACHE_CR_EN) != 0U)
 8001a20:	4b0b      	ldr	r3, [pc, #44]	; (8001a50 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 8001a22:	681b      	ldr	r3, [r3, #0]
 8001a24:	f003 0301 	and.w	r3, r3, #1
 8001a28:	2b00      	cmp	r3, #0
 8001a2a:	d002      	beq.n	8001a32 <HAL_ICACHE_ConfigAssociativityMode+0x1e>
  {
    status = HAL_ERROR;
 8001a2c:	2301      	movs	r3, #1
 8001a2e:	73fb      	strb	r3, [r7, #15]
 8001a30:	e007      	b.n	8001a42 <HAL_ICACHE_ConfigAssociativityMode+0x2e>
  }
  else
  {
    MODIFY_REG(ICACHE->CR, ICACHE_CR_WAYSEL, AssociativityMode);
 8001a32:	4b07      	ldr	r3, [pc, #28]	; (8001a50 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 8001a34:	681b      	ldr	r3, [r3, #0]
 8001a36:	f023 0204 	bic.w	r2, r3, #4
 8001a3a:	4905      	ldr	r1, [pc, #20]	; (8001a50 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 8001a3c:	687b      	ldr	r3, [r7, #4]
 8001a3e:	4313      	orrs	r3, r2
 8001a40:	600b      	str	r3, [r1, #0]
  }

  return status;
 8001a42:	7bfb      	ldrb	r3, [r7, #15]
}
 8001a44:	4618      	mov	r0, r3
 8001a46:	3714      	adds	r7, #20
 8001a48:	46bd      	mov	sp, r7
 8001a4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a4e:	4770      	bx	lr
 8001a50:	40030400 	.word	0x40030400

08001a54 <HAL_ICACHE_Enable>:
  *         cache operation. The Instruction Cache is bypassed until the
  *         cache operation completes.
  * @retval HAL status (HAL_OK)
  */
HAL_StatusTypeDef HAL_ICACHE_Enable(void)
{
 8001a54:	b480      	push	{r7}
 8001a56:	af00      	add	r7, sp, #0
  SET_BIT(ICACHE->CR, ICACHE_CR_EN);
 8001a58:	4b05      	ldr	r3, [pc, #20]	; (8001a70 <HAL_ICACHE_Enable+0x1c>)
 8001a5a:	681b      	ldr	r3, [r3, #0]
 8001a5c:	4a04      	ldr	r2, [pc, #16]	; (8001a70 <HAL_ICACHE_Enable+0x1c>)
 8001a5e:	f043 0301 	orr.w	r3, r3, #1
 8001a62:	6013      	str	r3, [r2, #0]

  return HAL_OK;
 8001a64:	2300      	movs	r3, #0
}
 8001a66:	4618      	mov	r0, r3
 8001a68:	46bd      	mov	sp, r7
 8001a6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a6e:	4770      	bx	lr
 8001a70:	40030400 	.word	0x40030400

08001a74 <LL_DLYB_Enable>:
  * @param  DLYBx DLYB Instance
  * @retval None
  */

__STATIC_INLINE void LL_DLYB_Enable(DLYB_TypeDef *DLYBx)
{
 8001a74:	b480      	push	{r7}
 8001a76:	b083      	sub	sp, #12
 8001a78:	af00      	add	r7, sp, #0
 8001a7a:	6078      	str	r0, [r7, #4]
  SET_BIT(DLYBx->CR, DLYB_CR_DEN);
 8001a7c:	687b      	ldr	r3, [r7, #4]
 8001a7e:	681b      	ldr	r3, [r3, #0]
 8001a80:	f043 0201 	orr.w	r2, r3, #1
 8001a84:	687b      	ldr	r3, [r7, #4]
 8001a86:	601a      	str	r2, [r3, #0]
}
 8001a88:	bf00      	nop
 8001a8a:	370c      	adds	r7, #12
 8001a8c:	46bd      	mov	sp, r7
 8001a8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a92:	4770      	bx	lr

08001a94 <HAL_OSPI_Init>:
  *         in the OSPI_InitTypeDef and initialize the associated handle.
  * @param  hospi : OSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_Init(OSPI_HandleTypeDef *hospi)
{
 8001a94:	b580      	push	{r7, lr}
 8001a96:	b086      	sub	sp, #24
 8001a98:	af02      	add	r7, sp, #8
 8001a9a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8001a9c:	2300      	movs	r3, #0
 8001a9e:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
 8001aa0:	f7ff faba 	bl	8001018 <HAL_GetTick>
 8001aa4:	60b8      	str	r0, [r7, #8]

  /* Check the OSPI handle allocation */
  if (hospi == NULL)
 8001aa6:	687b      	ldr	r3, [r7, #4]
 8001aa8:	2b00      	cmp	r3, #0
 8001aaa:	d102      	bne.n	8001ab2 <HAL_OSPI_Init+0x1e>
  {
    status = HAL_ERROR;
 8001aac:	2301      	movs	r3, #1
 8001aae:	73fb      	strb	r3, [r7, #15]
 8001ab0:	e0a5      	b.n	8001bfe <HAL_OSPI_Init+0x16a>
    assert_param(IS_OSPI_CS_BOUNDARY(hospi->Init.ChipSelectBoundary));
    assert_param(IS_OSPI_DLYBYP(hospi->Init.DelayBlockBypass));
    assert_param(IS_OSPI_MAXTRAN(hospi->Init.MaxTran));

    /* Initialize error code */
    hospi->ErrorCode = HAL_OSPI_ERROR_NONE;
 8001ab2:	687b      	ldr	r3, [r7, #4]
 8001ab4:	2200      	movs	r2, #0
 8001ab6:	655a      	str	r2, [r3, #84]	; 0x54

    /* Check if the state is the reset state */
    if (hospi->State == HAL_OSPI_STATE_RESET)
 8001ab8:	687b      	ldr	r3, [r7, #4]
 8001aba:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001abc:	2b00      	cmp	r3, #0
 8001abe:	f040 809e 	bne.w	8001bfe <HAL_OSPI_Init+0x16a>

      /* Init the low level hardware */
      hospi->MspInitCallback(hospi);
#else
      /* Initialization of the low level hardware */
      HAL_OSPI_MspInit(hospi);
 8001ac2:	6878      	ldr	r0, [r7, #4]
 8001ac4:	f7fe ff12 	bl	80008ec <HAL_OSPI_MspInit>
#endif /* defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */

      /* Configure the default timeout for the OSPI memory access */
      (void)HAL_OSPI_SetTimeout(hospi, HAL_OSPI_TIMEOUT_DEFAULT_VALUE);
 8001ac8:	f241 3188 	movw	r1, #5000	; 0x1388
 8001acc:	6878      	ldr	r0, [r7, #4]
 8001ace:	f000 fc6f 	bl	80023b0 <HAL_OSPI_SetTimeout>

      /* Configure memory type, device size, chip select high time, delay block bypass,
         free running clock, clock mode */
      MODIFY_REG(hospi->Instance->DCR1,
 8001ad2:	687b      	ldr	r3, [r7, #4]
 8001ad4:	681b      	ldr	r3, [r3, #0]
 8001ad6:	689a      	ldr	r2, [r3, #8]
 8001ad8:	4b4b      	ldr	r3, [pc, #300]	; (8001c08 <HAL_OSPI_Init+0x174>)
 8001ada:	4013      	ands	r3, r2
 8001adc:	687a      	ldr	r2, [r7, #4]
 8001ade:	68d1      	ldr	r1, [r2, #12]
 8001ae0:	687a      	ldr	r2, [r7, #4]
 8001ae2:	6912      	ldr	r2, [r2, #16]
 8001ae4:	3a01      	subs	r2, #1
 8001ae6:	0412      	lsls	r2, r2, #16
 8001ae8:	4311      	orrs	r1, r2
 8001aea:	687a      	ldr	r2, [r7, #4]
 8001aec:	6952      	ldr	r2, [r2, #20]
 8001aee:	3a01      	subs	r2, #1
 8001af0:	0212      	lsls	r2, r2, #8
 8001af2:	4311      	orrs	r1, r2
 8001af4:	687a      	ldr	r2, [r7, #4]
 8001af6:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8001af8:	4311      	orrs	r1, r2
 8001afa:	687a      	ldr	r2, [r7, #4]
 8001afc:	69d2      	ldr	r2, [r2, #28]
 8001afe:	4311      	orrs	r1, r2
 8001b00:	687a      	ldr	r2, [r7, #4]
 8001b02:	6812      	ldr	r2, [r2, #0]
 8001b04:	430b      	orrs	r3, r1
 8001b06:	6093      	str	r3, [r2, #8]
                 (hospi->Init.MemoryType | ((hospi->Init.DeviceSize - 1U) << OCTOSPI_DCR1_DEVSIZE_Pos) |
                  ((hospi->Init.ChipSelectHighTime - 1U) << OCTOSPI_DCR1_CSHT_Pos) |
                  hospi->Init.DelayBlockBypass | hospi->Init.ClockMode));

      /* Configure wrap size */
      MODIFY_REG(hospi->Instance->DCR2, OCTOSPI_DCR2_WRAPSIZE, hospi->Init.WrapSize);
 8001b08:	687b      	ldr	r3, [r7, #4]
 8001b0a:	681b      	ldr	r3, [r3, #0]
 8001b0c:	68db      	ldr	r3, [r3, #12]
 8001b0e:	f423 21e0 	bic.w	r1, r3, #458752	; 0x70000
 8001b12:	687b      	ldr	r3, [r7, #4]
 8001b14:	6a1a      	ldr	r2, [r3, #32]
 8001b16:	687b      	ldr	r3, [r7, #4]
 8001b18:	681b      	ldr	r3, [r3, #0]
 8001b1a:	430a      	orrs	r2, r1
 8001b1c:	60da      	str	r2, [r3, #12]

      /* Configure chip select boundary and maximum transfer */
      hospi->Instance->DCR3 = ((hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos) |
 8001b1e:	687b      	ldr	r3, [r7, #4]
 8001b20:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001b22:	0419      	lsls	r1, r3, #16
                               (hospi->Init.MaxTran << OCTOSPI_DCR3_MAXTRAN_Pos));
 8001b24:	687b      	ldr	r3, [r7, #4]
 8001b26:	6b9a      	ldr	r2, [r3, #56]	; 0x38
      hospi->Instance->DCR3 = ((hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos) |
 8001b28:	687b      	ldr	r3, [r7, #4]
 8001b2a:	681b      	ldr	r3, [r3, #0]
 8001b2c:	430a      	orrs	r2, r1
 8001b2e:	611a      	str	r2, [r3, #16]

      /* Configure refresh */
      hospi->Instance->DCR4 = hospi->Init.Refresh;
 8001b30:	687b      	ldr	r3, [r7, #4]
 8001b32:	681b      	ldr	r3, [r3, #0]
 8001b34:	687a      	ldr	r2, [r7, #4]
 8001b36:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8001b38:	615a      	str	r2, [r3, #20]

      /* Configure FIFO threshold */
      MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FTHRES, ((hospi->Init.FifoThreshold - 1U) << OCTOSPI_CR_FTHRES_Pos));
 8001b3a:	687b      	ldr	r3, [r7, #4]
 8001b3c:	681b      	ldr	r3, [r3, #0]
 8001b3e:	681b      	ldr	r3, [r3, #0]
 8001b40:	f423 517c 	bic.w	r1, r3, #16128	; 0x3f00
 8001b44:	687b      	ldr	r3, [r7, #4]
 8001b46:	685b      	ldr	r3, [r3, #4]
 8001b48:	3b01      	subs	r3, #1
 8001b4a:	021a      	lsls	r2, r3, #8
 8001b4c:	687b      	ldr	r3, [r7, #4]
 8001b4e:	681b      	ldr	r3, [r3, #0]
 8001b50:	430a      	orrs	r2, r1
 8001b52:	601a      	str	r2, [r3, #0]

      /* Wait till busy flag is reset */
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 8001b54:	687b      	ldr	r3, [r7, #4]
 8001b56:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001b58:	9300      	str	r3, [sp, #0]
 8001b5a:	68bb      	ldr	r3, [r7, #8]
 8001b5c:	2200      	movs	r2, #0
 8001b5e:	2120      	movs	r1, #32
 8001b60:	6878      	ldr	r0, [r7, #4]
 8001b62:	f001 f963 	bl	8002e2c <OSPI_WaitFlagStateUntilTimeout>
 8001b66:	4603      	mov	r3, r0
 8001b68:	73fb      	strb	r3, [r7, #15]

      if (status == HAL_OK)
 8001b6a:	7bfb      	ldrb	r3, [r7, #15]
 8001b6c:	2b00      	cmp	r3, #0
 8001b6e:	d146      	bne.n	8001bfe <HAL_OSPI_Init+0x16a>
      {
        /* Configure clock prescaler */
        MODIFY_REG(hospi->Instance->DCR2, OCTOSPI_DCR2_PRESCALER,
 8001b70:	687b      	ldr	r3, [r7, #4]
 8001b72:	681b      	ldr	r3, [r3, #0]
 8001b74:	68db      	ldr	r3, [r3, #12]
 8001b76:	f023 01ff 	bic.w	r1, r3, #255	; 0xff
 8001b7a:	687b      	ldr	r3, [r7, #4]
 8001b7c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001b7e:	1e5a      	subs	r2, r3, #1
 8001b80:	687b      	ldr	r3, [r7, #4]
 8001b82:	681b      	ldr	r3, [r3, #0]
 8001b84:	430a      	orrs	r2, r1
 8001b86:	60da      	str	r2, [r3, #12]
                   ((hospi->Init.ClockPrescaler - 1U) << OCTOSPI_DCR2_PRESCALER_Pos));

        /* Configure Dual Quad mode */
        MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_DMM, hospi->Init.DualQuad);
 8001b88:	687b      	ldr	r3, [r7, #4]
 8001b8a:	681b      	ldr	r3, [r3, #0]
 8001b8c:	681b      	ldr	r3, [r3, #0]
 8001b8e:	f023 0140 	bic.w	r1, r3, #64	; 0x40
 8001b92:	687b      	ldr	r3, [r7, #4]
 8001b94:	689a      	ldr	r2, [r3, #8]
 8001b96:	687b      	ldr	r3, [r7, #4]
 8001b98:	681b      	ldr	r3, [r3, #0]
 8001b9a:	430a      	orrs	r2, r1
 8001b9c:	601a      	str	r2, [r3, #0]

        /* Configure sample shifting and delay hold quarter cycle */
        MODIFY_REG(hospi->Instance->TCR, (OCTOSPI_TCR_SSHIFT | OCTOSPI_TCR_DHQC),
 8001b9e:	687b      	ldr	r3, [r7, #4]
 8001ba0:	681b      	ldr	r3, [r3, #0]
 8001ba2:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8001ba6:	f023 41a0 	bic.w	r1, r3, #1342177280	; 0x50000000
 8001baa:	687b      	ldr	r3, [r7, #4]
 8001bac:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001bae:	687b      	ldr	r3, [r7, #4]
 8001bb0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001bb2:	431a      	orrs	r2, r3
 8001bb4:	687b      	ldr	r3, [r7, #4]
 8001bb6:	681b      	ldr	r3, [r3, #0]
 8001bb8:	430a      	orrs	r2, r1
 8001bba:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
                   (hospi->Init.SampleShifting | hospi->Init.DelayHoldQuarterCycle));

        /* Enable OctoSPI */
        __HAL_OSPI_ENABLE(hospi);
 8001bbe:	687b      	ldr	r3, [r7, #4]
 8001bc0:	681b      	ldr	r3, [r3, #0]
 8001bc2:	681a      	ldr	r2, [r3, #0]
 8001bc4:	687b      	ldr	r3, [r7, #4]
 8001bc6:	681b      	ldr	r3, [r3, #0]
 8001bc8:	f042 0201 	orr.w	r2, r2, #1
 8001bcc:	601a      	str	r2, [r3, #0]

        /* Enable free running clock if needed : must be done after OSPI enable */
        if (hospi->Init.FreeRunningClock == HAL_OSPI_FREERUNCLK_ENABLE)
 8001bce:	687b      	ldr	r3, [r7, #4]
 8001bd0:	699b      	ldr	r3, [r3, #24]
 8001bd2:	2b02      	cmp	r3, #2
 8001bd4:	d107      	bne.n	8001be6 <HAL_OSPI_Init+0x152>
        {
          SET_BIT(hospi->Instance->DCR1, OCTOSPI_DCR1_FRCK);
 8001bd6:	687b      	ldr	r3, [r7, #4]
 8001bd8:	681b      	ldr	r3, [r3, #0]
 8001bda:	689a      	ldr	r2, [r3, #8]
 8001bdc:	687b      	ldr	r3, [r7, #4]
 8001bde:	681b      	ldr	r3, [r3, #0]
 8001be0:	f042 0202 	orr.w	r2, r2, #2
 8001be4:	609a      	str	r2, [r3, #8]
        }

        /* Initialize the OSPI state */
        if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 8001be6:	687b      	ldr	r3, [r7, #4]
 8001be8:	68db      	ldr	r3, [r3, #12]
 8001bea:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8001bee:	d103      	bne.n	8001bf8 <HAL_OSPI_Init+0x164>
        {
          hospi->State = HAL_OSPI_STATE_HYPERBUS_INIT;
 8001bf0:	687b      	ldr	r3, [r7, #4]
 8001bf2:	2201      	movs	r2, #1
 8001bf4:	651a      	str	r2, [r3, #80]	; 0x50
 8001bf6:	e002      	b.n	8001bfe <HAL_OSPI_Init+0x16a>
        }
        else
        {
          hospi->State = HAL_OSPI_STATE_READY;
 8001bf8:	687b      	ldr	r3, [r7, #4]
 8001bfa:	2202      	movs	r2, #2
 8001bfc:	651a      	str	r2, [r3, #80]	; 0x50
      }
    }
  }

  /* Return function status */
  return status;
 8001bfe:	7bfb      	ldrb	r3, [r7, #15]
}
 8001c00:	4618      	mov	r0, r3
 8001c02:	3710      	adds	r7, #16
 8001c04:	46bd      	mov	sp, r7
 8001c06:	bd80      	pop	{r7, pc}
 8001c08:	f8e0c0f4 	.word	0xf8e0c0f4

08001c0c <HAL_OSPI_DeInit>:
  * @brief  De-Initialize the OSPI peripheral.
  * @param  hospi : OSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_DeInit(OSPI_HandleTypeDef *hospi)
{
 8001c0c:	b580      	push	{r7, lr}
 8001c0e:	b084      	sub	sp, #16
 8001c10:	af00      	add	r7, sp, #0
 8001c12:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8001c14:	2300      	movs	r3, #0
 8001c16:	73fb      	strb	r3, [r7, #15]

  /* Check the OSPI handle allocation */
  if (hospi == NULL)
 8001c18:	687b      	ldr	r3, [r7, #4]
 8001c1a:	2b00      	cmp	r3, #0
 8001c1c:	d102      	bne.n	8001c24 <HAL_OSPI_DeInit+0x18>
  {
    status = HAL_ERROR;
 8001c1e:	2301      	movs	r3, #1
 8001c20:	73fb      	strb	r3, [r7, #15]
 8001c22:	e015      	b.n	8001c50 <HAL_OSPI_DeInit+0x44>
    /* No error code can be set set as the handler is null */
  }
  else
  {
    /* Disable OctoSPI */
    __HAL_OSPI_DISABLE(hospi);
 8001c24:	687b      	ldr	r3, [r7, #4]
 8001c26:	681b      	ldr	r3, [r3, #0]
 8001c28:	681a      	ldr	r2, [r3, #0]
 8001c2a:	687b      	ldr	r3, [r7, #4]
 8001c2c:	681b      	ldr	r3, [r3, #0]
 8001c2e:	f022 0201 	bic.w	r2, r2, #1
 8001c32:	601a      	str	r2, [r3, #0]

    /* Disable free running clock if needed : must be done after OSPI disable */
    CLEAR_BIT(hospi->Instance->DCR1, OCTOSPI_DCR1_FRCK);
 8001c34:	687b      	ldr	r3, [r7, #4]
 8001c36:	681b      	ldr	r3, [r3, #0]
 8001c38:	689a      	ldr	r2, [r3, #8]
 8001c3a:	687b      	ldr	r3, [r7, #4]
 8001c3c:	681b      	ldr	r3, [r3, #0]
 8001c3e:	f022 0202 	bic.w	r2, r2, #2
 8001c42:	609a      	str	r2, [r3, #8]

    /* DeInit the low level hardware */
    hospi->MspDeInitCallback(hospi);
#else
    /* De-initialize the low-level hardware */
    HAL_OSPI_MspDeInit(hospi);
 8001c44:	6878      	ldr	r0, [r7, #4]
 8001c46:	f7fe ffd1 	bl	8000bec <HAL_OSPI_MspDeInit>
#endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */

    /* Reset the driver state */
    hospi->State = HAL_OSPI_STATE_RESET;
 8001c4a:	687b      	ldr	r3, [r7, #4]
 8001c4c:	2200      	movs	r2, #0
 8001c4e:	651a      	str	r2, [r3, #80]	; 0x50
  }

  return status;
 8001c50:	7bfb      	ldrb	r3, [r7, #15]
}
 8001c52:	4618      	mov	r0, r3
 8001c54:	3710      	adds	r7, #16
 8001c56:	46bd      	mov	sp, r7
 8001c58:	bd80      	pop	{r7, pc}
	...

08001c5c <HAL_OSPI_IRQHandler>:
  * @brief  Handle OSPI interrupt request.
  * @param  hospi : OSPI handle
  * @retval None
  */
void HAL_OSPI_IRQHandler(OSPI_HandleTypeDef *hospi)
{
 8001c5c:	b580      	push	{r7, lr}
 8001c5e:	b086      	sub	sp, #24
 8001c60:	af00      	add	r7, sp, #0
 8001c62:	6078      	str	r0, [r7, #4]
  __IO uint32_t *data_reg = &hospi->Instance->DR;
 8001c64:	687b      	ldr	r3, [r7, #4]
 8001c66:	681b      	ldr	r3, [r3, #0]
 8001c68:	3350      	adds	r3, #80	; 0x50
 8001c6a:	617b      	str	r3, [r7, #20]
  uint32_t flag           = hospi->Instance->SR;
 8001c6c:	687b      	ldr	r3, [r7, #4]
 8001c6e:	681b      	ldr	r3, [r3, #0]
 8001c70:	6a1b      	ldr	r3, [r3, #32]
 8001c72:	613b      	str	r3, [r7, #16]
  uint32_t itsource       = hospi->Instance->CR;
 8001c74:	687b      	ldr	r3, [r7, #4]
 8001c76:	681b      	ldr	r3, [r3, #0]
 8001c78:	681b      	ldr	r3, [r3, #0]
 8001c7a:	60fb      	str	r3, [r7, #12]
  uint32_t currentstate   = hospi->State;
 8001c7c:	687b      	ldr	r3, [r7, #4]
 8001c7e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001c80:	60bb      	str	r3, [r7, #8]

  /* OctoSPI fifo threshold interrupt occurred -------------------------------*/
  if (((flag & HAL_OSPI_FLAG_FT) != 0U) && ((itsource & HAL_OSPI_IT_FT) != 0U))
 8001c82:	693b      	ldr	r3, [r7, #16]
 8001c84:	f003 0304 	and.w	r3, r3, #4
 8001c88:	2b00      	cmp	r3, #0
 8001c8a:	d03a      	beq.n	8001d02 <HAL_OSPI_IRQHandler+0xa6>
 8001c8c:	68fb      	ldr	r3, [r7, #12]
 8001c8e:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8001c92:	2b00      	cmp	r3, #0
 8001c94:	d035      	beq.n	8001d02 <HAL_OSPI_IRQHandler+0xa6>
  {
    if (currentstate == HAL_OSPI_STATE_BUSY_TX)
 8001c96:	68bb      	ldr	r3, [r7, #8]
 8001c98:	2b18      	cmp	r3, #24
 8001c9a:	d10f      	bne.n	8001cbc <HAL_OSPI_IRQHandler+0x60>
    {
      /* Write a data in the fifo */
      *((__IO uint8_t *)data_reg) = *hospi->pBuffPtr;
 8001c9c:	687b      	ldr	r3, [r7, #4]
 8001c9e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001ca0:	781a      	ldrb	r2, [r3, #0]
 8001ca2:	697b      	ldr	r3, [r7, #20]
 8001ca4:	701a      	strb	r2, [r3, #0]
      hospi->pBuffPtr++;
 8001ca6:	687b      	ldr	r3, [r7, #4]
 8001ca8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001caa:	1c5a      	adds	r2, r3, #1
 8001cac:	687b      	ldr	r3, [r7, #4]
 8001cae:	641a      	str	r2, [r3, #64]	; 0x40
      hospi->XferCount--;
 8001cb0:	687b      	ldr	r3, [r7, #4]
 8001cb2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001cb4:	1e5a      	subs	r2, r3, #1
 8001cb6:	687b      	ldr	r3, [r7, #4]
 8001cb8:	649a      	str	r2, [r3, #72]	; 0x48
 8001cba:	e012      	b.n	8001ce2 <HAL_OSPI_IRQHandler+0x86>
    }
    else if (currentstate == HAL_OSPI_STATE_BUSY_RX)
 8001cbc:	68bb      	ldr	r3, [r7, #8]
 8001cbe:	2b28      	cmp	r3, #40	; 0x28
 8001cc0:	d10f      	bne.n	8001ce2 <HAL_OSPI_IRQHandler+0x86>
    {
      /* Read a data from the fifo */
      *hospi->pBuffPtr = *((__IO uint8_t *)data_reg);
 8001cc2:	687b      	ldr	r3, [r7, #4]
 8001cc4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001cc6:	697a      	ldr	r2, [r7, #20]
 8001cc8:	7812      	ldrb	r2, [r2, #0]
 8001cca:	b2d2      	uxtb	r2, r2
 8001ccc:	701a      	strb	r2, [r3, #0]
      hospi->pBuffPtr++;
 8001cce:	687b      	ldr	r3, [r7, #4]
 8001cd0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001cd2:	1c5a      	adds	r2, r3, #1
 8001cd4:	687b      	ldr	r3, [r7, #4]
 8001cd6:	641a      	str	r2, [r3, #64]	; 0x40
      hospi->XferCount--;
 8001cd8:	687b      	ldr	r3, [r7, #4]
 8001cda:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001cdc:	1e5a      	subs	r2, r3, #1
 8001cde:	687b      	ldr	r3, [r7, #4]
 8001ce0:	649a      	str	r2, [r3, #72]	; 0x48
    else
    {
      /* Nothing to do */
    }

    if (hospi->XferCount == 0U)
 8001ce2:	687b      	ldr	r3, [r7, #4]
 8001ce4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001ce6:	2b00      	cmp	r3, #0
 8001ce8:	d107      	bne.n	8001cfa <HAL_OSPI_IRQHandler+0x9e>
    {
      /* All data have been received or transmitted for the transfer */
      /* Disable fifo threshold interrupt */
      __HAL_OSPI_DISABLE_IT(hospi, HAL_OSPI_IT_FT);
 8001cea:	687b      	ldr	r3, [r7, #4]
 8001cec:	681b      	ldr	r3, [r3, #0]
 8001cee:	681a      	ldr	r2, [r3, #0]
 8001cf0:	687b      	ldr	r3, [r7, #4]
 8001cf2:	681b      	ldr	r3, [r3, #0]
 8001cf4:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001cf8:	601a      	str	r2, [r3, #0]

    /* Fifo threshold callback */
#if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
    hospi->FifoThresholdCallback(hospi);
#else
    HAL_OSPI_FifoThresholdCallback(hospi);
 8001cfa:	6878      	ldr	r0, [r7, #4]
 8001cfc:	f000 faa7 	bl	800224e <HAL_OSPI_FifoThresholdCallback>
 8001d00:	e0e7      	b.n	8001ed2 <HAL_OSPI_IRQHandler+0x276>
#endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)*/
  }
  /* OctoSPI transfer complete interrupt occurred ----------------------------*/
  else if (((flag & HAL_OSPI_FLAG_TC) != 0U) && ((itsource & HAL_OSPI_IT_TC) != 0U))
 8001d02:	693b      	ldr	r3, [r7, #16]
 8001d04:	f003 0302 	and.w	r3, r3, #2
 8001d08:	2b00      	cmp	r3, #0
 8001d0a:	d067      	beq.n	8001ddc <HAL_OSPI_IRQHandler+0x180>
 8001d0c:	68fb      	ldr	r3, [r7, #12]
 8001d0e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001d12:	2b00      	cmp	r3, #0
 8001d14:	d062      	beq.n	8001ddc <HAL_OSPI_IRQHandler+0x180>
  {
    if (currentstate == HAL_OSPI_STATE_BUSY_RX)
 8001d16:	68bb      	ldr	r3, [r7, #8]
 8001d18:	2b28      	cmp	r3, #40	; 0x28
 8001d1a:	d131      	bne.n	8001d80 <HAL_OSPI_IRQHandler+0x124>
    {
      if ((hospi->XferCount > 0U) && ((flag & OCTOSPI_SR_FLEVEL) != 0U))
 8001d1c:	687b      	ldr	r3, [r7, #4]
 8001d1e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001d20:	2b00      	cmp	r3, #0
 8001d22:	d015      	beq.n	8001d50 <HAL_OSPI_IRQHandler+0xf4>
 8001d24:	693b      	ldr	r3, [r7, #16]
 8001d26:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 8001d2a:	2b00      	cmp	r3, #0
 8001d2c:	d010      	beq.n	8001d50 <HAL_OSPI_IRQHandler+0xf4>
      {
        /* Read the last data received in the fifo */
        *hospi->pBuffPtr = *((__IO uint8_t *)data_reg);
 8001d2e:	687b      	ldr	r3, [r7, #4]
 8001d30:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001d32:	697a      	ldr	r2, [r7, #20]
 8001d34:	7812      	ldrb	r2, [r2, #0]
 8001d36:	b2d2      	uxtb	r2, r2
 8001d38:	701a      	strb	r2, [r3, #0]
        hospi->pBuffPtr++;
 8001d3a:	687b      	ldr	r3, [r7, #4]
 8001d3c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001d3e:	1c5a      	adds	r2, r3, #1
 8001d40:	687b      	ldr	r3, [r7, #4]
 8001d42:	641a      	str	r2, [r3, #64]	; 0x40
        hospi->XferCount--;
 8001d44:	687b      	ldr	r3, [r7, #4]
 8001d46:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001d48:	1e5a      	subs	r2, r3, #1
 8001d4a:	687b      	ldr	r3, [r7, #4]
 8001d4c:	649a      	str	r2, [r3, #72]	; 0x48
    if (currentstate == HAL_OSPI_STATE_BUSY_RX)
 8001d4e:	e0bd      	b.n	8001ecc <HAL_OSPI_IRQHandler+0x270>
      }
      else if (hospi->XferCount == 0U)
 8001d50:	687b      	ldr	r3, [r7, #4]
 8001d52:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001d54:	2b00      	cmp	r3, #0
 8001d56:	f040 80b9 	bne.w	8001ecc <HAL_OSPI_IRQHandler+0x270>
      {
        /* Clear flag */
        hospi->Instance->FCR = HAL_OSPI_FLAG_TC;
 8001d5a:	687b      	ldr	r3, [r7, #4]
 8001d5c:	681b      	ldr	r3, [r3, #0]
 8001d5e:	2202      	movs	r2, #2
 8001d60:	625a      	str	r2, [r3, #36]	; 0x24

        /* Disable the interrupts */
        __HAL_OSPI_DISABLE_IT(hospi, HAL_OSPI_IT_TC | HAL_OSPI_IT_FT | HAL_OSPI_IT_TE);
 8001d62:	687b      	ldr	r3, [r7, #4]
 8001d64:	681b      	ldr	r3, [r3, #0]
 8001d66:	681a      	ldr	r2, [r3, #0]
 8001d68:	687b      	ldr	r3, [r7, #4]
 8001d6a:	681b      	ldr	r3, [r3, #0]
 8001d6c:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
 8001d70:	601a      	str	r2, [r3, #0]

        /* Update state */
        hospi->State = HAL_OSPI_STATE_READY;
 8001d72:	687b      	ldr	r3, [r7, #4]
 8001d74:	2202      	movs	r2, #2
 8001d76:	651a      	str	r2, [r3, #80]	; 0x50

        /* RX complete callback */
#if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
        hospi->RxCpltCallback(hospi);
#else
        HAL_OSPI_RxCpltCallback(hospi);
 8001d78:	6878      	ldr	r0, [r7, #4]
 8001d7a:	f000 fa7c 	bl	8002276 <HAL_OSPI_RxCpltCallback>
    if (currentstate == HAL_OSPI_STATE_BUSY_RX)
 8001d7e:	e0a5      	b.n	8001ecc <HAL_OSPI_IRQHandler+0x270>
      }
    }
    else
    {
      /* Clear flag */
      hospi->Instance->FCR = HAL_OSPI_FLAG_TC;
 8001d80:	687b      	ldr	r3, [r7, #4]
 8001d82:	681b      	ldr	r3, [r3, #0]
 8001d84:	2202      	movs	r2, #2
 8001d86:	625a      	str	r2, [r3, #36]	; 0x24

      /* Disable the interrupts */
      __HAL_OSPI_DISABLE_IT(hospi, HAL_OSPI_IT_TC | HAL_OSPI_IT_FT | HAL_OSPI_IT_TE);
 8001d88:	687b      	ldr	r3, [r7, #4]
 8001d8a:	681b      	ldr	r3, [r3, #0]
 8001d8c:	681a      	ldr	r2, [r3, #0]
 8001d8e:	687b      	ldr	r3, [r7, #4]
 8001d90:	681b      	ldr	r3, [r3, #0]
 8001d92:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
 8001d96:	601a      	str	r2, [r3, #0]

      /* Update state */
      hospi->State = HAL_OSPI_STATE_READY;
 8001d98:	687b      	ldr	r3, [r7, #4]
 8001d9a:	2202      	movs	r2, #2
 8001d9c:	651a      	str	r2, [r3, #80]	; 0x50

      if (currentstate == HAL_OSPI_STATE_BUSY_TX)
 8001d9e:	68bb      	ldr	r3, [r7, #8]
 8001da0:	2b18      	cmp	r3, #24
 8001da2:	d103      	bne.n	8001dac <HAL_OSPI_IRQHandler+0x150>
      {
        /* TX complete callback */
#if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
        hospi->TxCpltCallback(hospi);
#else
        HAL_OSPI_TxCpltCallback(hospi);
 8001da4:	6878      	ldr	r0, [r7, #4]
 8001da6:	f000 fa70 	bl	800228a <HAL_OSPI_TxCpltCallback>
    if (currentstate == HAL_OSPI_STATE_BUSY_RX)
 8001daa:	e08f      	b.n	8001ecc <HAL_OSPI_IRQHandler+0x270>
#endif /* defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
      }
      else if (currentstate == HAL_OSPI_STATE_BUSY_CMD)
 8001dac:	68bb      	ldr	r3, [r7, #8]
 8001dae:	2b08      	cmp	r3, #8
 8001db0:	d103      	bne.n	8001dba <HAL_OSPI_IRQHandler+0x15e>
      {
        /* Command complete callback */
#if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
        hospi->CmdCpltCallback(hospi);
#else
        HAL_OSPI_CmdCpltCallback(hospi);
 8001db2:	6878      	ldr	r0, [r7, #4]
 8001db4:	f000 fa55 	bl	8002262 <HAL_OSPI_CmdCpltCallback>
    if (currentstate == HAL_OSPI_STATE_BUSY_RX)
 8001db8:	e088      	b.n	8001ecc <HAL_OSPI_IRQHandler+0x270>
#endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
      }
      else if (currentstate == HAL_OSPI_STATE_ABORT)
 8001dba:	68bb      	ldr	r3, [r7, #8]
 8001dbc:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8001dc0:	f040 8084 	bne.w	8001ecc <HAL_OSPI_IRQHandler+0x270>
      {
        if (hospi->ErrorCode == HAL_OSPI_ERROR_NONE)
 8001dc4:	687b      	ldr	r3, [r7, #4]
 8001dc6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8001dc8:	2b00      	cmp	r3, #0
 8001dca:	d103      	bne.n	8001dd4 <HAL_OSPI_IRQHandler+0x178>
          /* Abort called by the user */
          /* Abort complete callback */
#if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
          hospi->AbortCpltCallback(hospi);
#else
          HAL_OSPI_AbortCpltCallback(hospi);
 8001dcc:	6878      	ldr	r0, [r7, #4]
 8001dce:	f000 fa34 	bl	800223a <HAL_OSPI_AbortCpltCallback>
    if (currentstate == HAL_OSPI_STATE_BUSY_RX)
 8001dd2:	e07b      	b.n	8001ecc <HAL_OSPI_IRQHandler+0x270>
          /* Abort due to an error (eg : DMA error) */
          /* Error callback */
#if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
          hospi->ErrorCallback(hospi);
#else
          HAL_OSPI_ErrorCallback(hospi);
 8001dd4:	6878      	ldr	r0, [r7, #4]
 8001dd6:	f000 fa26 	bl	8002226 <HAL_OSPI_ErrorCallback>
    if (currentstate == HAL_OSPI_STATE_BUSY_RX)
 8001dda:	e077      	b.n	8001ecc <HAL_OSPI_IRQHandler+0x270>
        /* Nothing to do */
      }
    }
  }
  /* OctoSPI status match interrupt occurred ---------------------------------*/
  else if (((flag & HAL_OSPI_FLAG_SM) != 0U) && ((itsource & HAL_OSPI_IT_SM) != 0U))
 8001ddc:	693b      	ldr	r3, [r7, #16]
 8001dde:	f003 0308 	and.w	r3, r3, #8
 8001de2:	2b00      	cmp	r3, #0
 8001de4:	d01e      	beq.n	8001e24 <HAL_OSPI_IRQHandler+0x1c8>
 8001de6:	68fb      	ldr	r3, [r7, #12]
 8001de8:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8001dec:	2b00      	cmp	r3, #0
 8001dee:	d019      	beq.n	8001e24 <HAL_OSPI_IRQHandler+0x1c8>
  {
    /* Clear flag */
    hospi->Instance->FCR = HAL_OSPI_FLAG_SM;
 8001df0:	687b      	ldr	r3, [r7, #4]
 8001df2:	681b      	ldr	r3, [r3, #0]
 8001df4:	2208      	movs	r2, #8
 8001df6:	625a      	str	r2, [r3, #36]	; 0x24

    /* Check if automatic poll mode stop is activated */
    if ((hospi->Instance->CR & OCTOSPI_CR_APMS) != 0U)
 8001df8:	687b      	ldr	r3, [r7, #4]
 8001dfa:	681b      	ldr	r3, [r3, #0]
 8001dfc:	681b      	ldr	r3, [r3, #0]
 8001dfe:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8001e02:	2b00      	cmp	r3, #0
 8001e04:	d00a      	beq.n	8001e1c <HAL_OSPI_IRQHandler+0x1c0>
    {
      /* Disable the interrupts */
      __HAL_OSPI_DISABLE_IT(hospi, HAL_OSPI_IT_SM | HAL_OSPI_IT_TE);
 8001e06:	687b      	ldr	r3, [r7, #4]
 8001e08:	681b      	ldr	r3, [r3, #0]
 8001e0a:	681a      	ldr	r2, [r3, #0]
 8001e0c:	687b      	ldr	r3, [r7, #4]
 8001e0e:	681b      	ldr	r3, [r3, #0]
 8001e10:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
 8001e14:	601a      	str	r2, [r3, #0]

      /* Update state */
      hospi->State = HAL_OSPI_STATE_READY;
 8001e16:	687b      	ldr	r3, [r7, #4]
 8001e18:	2202      	movs	r2, #2
 8001e1a:	651a      	str	r2, [r3, #80]	; 0x50

    /* Status match callback */
#if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
    hospi->StatusMatchCallback(hospi);
#else
    HAL_OSPI_StatusMatchCallback(hospi);
 8001e1c:	6878      	ldr	r0, [r7, #4]
 8001e1e:	f000 fa3e 	bl	800229e <HAL_OSPI_StatusMatchCallback>
 8001e22:	e056      	b.n	8001ed2 <HAL_OSPI_IRQHandler+0x276>
#endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
  }
  /* OctoSPI transfer error interrupt occurred -------------------------------*/
  else if (((flag & HAL_OSPI_FLAG_TE) != 0U) && ((itsource & HAL_OSPI_IT_TE) != 0U))
 8001e24:	693b      	ldr	r3, [r7, #16]
 8001e26:	f003 0301 	and.w	r3, r3, #1
 8001e2a:	2b00      	cmp	r3, #0
 8001e2c:	d03c      	beq.n	8001ea8 <HAL_OSPI_IRQHandler+0x24c>
 8001e2e:	68fb      	ldr	r3, [r7, #12]
 8001e30:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8001e34:	2b00      	cmp	r3, #0
 8001e36:	d037      	beq.n	8001ea8 <HAL_OSPI_IRQHandler+0x24c>
  {
    /* Clear flag */
    hospi->Instance->FCR = HAL_OSPI_FLAG_TE;
 8001e38:	687b      	ldr	r3, [r7, #4]
 8001e3a:	681b      	ldr	r3, [r3, #0]
 8001e3c:	2201      	movs	r2, #1
 8001e3e:	625a      	str	r2, [r3, #36]	; 0x24

    /* Disable all interrupts */
    __HAL_OSPI_DISABLE_IT(hospi, (HAL_OSPI_IT_TO | HAL_OSPI_IT_SM | HAL_OSPI_IT_FT | HAL_OSPI_IT_TC | HAL_OSPI_IT_TE));
 8001e40:	687b      	ldr	r3, [r7, #4]
 8001e42:	681b      	ldr	r3, [r3, #0]
 8001e44:	681a      	ldr	r2, [r3, #0]
 8001e46:	687b      	ldr	r3, [r7, #4]
 8001e48:	681b      	ldr	r3, [r3, #0]
 8001e4a:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8001e4e:	601a      	str	r2, [r3, #0]

    /* Set error code */
    hospi->ErrorCode = HAL_OSPI_ERROR_TRANSFER;
 8001e50:	687b      	ldr	r3, [r7, #4]
 8001e52:	2202      	movs	r2, #2
 8001e54:	655a      	str	r2, [r3, #84]	; 0x54

    /* Check if the DMA is enabled */
    if ((hospi->Instance->CR & OCTOSPI_CR_DMAEN) != 0U)
 8001e56:	687b      	ldr	r3, [r7, #4]
 8001e58:	681b      	ldr	r3, [r3, #0]
 8001e5a:	681b      	ldr	r3, [r3, #0]
 8001e5c:	f003 0304 	and.w	r3, r3, #4
 8001e60:	2b00      	cmp	r3, #0
 8001e62:	d01a      	beq.n	8001e9a <HAL_OSPI_IRQHandler+0x23e>
    {
      /* Disable the DMA transfer on the OctoSPI side */
      CLEAR_BIT(hospi->Instance->CR, OCTOSPI_CR_DMAEN);
 8001e64:	687b      	ldr	r3, [r7, #4]
 8001e66:	681b      	ldr	r3, [r3, #0]
 8001e68:	681a      	ldr	r2, [r3, #0]
 8001e6a:	687b      	ldr	r3, [r7, #4]
 8001e6c:	681b      	ldr	r3, [r3, #0]
 8001e6e:	f022 0204 	bic.w	r2, r2, #4
 8001e72:	601a      	str	r2, [r3, #0]

      /* Disable the DMA transfer on the DMA side */
      hospi->hdma->XferAbortCallback = OSPI_DMAAbortCplt;
 8001e74:	687b      	ldr	r3, [r7, #4]
 8001e76:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001e78:	4a18      	ldr	r2, [pc, #96]	; (8001edc <HAL_OSPI_IRQHandler+0x280>)
 8001e7a:	66da      	str	r2, [r3, #108]	; 0x6c
      if (HAL_DMA_Abort_IT(hospi->hdma) != HAL_OK)
 8001e7c:	687b      	ldr	r3, [r7, #4]
 8001e7e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001e80:	4618      	mov	r0, r3
 8001e82:	f7ff fab6 	bl	80013f2 <HAL_DMA_Abort_IT>
 8001e86:	4603      	mov	r3, r0
 8001e88:	2b00      	cmp	r3, #0
 8001e8a:	d021      	beq.n	8001ed0 <HAL_OSPI_IRQHandler+0x274>
      {
        /* Update state */
        hospi->State = HAL_OSPI_STATE_READY;
 8001e8c:	687b      	ldr	r3, [r7, #4]
 8001e8e:	2202      	movs	r2, #2
 8001e90:	651a      	str	r2, [r3, #80]	; 0x50

        /* Error callback */
#if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
        hospi->ErrorCallback(hospi);
#else
        HAL_OSPI_ErrorCallback(hospi);
 8001e92:	6878      	ldr	r0, [r7, #4]
 8001e94:	f000 f9c7 	bl	8002226 <HAL_OSPI_ErrorCallback>
    if ((hospi->Instance->CR & OCTOSPI_CR_DMAEN) != 0U)
 8001e98:	e01a      	b.n	8001ed0 <HAL_OSPI_IRQHandler+0x274>
      }
    }
    else
    {
      /* Update state */
      hospi->State = HAL_OSPI_STATE_READY;
 8001e9a:	687b      	ldr	r3, [r7, #4]
 8001e9c:	2202      	movs	r2, #2
 8001e9e:	651a      	str	r2, [r3, #80]	; 0x50

      /* Error callback */
#if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
      hospi->ErrorCallback(hospi);
#else
      HAL_OSPI_ErrorCallback(hospi);
 8001ea0:	6878      	ldr	r0, [r7, #4]
 8001ea2:	f000 f9c0 	bl	8002226 <HAL_OSPI_ErrorCallback>
    if ((hospi->Instance->CR & OCTOSPI_CR_DMAEN) != 0U)
 8001ea6:	e013      	b.n	8001ed0 <HAL_OSPI_IRQHandler+0x274>
#endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
    }
  }
  /* OctoSPI timeout interrupt occurred --------------------------------------*/
  else if (((flag & HAL_OSPI_FLAG_TO) != 0U) && ((itsource & HAL_OSPI_IT_TO) != 0U))
 8001ea8:	693b      	ldr	r3, [r7, #16]
 8001eaa:	f003 0310 	and.w	r3, r3, #16
 8001eae:	2b00      	cmp	r3, #0
 8001eb0:	d00f      	beq.n	8001ed2 <HAL_OSPI_IRQHandler+0x276>
 8001eb2:	68fb      	ldr	r3, [r7, #12]
 8001eb4:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8001eb8:	2b00      	cmp	r3, #0
 8001eba:	d00a      	beq.n	8001ed2 <HAL_OSPI_IRQHandler+0x276>
  {
    /* Clear flag */
    hospi->Instance->FCR = HAL_OSPI_FLAG_TO;
 8001ebc:	687b      	ldr	r3, [r7, #4]
 8001ebe:	681b      	ldr	r3, [r3, #0]
 8001ec0:	2210      	movs	r2, #16
 8001ec2:	625a      	str	r2, [r3, #36]	; 0x24

    /* Timeout callback */
#if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
    hospi->TimeOutCallback(hospi);
#else
    HAL_OSPI_TimeOutCallback(hospi);
 8001ec4:	6878      	ldr	r0, [r7, #4]
 8001ec6:	f000 f9f4 	bl	80022b2 <HAL_OSPI_TimeOutCallback>
  }
  else
  {
    /* Nothing to do */
  }
}
 8001eca:	e002      	b.n	8001ed2 <HAL_OSPI_IRQHandler+0x276>
    if (currentstate == HAL_OSPI_STATE_BUSY_RX)
 8001ecc:	bf00      	nop
 8001ece:	e000      	b.n	8001ed2 <HAL_OSPI_IRQHandler+0x276>
    if ((hospi->Instance->CR & OCTOSPI_CR_DMAEN) != 0U)
 8001ed0:	bf00      	nop
}
 8001ed2:	bf00      	nop
 8001ed4:	3718      	adds	r7, #24
 8001ed6:	46bd      	mov	sp, r7
 8001ed8:	bd80      	pop	{r7, pc}
 8001eda:	bf00      	nop
 8001edc:	08002db5 	.word	0x08002db5

08001ee0 <HAL_OSPI_Command>:
  * @param  cmd     : structure that contains the command configuration information
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_Command(OSPI_HandleTypeDef *hospi, OSPI_RegularCmdTypeDef *cmd, uint32_t Timeout)
{
 8001ee0:	b580      	push	{r7, lr}
 8001ee2:	b08a      	sub	sp, #40	; 0x28
 8001ee4:	af02      	add	r7, sp, #8
 8001ee6:	60f8      	str	r0, [r7, #12]
 8001ee8:	60b9      	str	r1, [r7, #8]
 8001eea:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t state;
  uint32_t tickstart = HAL_GetTick();
 8001eec:	f7ff f894 	bl	8001018 <HAL_GetTick>
 8001ef0:	61b8      	str	r0, [r7, #24]
    assert_param(IS_OSPI_ALT_BYTES_SIZE(cmd->AlternateBytesSize));
    assert_param(IS_OSPI_ALT_BYTES_DTR_MODE(cmd->AlternateBytesDtrMode));
  }

  assert_param(IS_OSPI_DATA_MODE(cmd->DataMode));
  if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 8001ef2:	68bb      	ldr	r3, [r7, #8]
 8001ef4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001ef6:	2b00      	cmp	r3, #0

  assert_param(IS_OSPI_DQS_MODE(cmd->DQSMode));
  assert_param(IS_OSPI_SIOO_MODE(cmd->SIOOMode));

  /* Check the state of the driver */
  state = hospi->State;
 8001ef8:	68fb      	ldr	r3, [r7, #12]
 8001efa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001efc:	617b      	str	r3, [r7, #20]
  if (((state == HAL_OSPI_STATE_READY)         && (hospi->Init.MemoryType != HAL_OSPI_MEMTYPE_HYPERBUS)) ||
 8001efe:	697b      	ldr	r3, [r7, #20]
 8001f00:	2b02      	cmp	r3, #2
 8001f02:	d104      	bne.n	8001f0e <HAL_OSPI_Command+0x2e>
 8001f04:	68fb      	ldr	r3, [r7, #12]
 8001f06:	68db      	ldr	r3, [r3, #12]
 8001f08:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8001f0c:	d115      	bne.n	8001f3a <HAL_OSPI_Command+0x5a>
 8001f0e:	697b      	ldr	r3, [r7, #20]
 8001f10:	2b14      	cmp	r3, #20
 8001f12:	d107      	bne.n	8001f24 <HAL_OSPI_Command+0x44>
      ((state == HAL_OSPI_STATE_READ_CMD_CFG)  && ((cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG)
 8001f14:	68bb      	ldr	r3, [r7, #8]
 8001f16:	681b      	ldr	r3, [r3, #0]
 8001f18:	2b02      	cmp	r3, #2
 8001f1a:	d00e      	beq.n	8001f3a <HAL_OSPI_Command+0x5a>
                                                   || (cmd->OperationType == HAL_OSPI_OPTYPE_WRAP_CFG))) ||
 8001f1c:	68bb      	ldr	r3, [r7, #8]
 8001f1e:	681b      	ldr	r3, [r3, #0]
 8001f20:	2b03      	cmp	r3, #3
 8001f22:	d00a      	beq.n	8001f3a <HAL_OSPI_Command+0x5a>
 8001f24:	697b      	ldr	r3, [r7, #20]
 8001f26:	2b24      	cmp	r3, #36	; 0x24
 8001f28:	d15b      	bne.n	8001fe2 <HAL_OSPI_Command+0x102>
      ((state == HAL_OSPI_STATE_WRITE_CMD_CFG) && ((cmd->OperationType == HAL_OSPI_OPTYPE_READ_CFG)  ||
 8001f2a:	68bb      	ldr	r3, [r7, #8]
 8001f2c:	681b      	ldr	r3, [r3, #0]
 8001f2e:	2b01      	cmp	r3, #1
 8001f30:	d003      	beq.n	8001f3a <HAL_OSPI_Command+0x5a>
                                                   (cmd->OperationType == HAL_OSPI_OPTYPE_WRAP_CFG))))
 8001f32:	68bb      	ldr	r3, [r7, #8]
 8001f34:	681b      	ldr	r3, [r3, #0]
      ((state == HAL_OSPI_STATE_WRITE_CMD_CFG) && ((cmd->OperationType == HAL_OSPI_OPTYPE_READ_CFG)  ||
 8001f36:	2b03      	cmp	r3, #3
 8001f38:	d153      	bne.n	8001fe2 <HAL_OSPI_Command+0x102>
  {
    /* Wait till busy flag is reset */
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 8001f3a:	687b      	ldr	r3, [r7, #4]
 8001f3c:	9300      	str	r3, [sp, #0]
 8001f3e:	69bb      	ldr	r3, [r7, #24]
 8001f40:	2200      	movs	r2, #0
 8001f42:	2120      	movs	r1, #32
 8001f44:	68f8      	ldr	r0, [r7, #12]
 8001f46:	f000 ff71 	bl	8002e2c <OSPI_WaitFlagStateUntilTimeout>
 8001f4a:	4603      	mov	r3, r0
 8001f4c:	77fb      	strb	r3, [r7, #31]

    if (status == HAL_OK)
 8001f4e:	7ffb      	ldrb	r3, [r7, #31]
 8001f50:	2b00      	cmp	r3, #0
 8001f52:	d14c      	bne.n	8001fee <HAL_OSPI_Command+0x10e>
    {
      /* Initialize error code */
      hospi->ErrorCode = HAL_OSPI_ERROR_NONE;
 8001f54:	68fb      	ldr	r3, [r7, #12]
 8001f56:	2200      	movs	r2, #0
 8001f58:	655a      	str	r2, [r3, #84]	; 0x54

      /* Configure the registers */
      status = OSPI_ConfigCmd(hospi, cmd);
 8001f5a:	68b9      	ldr	r1, [r7, #8]
 8001f5c:	68f8      	ldr	r0, [r7, #12]
 8001f5e:	f000 ffa5 	bl	8002eac <OSPI_ConfigCmd>
 8001f62:	4603      	mov	r3, r0
 8001f64:	77fb      	strb	r3, [r7, #31]

      if (status == HAL_OK)
 8001f66:	7ffb      	ldrb	r3, [r7, #31]
 8001f68:	2b00      	cmp	r3, #0
 8001f6a:	d140      	bne.n	8001fee <HAL_OSPI_Command+0x10e>
      {
        if (cmd->DataMode == HAL_OSPI_DATA_NONE)
 8001f6c:	68bb      	ldr	r3, [r7, #8]
 8001f6e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001f70:	2b00      	cmp	r3, #0
 8001f72:	d10e      	bne.n	8001f92 <HAL_OSPI_Command+0xb2>
        {
          /* When there is no data phase, the transfer start as soon as the configuration is done
             so wait until TC flag is set to go back in idle state */
          status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, Timeout);
 8001f74:	687b      	ldr	r3, [r7, #4]
 8001f76:	9300      	str	r3, [sp, #0]
 8001f78:	69bb      	ldr	r3, [r7, #24]
 8001f7a:	2201      	movs	r2, #1
 8001f7c:	2102      	movs	r1, #2
 8001f7e:	68f8      	ldr	r0, [r7, #12]
 8001f80:	f000 ff54 	bl	8002e2c <OSPI_WaitFlagStateUntilTimeout>
 8001f84:	4603      	mov	r3, r0
 8001f86:	77fb      	strb	r3, [r7, #31]

          __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 8001f88:	68fb      	ldr	r3, [r7, #12]
 8001f8a:	681b      	ldr	r3, [r3, #0]
 8001f8c:	2202      	movs	r2, #2
 8001f8e:	625a      	str	r2, [r3, #36]	; 0x24
    if (status == HAL_OK)
 8001f90:	e02d      	b.n	8001fee <HAL_OSPI_Command+0x10e>
        }
        else
        {
          /* Update the state */
          if (cmd->OperationType == HAL_OSPI_OPTYPE_COMMON_CFG)
 8001f92:	68bb      	ldr	r3, [r7, #8]
 8001f94:	681b      	ldr	r3, [r3, #0]
 8001f96:	2b00      	cmp	r3, #0
 8001f98:	d103      	bne.n	8001fa2 <HAL_OSPI_Command+0xc2>
          {
            hospi->State = HAL_OSPI_STATE_CMD_CFG;
 8001f9a:	68fb      	ldr	r3, [r7, #12]
 8001f9c:	2204      	movs	r2, #4
 8001f9e:	651a      	str	r2, [r3, #80]	; 0x50
    if (status == HAL_OK)
 8001fa0:	e025      	b.n	8001fee <HAL_OSPI_Command+0x10e>
          }
          else if (cmd->OperationType == HAL_OSPI_OPTYPE_READ_CFG)
 8001fa2:	68bb      	ldr	r3, [r7, #8]
 8001fa4:	681b      	ldr	r3, [r3, #0]
 8001fa6:	2b01      	cmp	r3, #1
 8001fa8:	d10b      	bne.n	8001fc2 <HAL_OSPI_Command+0xe2>
          {
            if (hospi->State == HAL_OSPI_STATE_WRITE_CMD_CFG)
 8001faa:	68fb      	ldr	r3, [r7, #12]
 8001fac:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001fae:	2b24      	cmp	r3, #36	; 0x24
 8001fb0:	d103      	bne.n	8001fba <HAL_OSPI_Command+0xda>
            {
              hospi->State = HAL_OSPI_STATE_CMD_CFG;
 8001fb2:	68fb      	ldr	r3, [r7, #12]
 8001fb4:	2204      	movs	r2, #4
 8001fb6:	651a      	str	r2, [r3, #80]	; 0x50
    if (status == HAL_OK)
 8001fb8:	e019      	b.n	8001fee <HAL_OSPI_Command+0x10e>
            }
            else
            {
              hospi->State = HAL_OSPI_STATE_READ_CMD_CFG;
 8001fba:	68fb      	ldr	r3, [r7, #12]
 8001fbc:	2214      	movs	r2, #20
 8001fbe:	651a      	str	r2, [r3, #80]	; 0x50
    if (status == HAL_OK)
 8001fc0:	e015      	b.n	8001fee <HAL_OSPI_Command+0x10e>
            }
          }
          else if (cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG)
 8001fc2:	68bb      	ldr	r3, [r7, #8]
 8001fc4:	681b      	ldr	r3, [r3, #0]
 8001fc6:	2b02      	cmp	r3, #2
 8001fc8:	d111      	bne.n	8001fee <HAL_OSPI_Command+0x10e>
          {
            if (hospi->State == HAL_OSPI_STATE_READ_CMD_CFG)
 8001fca:	68fb      	ldr	r3, [r7, #12]
 8001fcc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001fce:	2b14      	cmp	r3, #20
 8001fd0:	d103      	bne.n	8001fda <HAL_OSPI_Command+0xfa>
            {
              hospi->State = HAL_OSPI_STATE_CMD_CFG;
 8001fd2:	68fb      	ldr	r3, [r7, #12]
 8001fd4:	2204      	movs	r2, #4
 8001fd6:	651a      	str	r2, [r3, #80]	; 0x50
    if (status == HAL_OK)
 8001fd8:	e009      	b.n	8001fee <HAL_OSPI_Command+0x10e>
            }
            else
            {
              hospi->State = HAL_OSPI_STATE_WRITE_CMD_CFG;
 8001fda:	68fb      	ldr	r3, [r7, #12]
 8001fdc:	2224      	movs	r2, #36	; 0x24
 8001fde:	651a      	str	r2, [r3, #80]	; 0x50
    if (status == HAL_OK)
 8001fe0:	e005      	b.n	8001fee <HAL_OSPI_Command+0x10e>
      }
    }
  }
  else
  {
    status = HAL_ERROR;
 8001fe2:	2301      	movs	r3, #1
 8001fe4:	77fb      	strb	r3, [r7, #31]
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 8001fe6:	68fb      	ldr	r3, [r7, #12]
 8001fe8:	2210      	movs	r2, #16
 8001fea:	655a      	str	r2, [r3, #84]	; 0x54
 8001fec:	e000      	b.n	8001ff0 <HAL_OSPI_Command+0x110>
    if (status == HAL_OK)
 8001fee:	bf00      	nop
  }

  /* Return function status */
  return status;
 8001ff0:	7ffb      	ldrb	r3, [r7, #31]
}
 8001ff2:	4618      	mov	r0, r3
 8001ff4:	3720      	adds	r7, #32
 8001ff6:	46bd      	mov	sp, r7
 8001ff8:	bd80      	pop	{r7, pc}

08001ffa <HAL_OSPI_Transmit>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_Transmit(OSPI_HandleTypeDef *hospi, uint8_t *pData, uint32_t Timeout)
{
 8001ffa:	b580      	push	{r7, lr}
 8001ffc:	b08a      	sub	sp, #40	; 0x28
 8001ffe:	af02      	add	r7, sp, #8
 8002000:	60f8      	str	r0, [r7, #12]
 8002002:	60b9      	str	r1, [r7, #8]
 8002004:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 8002006:	f7ff f807 	bl	8001018 <HAL_GetTick>
 800200a:	61b8      	str	r0, [r7, #24]
  __IO uint32_t *data_reg = &hospi->Instance->DR;
 800200c:	68fb      	ldr	r3, [r7, #12]
 800200e:	681b      	ldr	r3, [r3, #0]
 8002010:	3350      	adds	r3, #80	; 0x50
 8002012:	617b      	str	r3, [r7, #20]

  /* Check the data pointer allocation */
  if (pData == NULL)
 8002014:	68bb      	ldr	r3, [r7, #8]
 8002016:	2b00      	cmp	r3, #0
 8002018:	d105      	bne.n	8002026 <HAL_OSPI_Transmit+0x2c>
  {
    status = HAL_ERROR;
 800201a:	2301      	movs	r3, #1
 800201c:	77fb      	strb	r3, [r7, #31]
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
 800201e:	68fb      	ldr	r3, [r7, #12]
 8002020:	2208      	movs	r2, #8
 8002022:	655a      	str	r2, [r3, #84]	; 0x54
 8002024:	e057      	b.n	80020d6 <HAL_OSPI_Transmit+0xdc>
  }
  else
  {
    /* Check the state */
    if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 8002026:	68fb      	ldr	r3, [r7, #12]
 8002028:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800202a:	2b04      	cmp	r3, #4
 800202c:	d14e      	bne.n	80020cc <HAL_OSPI_Transmit+0xd2>
    {
      /* Configure counters and size */
      hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
 800202e:	68fb      	ldr	r3, [r7, #12]
 8002030:	681b      	ldr	r3, [r3, #0]
 8002032:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002034:	1c5a      	adds	r2, r3, #1
 8002036:	68fb      	ldr	r3, [r7, #12]
 8002038:	649a      	str	r2, [r3, #72]	; 0x48
      hospi->XferSize  = hospi->XferCount;
 800203a:	68fb      	ldr	r3, [r7, #12]
 800203c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800203e:	68fb      	ldr	r3, [r7, #12]
 8002040:	645a      	str	r2, [r3, #68]	; 0x44
      hospi->pBuffPtr  = pData;
 8002042:	68fb      	ldr	r3, [r7, #12]
 8002044:	68ba      	ldr	r2, [r7, #8]
 8002046:	641a      	str	r2, [r3, #64]	; 0x40

      /* Configure CR register with functional mode as indirect write */
      MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, OSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
 8002048:	68fb      	ldr	r3, [r7, #12]
 800204a:	681b      	ldr	r3, [r3, #0]
 800204c:	681a      	ldr	r2, [r3, #0]
 800204e:	68fb      	ldr	r3, [r7, #12]
 8002050:	681b      	ldr	r3, [r3, #0]
 8002052:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8002056:	601a      	str	r2, [r3, #0]

      do
      {
        /* Wait till fifo threshold flag is set to send data */
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_FT, SET, tickstart, Timeout);
 8002058:	687b      	ldr	r3, [r7, #4]
 800205a:	9300      	str	r3, [sp, #0]
 800205c:	69bb      	ldr	r3, [r7, #24]
 800205e:	2201      	movs	r2, #1
 8002060:	2104      	movs	r1, #4
 8002062:	68f8      	ldr	r0, [r7, #12]
 8002064:	f000 fee2 	bl	8002e2c <OSPI_WaitFlagStateUntilTimeout>
 8002068:	4603      	mov	r3, r0
 800206a:	77fb      	strb	r3, [r7, #31]

        if (status != HAL_OK)
 800206c:	7ffb      	ldrb	r3, [r7, #31]
 800206e:	2b00      	cmp	r3, #0
 8002070:	d113      	bne.n	800209a <HAL_OSPI_Transmit+0xa0>
        {
          break;
        }

        *((__IO uint8_t *)data_reg) = *hospi->pBuffPtr;
 8002072:	68fb      	ldr	r3, [r7, #12]
 8002074:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002076:	781a      	ldrb	r2, [r3, #0]
 8002078:	697b      	ldr	r3, [r7, #20]
 800207a:	701a      	strb	r2, [r3, #0]
        hospi->pBuffPtr++;
 800207c:	68fb      	ldr	r3, [r7, #12]
 800207e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002080:	1c5a      	adds	r2, r3, #1
 8002082:	68fb      	ldr	r3, [r7, #12]
 8002084:	641a      	str	r2, [r3, #64]	; 0x40
        hospi->XferCount--;
 8002086:	68fb      	ldr	r3, [r7, #12]
 8002088:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800208a:	1e5a      	subs	r2, r3, #1
 800208c:	68fb      	ldr	r3, [r7, #12]
 800208e:	649a      	str	r2, [r3, #72]	; 0x48
      } while (hospi->XferCount > 0U);
 8002090:	68fb      	ldr	r3, [r7, #12]
 8002092:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8002094:	2b00      	cmp	r3, #0
 8002096:	d1df      	bne.n	8002058 <HAL_OSPI_Transmit+0x5e>
 8002098:	e000      	b.n	800209c <HAL_OSPI_Transmit+0xa2>
          break;
 800209a:	bf00      	nop

      if (status == HAL_OK)
 800209c:	7ffb      	ldrb	r3, [r7, #31]
 800209e:	2b00      	cmp	r3, #0
 80020a0:	d119      	bne.n	80020d6 <HAL_OSPI_Transmit+0xdc>
      {
        /* Wait till transfer complete flag is set to go back in idle state */
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, Timeout);
 80020a2:	687b      	ldr	r3, [r7, #4]
 80020a4:	9300      	str	r3, [sp, #0]
 80020a6:	69bb      	ldr	r3, [r7, #24]
 80020a8:	2201      	movs	r2, #1
 80020aa:	2102      	movs	r1, #2
 80020ac:	68f8      	ldr	r0, [r7, #12]
 80020ae:	f000 febd 	bl	8002e2c <OSPI_WaitFlagStateUntilTimeout>
 80020b2:	4603      	mov	r3, r0
 80020b4:	77fb      	strb	r3, [r7, #31]

        if (status == HAL_OK)
 80020b6:	7ffb      	ldrb	r3, [r7, #31]
 80020b8:	2b00      	cmp	r3, #0
 80020ba:	d10c      	bne.n	80020d6 <HAL_OSPI_Transmit+0xdc>
        {
          /* Clear transfer complete flag */
          __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 80020bc:	68fb      	ldr	r3, [r7, #12]
 80020be:	681b      	ldr	r3, [r3, #0]
 80020c0:	2202      	movs	r2, #2
 80020c2:	625a      	str	r2, [r3, #36]	; 0x24

          /* Update state */
          hospi->State = HAL_OSPI_STATE_READY;
 80020c4:	68fb      	ldr	r3, [r7, #12]
 80020c6:	2202      	movs	r2, #2
 80020c8:	651a      	str	r2, [r3, #80]	; 0x50
 80020ca:	e004      	b.n	80020d6 <HAL_OSPI_Transmit+0xdc>
        }
      }
    }
    else
    {
      status = HAL_ERROR;
 80020cc:	2301      	movs	r3, #1
 80020ce:	77fb      	strb	r3, [r7, #31]
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 80020d0:	68fb      	ldr	r3, [r7, #12]
 80020d2:	2210      	movs	r2, #16
 80020d4:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }

  /* Return function status */
  return status;
 80020d6:	7ffb      	ldrb	r3, [r7, #31]
}
 80020d8:	4618      	mov	r0, r3
 80020da:	3720      	adds	r7, #32
 80020dc:	46bd      	mov	sp, r7
 80020de:	bd80      	pop	{r7, pc}

080020e0 <HAL_OSPI_Receive>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_Receive(OSPI_HandleTypeDef *hospi, uint8_t *pData, uint32_t Timeout)
{
 80020e0:	b580      	push	{r7, lr}
 80020e2:	b08c      	sub	sp, #48	; 0x30
 80020e4:	af02      	add	r7, sp, #8
 80020e6:	60f8      	str	r0, [r7, #12]
 80020e8:	60b9      	str	r1, [r7, #8]
 80020ea:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 80020ec:	f7fe ff94 	bl	8001018 <HAL_GetTick>
 80020f0:	6238      	str	r0, [r7, #32]
  __IO uint32_t *data_reg = &hospi->Instance->DR;
 80020f2:	68fb      	ldr	r3, [r7, #12]
 80020f4:	681b      	ldr	r3, [r3, #0]
 80020f6:	3350      	adds	r3, #80	; 0x50
 80020f8:	61fb      	str	r3, [r7, #28]
  uint32_t addr_reg = hospi->Instance->AR;
 80020fa:	68fb      	ldr	r3, [r7, #12]
 80020fc:	681b      	ldr	r3, [r3, #0]
 80020fe:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8002100:	61bb      	str	r3, [r7, #24]
  uint32_t ir_reg = hospi->Instance->IR;
 8002102:	68fb      	ldr	r3, [r7, #12]
 8002104:	681b      	ldr	r3, [r3, #0]
 8002106:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 800210a:	617b      	str	r3, [r7, #20]

  /* Check the data pointer allocation */
  if (pData == NULL)
 800210c:	68bb      	ldr	r3, [r7, #8]
 800210e:	2b00      	cmp	r3, #0
 8002110:	d106      	bne.n	8002120 <HAL_OSPI_Receive+0x40>
  {
    status = HAL_ERROR;
 8002112:	2301      	movs	r3, #1
 8002114:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
 8002118:	68fb      	ldr	r3, [r7, #12]
 800211a:	2208      	movs	r2, #8
 800211c:	655a      	str	r2, [r3, #84]	; 0x54
 800211e:	e07c      	b.n	800221a <HAL_OSPI_Receive+0x13a>
  }
  else
  {
    /* Check the state */
    if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 8002120:	68fb      	ldr	r3, [r7, #12]
 8002122:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8002124:	2b04      	cmp	r3, #4
 8002126:	d172      	bne.n	800220e <HAL_OSPI_Receive+0x12e>
    {
      /* Configure counters and size */
      hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
 8002128:	68fb      	ldr	r3, [r7, #12]
 800212a:	681b      	ldr	r3, [r3, #0]
 800212c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800212e:	1c5a      	adds	r2, r3, #1
 8002130:	68fb      	ldr	r3, [r7, #12]
 8002132:	649a      	str	r2, [r3, #72]	; 0x48
      hospi->XferSize  = hospi->XferCount;
 8002134:	68fb      	ldr	r3, [r7, #12]
 8002136:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8002138:	68fb      	ldr	r3, [r7, #12]
 800213a:	645a      	str	r2, [r3, #68]	; 0x44
      hospi->pBuffPtr  = pData;
 800213c:	68fb      	ldr	r3, [r7, #12]
 800213e:	68ba      	ldr	r2, [r7, #8]
 8002140:	641a      	str	r2, [r3, #64]	; 0x40

      /* Configure CR register with functional mode as indirect read */
      MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, OSPI_FUNCTIONAL_MODE_INDIRECT_READ);
 8002142:	68fb      	ldr	r3, [r7, #12]
 8002144:	681b      	ldr	r3, [r3, #0]
 8002146:	681b      	ldr	r3, [r3, #0]
 8002148:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
 800214c:	68fb      	ldr	r3, [r7, #12]
 800214e:	681b      	ldr	r3, [r3, #0]
 8002150:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002154:	601a      	str	r2, [r3, #0]

      /* Trig the transfer by re-writing address or instruction register */
      if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 8002156:	68fb      	ldr	r3, [r7, #12]
 8002158:	68db      	ldr	r3, [r3, #12]
 800215a:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 800215e:	d104      	bne.n	800216a <HAL_OSPI_Receive+0x8a>
      {
        WRITE_REG(hospi->Instance->AR, addr_reg);
 8002160:	68fb      	ldr	r3, [r7, #12]
 8002162:	681b      	ldr	r3, [r3, #0]
 8002164:	69ba      	ldr	r2, [r7, #24]
 8002166:	649a      	str	r2, [r3, #72]	; 0x48
 8002168:	e011      	b.n	800218e <HAL_OSPI_Receive+0xae>
      }
      else
      {
        if (READ_BIT(hospi->Instance->CCR, OCTOSPI_CCR_ADMODE) != HAL_OSPI_ADDRESS_NONE)
 800216a:	68fb      	ldr	r3, [r7, #12]
 800216c:	681b      	ldr	r3, [r3, #0]
 800216e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8002172:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8002176:	2b00      	cmp	r3, #0
 8002178:	d004      	beq.n	8002184 <HAL_OSPI_Receive+0xa4>
        {
          WRITE_REG(hospi->Instance->AR, addr_reg);
 800217a:	68fb      	ldr	r3, [r7, #12]
 800217c:	681b      	ldr	r3, [r3, #0]
 800217e:	69ba      	ldr	r2, [r7, #24]
 8002180:	649a      	str	r2, [r3, #72]	; 0x48
 8002182:	e004      	b.n	800218e <HAL_OSPI_Receive+0xae>
        }
        else
        {
          WRITE_REG(hospi->Instance->IR, ir_reg);
 8002184:	68fb      	ldr	r3, [r7, #12]
 8002186:	681b      	ldr	r3, [r3, #0]
 8002188:	697a      	ldr	r2, [r7, #20]
 800218a:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
      }

      do
      {
        /* Wait till fifo threshold or transfer complete flags are set to read received data */
        status = OSPI_WaitFlagStateUntilTimeout(hospi, (HAL_OSPI_FLAG_FT | HAL_OSPI_FLAG_TC), SET, tickstart, Timeout);
 800218e:	687b      	ldr	r3, [r7, #4]
 8002190:	9300      	str	r3, [sp, #0]
 8002192:	6a3b      	ldr	r3, [r7, #32]
 8002194:	2201      	movs	r2, #1
 8002196:	2106      	movs	r1, #6
 8002198:	68f8      	ldr	r0, [r7, #12]
 800219a:	f000 fe47 	bl	8002e2c <OSPI_WaitFlagStateUntilTimeout>
 800219e:	4603      	mov	r3, r0
 80021a0:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

        if (status != HAL_OK)
 80021a4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80021a8:	2b00      	cmp	r3, #0
 80021aa:	d114      	bne.n	80021d6 <HAL_OSPI_Receive+0xf6>
        {
          break;
        }

        *hospi->pBuffPtr = *((__IO uint8_t *)data_reg);
 80021ac:	68fb      	ldr	r3, [r7, #12]
 80021ae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80021b0:	69fa      	ldr	r2, [r7, #28]
 80021b2:	7812      	ldrb	r2, [r2, #0]
 80021b4:	b2d2      	uxtb	r2, r2
 80021b6:	701a      	strb	r2, [r3, #0]
        hospi->pBuffPtr++;
 80021b8:	68fb      	ldr	r3, [r7, #12]
 80021ba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80021bc:	1c5a      	adds	r2, r3, #1
 80021be:	68fb      	ldr	r3, [r7, #12]
 80021c0:	641a      	str	r2, [r3, #64]	; 0x40
        hospi->XferCount--;
 80021c2:	68fb      	ldr	r3, [r7, #12]
 80021c4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80021c6:	1e5a      	subs	r2, r3, #1
 80021c8:	68fb      	ldr	r3, [r7, #12]
 80021ca:	649a      	str	r2, [r3, #72]	; 0x48
      } while (hospi->XferCount > 0U);
 80021cc:	68fb      	ldr	r3, [r7, #12]
 80021ce:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80021d0:	2b00      	cmp	r3, #0
 80021d2:	d1dc      	bne.n	800218e <HAL_OSPI_Receive+0xae>
 80021d4:	e000      	b.n	80021d8 <HAL_OSPI_Receive+0xf8>
          break;
 80021d6:	bf00      	nop

      if (status == HAL_OK)
 80021d8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80021dc:	2b00      	cmp	r3, #0
 80021de:	d11c      	bne.n	800221a <HAL_OSPI_Receive+0x13a>
      {
        /* Wait till transfer complete flag is set to go back in idle state */
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, Timeout);
 80021e0:	687b      	ldr	r3, [r7, #4]
 80021e2:	9300      	str	r3, [sp, #0]
 80021e4:	6a3b      	ldr	r3, [r7, #32]
 80021e6:	2201      	movs	r2, #1
 80021e8:	2102      	movs	r1, #2
 80021ea:	68f8      	ldr	r0, [r7, #12]
 80021ec:	f000 fe1e 	bl	8002e2c <OSPI_WaitFlagStateUntilTimeout>
 80021f0:	4603      	mov	r3, r0
 80021f2:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

        if (status == HAL_OK)
 80021f6:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80021fa:	2b00      	cmp	r3, #0
 80021fc:	d10d      	bne.n	800221a <HAL_OSPI_Receive+0x13a>
        {
          /* Clear transfer complete flag */
          __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 80021fe:	68fb      	ldr	r3, [r7, #12]
 8002200:	681b      	ldr	r3, [r3, #0]
 8002202:	2202      	movs	r2, #2
 8002204:	625a      	str	r2, [r3, #36]	; 0x24

          /* Update state */
          hospi->State = HAL_OSPI_STATE_READY;
 8002206:	68fb      	ldr	r3, [r7, #12]
 8002208:	2202      	movs	r2, #2
 800220a:	651a      	str	r2, [r3, #80]	; 0x50
 800220c:	e005      	b.n	800221a <HAL_OSPI_Receive+0x13a>
        }
      }
    }
    else
    {
      status = HAL_ERROR;
 800220e:	2301      	movs	r3, #1
 8002210:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 8002214:	68fb      	ldr	r3, [r7, #12]
 8002216:	2210      	movs	r2, #16
 8002218:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }

  /* Return function status */
  return status;
 800221a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 800221e:	4618      	mov	r0, r3
 8002220:	3728      	adds	r7, #40	; 0x28
 8002222:	46bd      	mov	sp, r7
 8002224:	bd80      	pop	{r7, pc}

08002226 <HAL_OSPI_ErrorCallback>:
  * @brief  Transfer Error callback.
  * @param  hospi : OSPI handle
  * @retval None
  */
__weak void HAL_OSPI_ErrorCallback(OSPI_HandleTypeDef *hospi)
{
 8002226:	b480      	push	{r7}
 8002228:	b083      	sub	sp, #12
 800222a:	af00      	add	r7, sp, #0
 800222c:	6078      	str	r0, [r7, #4]
  UNUSED(hospi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_OSPI_ErrorCallback could be implemented in the user file
   */
}
 800222e:	bf00      	nop
 8002230:	370c      	adds	r7, #12
 8002232:	46bd      	mov	sp, r7
 8002234:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002238:	4770      	bx	lr

0800223a <HAL_OSPI_AbortCpltCallback>:
  * @brief  Abort completed callback.
  * @param  hospi : OSPI handle
  * @retval None
  */
__weak void HAL_OSPI_AbortCpltCallback(OSPI_HandleTypeDef *hospi)
{
 800223a:	b480      	push	{r7}
 800223c:	b083      	sub	sp, #12
 800223e:	af00      	add	r7, sp, #0
 8002240:	6078      	str	r0, [r7, #4]
  UNUSED(hospi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_OSPI_AbortCpltCallback could be implemented in the user file
   */
}
 8002242:	bf00      	nop
 8002244:	370c      	adds	r7, #12
 8002246:	46bd      	mov	sp, r7
 8002248:	f85d 7b04 	ldr.w	r7, [sp], #4
 800224c:	4770      	bx	lr

0800224e <HAL_OSPI_FifoThresholdCallback>:
  * @brief  FIFO Threshold callback.
  * @param  hospi : OSPI handle
  * @retval None
  */
__weak void HAL_OSPI_FifoThresholdCallback(OSPI_HandleTypeDef *hospi)
{
 800224e:	b480      	push	{r7}
 8002250:	b083      	sub	sp, #12
 8002252:	af00      	add	r7, sp, #0
 8002254:	6078      	str	r0, [r7, #4]
  UNUSED(hospi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_OSPI_FIFOThresholdCallback could be implemented in the user file
   */
}
 8002256:	bf00      	nop
 8002258:	370c      	adds	r7, #12
 800225a:	46bd      	mov	sp, r7
 800225c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002260:	4770      	bx	lr

08002262 <HAL_OSPI_CmdCpltCallback>:
  * @brief  Command completed callback.
  * @param  hospi : OSPI handle
  * @retval None
  */
__weak void HAL_OSPI_CmdCpltCallback(OSPI_HandleTypeDef *hospi)
{
 8002262:	b480      	push	{r7}
 8002264:	b083      	sub	sp, #12
 8002266:	af00      	add	r7, sp, #0
 8002268:	6078      	str	r0, [r7, #4]
  UNUSED(hospi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_OSPI_CmdCpltCallback could be implemented in the user file
   */
}
 800226a:	bf00      	nop
 800226c:	370c      	adds	r7, #12
 800226e:	46bd      	mov	sp, r7
 8002270:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002274:	4770      	bx	lr

08002276 <HAL_OSPI_RxCpltCallback>:
  * @brief  Rx Transfer completed callback.
  * @param  hospi : OSPI handle
  * @retval None
  */
__weak void HAL_OSPI_RxCpltCallback(OSPI_HandleTypeDef *hospi)
{
 8002276:	b480      	push	{r7}
 8002278:	b083      	sub	sp, #12
 800227a:	af00      	add	r7, sp, #0
 800227c:	6078      	str	r0, [r7, #4]
  UNUSED(hospi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_OSPI_RxCpltCallback could be implemented in the user file
   */
}
 800227e:	bf00      	nop
 8002280:	370c      	adds	r7, #12
 8002282:	46bd      	mov	sp, r7
 8002284:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002288:	4770      	bx	lr

0800228a <HAL_OSPI_TxCpltCallback>:
  * @brief  Tx Transfer completed callback.
  * @param  hospi : OSPI handle
  * @retval None
  */
__weak void HAL_OSPI_TxCpltCallback(OSPI_HandleTypeDef *hospi)
{
 800228a:	b480      	push	{r7}
 800228c:	b083      	sub	sp, #12
 800228e:	af00      	add	r7, sp, #0
 8002290:	6078      	str	r0, [r7, #4]
  UNUSED(hospi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_OSPI_TxCpltCallback could be implemented in the user file
   */
}
 8002292:	bf00      	nop
 8002294:	370c      	adds	r7, #12
 8002296:	46bd      	mov	sp, r7
 8002298:	f85d 7b04 	ldr.w	r7, [sp], #4
 800229c:	4770      	bx	lr

0800229e <HAL_OSPI_StatusMatchCallback>:
  * @brief  Status Match callback.
  * @param  hospi : OSPI handle
  * @retval None
  */
__weak void HAL_OSPI_StatusMatchCallback(OSPI_HandleTypeDef *hospi)
{
 800229e:	b480      	push	{r7}
 80022a0:	b083      	sub	sp, #12
 80022a2:	af00      	add	r7, sp, #0
 80022a4:	6078      	str	r0, [r7, #4]
  UNUSED(hospi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_OSPI_StatusMatchCallback could be implemented in the user file
   */
}
 80022a6:	bf00      	nop
 80022a8:	370c      	adds	r7, #12
 80022aa:	46bd      	mov	sp, r7
 80022ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80022b0:	4770      	bx	lr

080022b2 <HAL_OSPI_TimeOutCallback>:
  * @brief  Timeout callback.
  * @param  hospi : OSPI handle
  * @retval None
  */
__weak void HAL_OSPI_TimeOutCallback(OSPI_HandleTypeDef *hospi)
{
 80022b2:	b480      	push	{r7}
 80022b4:	b083      	sub	sp, #12
 80022b6:	af00      	add	r7, sp, #0
 80022b8:	6078      	str	r0, [r7, #4]
  UNUSED(hospi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_OSPI_TimeOutCallback could be implemented in the user file
   */
}
 80022ba:	bf00      	nop
 80022bc:	370c      	adds	r7, #12
 80022be:	46bd      	mov	sp, r7
 80022c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80022c4:	4770      	bx	lr

080022c6 <HAL_OSPI_Abort>:
  * @brief  Abort the current transmission.
  * @param  hospi : OSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_Abort(OSPI_HandleTypeDef *hospi)
{
 80022c6:	b580      	push	{r7, lr}
 80022c8:	b088      	sub	sp, #32
 80022ca:	af02      	add	r7, sp, #8
 80022cc:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 80022ce:	2300      	movs	r3, #0
 80022d0:	75fb      	strb	r3, [r7, #23]
  uint32_t state;
  uint32_t tickstart = HAL_GetTick();
 80022d2:	f7fe fea1 	bl	8001018 <HAL_GetTick>
 80022d6:	6138      	str	r0, [r7, #16]

  /* Check if the state is in one of the busy or configured states */
  state = hospi->State;
 80022d8:	687b      	ldr	r3, [r7, #4]
 80022da:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80022dc:	60fb      	str	r3, [r7, #12]
  if (((state & OSPI_BUSY_STATE_MASK) != 0U) || ((state & OSPI_CFG_STATE_MASK) != 0U))
 80022de:	68fb      	ldr	r3, [r7, #12]
 80022e0:	f003 0308 	and.w	r3, r3, #8
 80022e4:	2b00      	cmp	r3, #0
 80022e6:	d104      	bne.n	80022f2 <HAL_OSPI_Abort+0x2c>
 80022e8:	68fb      	ldr	r3, [r7, #12]
 80022ea:	f003 0304 	and.w	r3, r3, #4
 80022ee:	2b00      	cmp	r3, #0
 80022f0:	d052      	beq.n	8002398 <HAL_OSPI_Abort+0xd2>
  {
    /* Check if the DMA is enabled */
    if ((hospi->Instance->CR & OCTOSPI_CR_DMAEN) != 0U)
 80022f2:	687b      	ldr	r3, [r7, #4]
 80022f4:	681b      	ldr	r3, [r3, #0]
 80022f6:	681b      	ldr	r3, [r3, #0]
 80022f8:	f003 0304 	and.w	r3, r3, #4
 80022fc:	2b00      	cmp	r3, #0
 80022fe:	d014      	beq.n	800232a <HAL_OSPI_Abort+0x64>
    {
      /* Disable the DMA transfer on the OctoSPI side */
      CLEAR_BIT(hospi->Instance->CR, OCTOSPI_CR_DMAEN);
 8002300:	687b      	ldr	r3, [r7, #4]
 8002302:	681b      	ldr	r3, [r3, #0]
 8002304:	681a      	ldr	r2, [r3, #0]
 8002306:	687b      	ldr	r3, [r7, #4]
 8002308:	681b      	ldr	r3, [r3, #0]
 800230a:	f022 0204 	bic.w	r2, r2, #4
 800230e:	601a      	str	r2, [r3, #0]

      /* Disable the DMA transfer on the DMA side */
      status = HAL_DMA_Abort(hospi->hdma);
 8002310:	687b      	ldr	r3, [r7, #4]
 8002312:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8002314:	4618      	mov	r0, r3
 8002316:	f7fe fff0 	bl	80012fa <HAL_DMA_Abort>
 800231a:	4603      	mov	r3, r0
 800231c:	75fb      	strb	r3, [r7, #23]
      if (status != HAL_OK)
 800231e:	7dfb      	ldrb	r3, [r7, #23]
 8002320:	2b00      	cmp	r3, #0
 8002322:	d002      	beq.n	800232a <HAL_OSPI_Abort+0x64>
      {
        hospi->ErrorCode = HAL_OSPI_ERROR_DMA;
 8002324:	687b      	ldr	r3, [r7, #4]
 8002326:	2204      	movs	r2, #4
 8002328:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }

    if (__HAL_OSPI_GET_FLAG(hospi, HAL_OSPI_FLAG_BUSY) != RESET)
 800232a:	687b      	ldr	r3, [r7, #4]
 800232c:	681b      	ldr	r3, [r3, #0]
 800232e:	6a1b      	ldr	r3, [r3, #32]
 8002330:	f003 0320 	and.w	r3, r3, #32
 8002334:	2b00      	cmp	r3, #0
 8002336:	d02b      	beq.n	8002390 <HAL_OSPI_Abort+0xca>
    {
      /* Perform an abort of the OctoSPI */
      SET_BIT(hospi->Instance->CR, OCTOSPI_CR_ABORT);
 8002338:	687b      	ldr	r3, [r7, #4]
 800233a:	681b      	ldr	r3, [r3, #0]
 800233c:	681a      	ldr	r2, [r3, #0]
 800233e:	687b      	ldr	r3, [r7, #4]
 8002340:	681b      	ldr	r3, [r3, #0]
 8002342:	f042 0202 	orr.w	r2, r2, #2
 8002346:	601a      	str	r2, [r3, #0]

      /* Wait until the transfer complete flag is set to go back in idle state */
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, hospi->Timeout);
 8002348:	687b      	ldr	r3, [r7, #4]
 800234a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800234c:	9300      	str	r3, [sp, #0]
 800234e:	693b      	ldr	r3, [r7, #16]
 8002350:	2201      	movs	r2, #1
 8002352:	2102      	movs	r1, #2
 8002354:	6878      	ldr	r0, [r7, #4]
 8002356:	f000 fd69 	bl	8002e2c <OSPI_WaitFlagStateUntilTimeout>
 800235a:	4603      	mov	r3, r0
 800235c:	75fb      	strb	r3, [r7, #23]

      if (status == HAL_OK)
 800235e:	7dfb      	ldrb	r3, [r7, #23]
 8002360:	2b00      	cmp	r3, #0
 8002362:	d11f      	bne.n	80023a4 <HAL_OSPI_Abort+0xde>
      {
        /* Clear transfer complete flag */
        __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 8002364:	687b      	ldr	r3, [r7, #4]
 8002366:	681b      	ldr	r3, [r3, #0]
 8002368:	2202      	movs	r2, #2
 800236a:	625a      	str	r2, [r3, #36]	; 0x24

        /* Wait until the busy flag is reset to go back in idle state */
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 800236c:	687b      	ldr	r3, [r7, #4]
 800236e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8002370:	9300      	str	r3, [sp, #0]
 8002372:	693b      	ldr	r3, [r7, #16]
 8002374:	2200      	movs	r2, #0
 8002376:	2120      	movs	r1, #32
 8002378:	6878      	ldr	r0, [r7, #4]
 800237a:	f000 fd57 	bl	8002e2c <OSPI_WaitFlagStateUntilTimeout>
 800237e:	4603      	mov	r3, r0
 8002380:	75fb      	strb	r3, [r7, #23]

        if (status == HAL_OK)
 8002382:	7dfb      	ldrb	r3, [r7, #23]
 8002384:	2b00      	cmp	r3, #0
 8002386:	d10d      	bne.n	80023a4 <HAL_OSPI_Abort+0xde>
        {
          /* Update state */
          hospi->State = HAL_OSPI_STATE_READY;
 8002388:	687b      	ldr	r3, [r7, #4]
 800238a:	2202      	movs	r2, #2
 800238c:	651a      	str	r2, [r3, #80]	; 0x50
    if (__HAL_OSPI_GET_FLAG(hospi, HAL_OSPI_FLAG_BUSY) != RESET)
 800238e:	e009      	b.n	80023a4 <HAL_OSPI_Abort+0xde>
      }
    }
    else
    {
      /* Update state */
      hospi->State = HAL_OSPI_STATE_READY;
 8002390:	687b      	ldr	r3, [r7, #4]
 8002392:	2202      	movs	r2, #2
 8002394:	651a      	str	r2, [r3, #80]	; 0x50
    if (__HAL_OSPI_GET_FLAG(hospi, HAL_OSPI_FLAG_BUSY) != RESET)
 8002396:	e005      	b.n	80023a4 <HAL_OSPI_Abort+0xde>
    }
  }
  else
  {
    status = HAL_ERROR;
 8002398:	2301      	movs	r3, #1
 800239a:	75fb      	strb	r3, [r7, #23]
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 800239c:	687b      	ldr	r3, [r7, #4]
 800239e:	2210      	movs	r2, #16
 80023a0:	655a      	str	r2, [r3, #84]	; 0x54
 80023a2:	e000      	b.n	80023a6 <HAL_OSPI_Abort+0xe0>
    if (__HAL_OSPI_GET_FLAG(hospi, HAL_OSPI_FLAG_BUSY) != RESET)
 80023a4:	bf00      	nop
  }

  /* Return function status */
  return status;
 80023a6:	7dfb      	ldrb	r3, [r7, #23]
}
 80023a8:	4618      	mov	r0, r3
 80023aa:	3718      	adds	r7, #24
 80023ac:	46bd      	mov	sp, r7
 80023ae:	bd80      	pop	{r7, pc}

080023b0 <HAL_OSPI_SetTimeout>:
  * @param  hospi   : OSPI handle.
  * @param  Timeout : Timeout for the memory access.
  * @retval None
  */
HAL_StatusTypeDef HAL_OSPI_SetTimeout(OSPI_HandleTypeDef *hospi, uint32_t Timeout)
{
 80023b0:	b480      	push	{r7}
 80023b2:	b083      	sub	sp, #12
 80023b4:	af00      	add	r7, sp, #0
 80023b6:	6078      	str	r0, [r7, #4]
 80023b8:	6039      	str	r1, [r7, #0]
  hospi->Timeout = Timeout;
 80023ba:	687b      	ldr	r3, [r7, #4]
 80023bc:	683a      	ldr	r2, [r7, #0]
 80023be:	659a      	str	r2, [r3, #88]	; 0x58
  return HAL_OK;
 80023c0:	2300      	movs	r3, #0
}
 80023c2:	4618      	mov	r0, r3
 80023c4:	370c      	adds	r7, #12
 80023c6:	46bd      	mov	sp, r7
 80023c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80023cc:	4770      	bx	lr
	...

080023d0 <HAL_OSPIM_Config>:
  * @param  cfg     : Configuration of the IO Manager for the instance
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPIM_Config(OSPI_HandleTypeDef *hospi, OSPIM_CfgTypeDef *cfg, uint32_t Timeout)
{
 80023d0:	b580      	push	{r7, lr}
 80023d2:	b094      	sub	sp, #80	; 0x50
 80023d4:	af00      	add	r7, sp, #0
 80023d6:	60f8      	str	r0, [r7, #12]
 80023d8:	60b9      	str	r1, [r7, #8]
 80023da:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 80023dc:	2300      	movs	r3, #0
 80023de:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
  uint32_t instance;
  uint8_t index;
  uint8_t ospi_enabled = 0U;
 80023e2:	2300      	movs	r3, #0
 80023e4:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
  assert_param(IS_OSPIM_DQS_PORT(cfg->DQSPort));
  assert_param(IS_OSPIM_PORT(cfg->NCSPort));
  assert_param(IS_OSPIM_IO_PORT(cfg->IOLowPort));
  assert_param(IS_OSPIM_IO_PORT(cfg->IOHighPort));

  if (hospi->Instance == (OCTOSPI_TypeDef *)OCTOSPI1)
 80023e8:	68fb      	ldr	r3, [r7, #12]
 80023ea:	681b      	ldr	r3, [r3, #0]
 80023ec:	4a9d      	ldr	r2, [pc, #628]	; (8002664 <HAL_OSPIM_Config+0x294>)
 80023ee:	4293      	cmp	r3, r2
 80023f0:	d105      	bne.n	80023fe <HAL_OSPIM_Config+0x2e>
  {
    instance = 0U;
 80023f2:	2300      	movs	r3, #0
 80023f4:	64bb      	str	r3, [r7, #72]	; 0x48
    other_instance = 1U;
 80023f6:	2301      	movs	r3, #1
 80023f8:	f887 3045 	strb.w	r3, [r7, #69]	; 0x45
 80023fc:	e004      	b.n	8002408 <HAL_OSPIM_Config+0x38>
  }
  else
  {
    instance = 1U;
 80023fe:	2301      	movs	r3, #1
 8002400:	64bb      	str	r3, [r7, #72]	; 0x48
    other_instance = 0U;
 8002402:	2300      	movs	r3, #0
 8002404:	f887 3045 	strb.w	r3, [r7, #69]	; 0x45
  }

  /**************** Get current configuration of the instances ****************/
  for (index = 0U; index < OSPI_NB_INSTANCE; index++)
 8002408:	2300      	movs	r3, #0
 800240a:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 800240e:	e01d      	b.n	800244c <HAL_OSPIM_Config+0x7c>
  {
    if (OSPIM_GetConfig(index + 1U, &(IOM_cfg[index])) != HAL_OK)
 8002410:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8002414:	3301      	adds	r3, #1
 8002416:	b2d8      	uxtb	r0, r3
 8002418:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 800241c:	f107 0114 	add.w	r1, r7, #20
 8002420:	4613      	mov	r3, r2
 8002422:	005b      	lsls	r3, r3, #1
 8002424:	4413      	add	r3, r2
 8002426:	00db      	lsls	r3, r3, #3
 8002428:	440b      	add	r3, r1
 800242a:	4619      	mov	r1, r3
 800242c:	f000 feb8 	bl	80031a0 <OSPIM_GetConfig>
 8002430:	4603      	mov	r3, r0
 8002432:	2b00      	cmp	r3, #0
 8002434:	d005      	beq.n	8002442 <HAL_OSPIM_Config+0x72>
    {
      status = HAL_ERROR;
 8002436:	2301      	movs	r3, #1
 8002438:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
 800243c:	68fb      	ldr	r3, [r7, #12]
 800243e:	2208      	movs	r2, #8
 8002440:	655a      	str	r2, [r3, #84]	; 0x54
  for (index = 0U; index < OSPI_NB_INSTANCE; index++)
 8002442:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8002446:	3301      	adds	r3, #1
 8002448:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 800244c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8002450:	2b01      	cmp	r3, #1
 8002452:	d9dd      	bls.n	8002410 <HAL_OSPIM_Config+0x40>
    }
  }

  if (status == HAL_OK)
 8002454:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8002458:	2b00      	cmp	r3, #0
 800245a:	f040 849e 	bne.w	8002d9a <HAL_OSPIM_Config+0x9ca>
  {
    /********** Disable both OctoSPI to configure OctoSPI IO Manager **********/
    if ((OCTOSPI1->CR & OCTOSPI_CR_EN) != 0U)
 800245e:	4b81      	ldr	r3, [pc, #516]	; (8002664 <HAL_OSPIM_Config+0x294>)
 8002460:	681b      	ldr	r3, [r3, #0]
 8002462:	f003 0301 	and.w	r3, r3, #1
 8002466:	2b00      	cmp	r3, #0
 8002468:	d00b      	beq.n	8002482 <HAL_OSPIM_Config+0xb2>
    {
      CLEAR_BIT(OCTOSPI1->CR, OCTOSPI_CR_EN);
 800246a:	4b7e      	ldr	r3, [pc, #504]	; (8002664 <HAL_OSPIM_Config+0x294>)
 800246c:	681b      	ldr	r3, [r3, #0]
 800246e:	4a7d      	ldr	r2, [pc, #500]	; (8002664 <HAL_OSPIM_Config+0x294>)
 8002470:	f023 0301 	bic.w	r3, r3, #1
 8002474:	6013      	str	r3, [r2, #0]
      ospi_enabled |= 0x1U;
 8002476:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 800247a:	f043 0301 	orr.w	r3, r3, #1
 800247e:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
    }
    if ((OCTOSPI2->CR & OCTOSPI_CR_EN) != 0U)
 8002482:	4b79      	ldr	r3, [pc, #484]	; (8002668 <HAL_OSPIM_Config+0x298>)
 8002484:	681b      	ldr	r3, [r3, #0]
 8002486:	f003 0301 	and.w	r3, r3, #1
 800248a:	2b00      	cmp	r3, #0
 800248c:	d00b      	beq.n	80024a6 <HAL_OSPIM_Config+0xd6>
    {
      CLEAR_BIT(OCTOSPI2->CR, OCTOSPI_CR_EN);
 800248e:	4b76      	ldr	r3, [pc, #472]	; (8002668 <HAL_OSPIM_Config+0x298>)
 8002490:	681b      	ldr	r3, [r3, #0]
 8002492:	4a75      	ldr	r2, [pc, #468]	; (8002668 <HAL_OSPIM_Config+0x298>)
 8002494:	f023 0301 	bic.w	r3, r3, #1
 8002498:	6013      	str	r3, [r2, #0]
      ospi_enabled |= 0x2U;
 800249a:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 800249e:	f043 0302 	orr.w	r3, r3, #2
 80024a2:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
    }

    /***************** Deactivation of previous configuration *****************/
    CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].NCSPort - 1U)], OCTOSPIM_PCR_NCSEN);
 80024a6:	4971      	ldr	r1, [pc, #452]	; (800266c <HAL_OSPIM_Config+0x29c>)
 80024a8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80024aa:	4613      	mov	r3, r2
 80024ac:	005b      	lsls	r3, r3, #1
 80024ae:	4413      	add	r3, r2
 80024b0:	00db      	lsls	r3, r3, #3
 80024b2:	3350      	adds	r3, #80	; 0x50
 80024b4:	443b      	add	r3, r7
 80024b6:	3b34      	subs	r3, #52	; 0x34
 80024b8:	681b      	ldr	r3, [r3, #0]
 80024ba:	3b01      	subs	r3, #1
 80024bc:	009b      	lsls	r3, r3, #2
 80024be:	440b      	add	r3, r1
 80024c0:	6859      	ldr	r1, [r3, #4]
 80024c2:	486a      	ldr	r0, [pc, #424]	; (800266c <HAL_OSPIM_Config+0x29c>)
 80024c4:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80024c6:	4613      	mov	r3, r2
 80024c8:	005b      	lsls	r3, r3, #1
 80024ca:	4413      	add	r3, r2
 80024cc:	00db      	lsls	r3, r3, #3
 80024ce:	3350      	adds	r3, #80	; 0x50
 80024d0:	443b      	add	r3, r7
 80024d2:	3b34      	subs	r3, #52	; 0x34
 80024d4:	681b      	ldr	r3, [r3, #0]
 80024d6:	3b01      	subs	r3, #1
 80024d8:	f421 7280 	bic.w	r2, r1, #256	; 0x100
 80024dc:	009b      	lsls	r3, r3, #2
 80024de:	4403      	add	r3, r0
 80024e0:	605a      	str	r2, [r3, #4]
    if ((OCTOSPIM->CR & OCTOSPIM_CR_MUXEN) != 0U)
 80024e2:	4b62      	ldr	r3, [pc, #392]	; (800266c <HAL_OSPIM_Config+0x29c>)
 80024e4:	681b      	ldr	r3, [r3, #0]
 80024e6:	f003 0301 	and.w	r3, r3, #1
 80024ea:	2b00      	cmp	r3, #0
 80024ec:	f000 80c0 	beq.w	8002670 <HAL_OSPIM_Config+0x2a0>
    {
      /* De-multiplexing should be performed */
      CLEAR_BIT(OCTOSPIM->CR, OCTOSPIM_CR_MUXEN);
 80024f0:	4b5e      	ldr	r3, [pc, #376]	; (800266c <HAL_OSPIM_Config+0x29c>)
 80024f2:	681b      	ldr	r3, [r3, #0]
 80024f4:	4a5d      	ldr	r2, [pc, #372]	; (800266c <HAL_OSPIM_Config+0x29c>)
 80024f6:	f023 0301 	bic.w	r3, r3, #1
 80024fa:	6013      	str	r3, [r2, #0]

      if (other_instance == 1U)
 80024fc:	f897 3045 	ldrb.w	r3, [r7, #69]	; 0x45
 8002500:	2b01      	cmp	r3, #1
 8002502:	f040 8162 	bne.w	80027ca <HAL_OSPIM_Config+0x3fa>
      {
        SET_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].ClkPort - 1U)], OCTOSPIM_PCR_CLKSRC);
 8002506:	4959      	ldr	r1, [pc, #356]	; (800266c <HAL_OSPIM_Config+0x29c>)
 8002508:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 800250c:	4613      	mov	r3, r2
 800250e:	005b      	lsls	r3, r3, #1
 8002510:	4413      	add	r3, r2
 8002512:	00db      	lsls	r3, r3, #3
 8002514:	3350      	adds	r3, #80	; 0x50
 8002516:	443b      	add	r3, r7
 8002518:	3b3c      	subs	r3, #60	; 0x3c
 800251a:	681b      	ldr	r3, [r3, #0]
 800251c:	3b01      	subs	r3, #1
 800251e:	009b      	lsls	r3, r3, #2
 8002520:	440b      	add	r3, r1
 8002522:	6859      	ldr	r1, [r3, #4]
 8002524:	4851      	ldr	r0, [pc, #324]	; (800266c <HAL_OSPIM_Config+0x29c>)
 8002526:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 800252a:	4613      	mov	r3, r2
 800252c:	005b      	lsls	r3, r3, #1
 800252e:	4413      	add	r3, r2
 8002530:	00db      	lsls	r3, r3, #3
 8002532:	3350      	adds	r3, #80	; 0x50
 8002534:	443b      	add	r3, r7
 8002536:	3b3c      	subs	r3, #60	; 0x3c
 8002538:	681b      	ldr	r3, [r3, #0]
 800253a:	3b01      	subs	r3, #1
 800253c:	f041 0202 	orr.w	r2, r1, #2
 8002540:	009b      	lsls	r3, r3, #2
 8002542:	4403      	add	r3, r0
 8002544:	605a      	str	r2, [r3, #4]
        if (IOM_cfg[other_instance].DQSPort != 0U)
 8002546:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 800254a:	4613      	mov	r3, r2
 800254c:	005b      	lsls	r3, r3, #1
 800254e:	4413      	add	r3, r2
 8002550:	00db      	lsls	r3, r3, #3
 8002552:	3350      	adds	r3, #80	; 0x50
 8002554:	443b      	add	r3, r7
 8002556:	3b38      	subs	r3, #56	; 0x38
 8002558:	681b      	ldr	r3, [r3, #0]
 800255a:	2b00      	cmp	r3, #0
 800255c:	d01f      	beq.n	800259e <HAL_OSPIM_Config+0x1ce>
        {
          SET_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].DQSPort - 1U)], OCTOSPIM_PCR_DQSSRC);
 800255e:	4943      	ldr	r1, [pc, #268]	; (800266c <HAL_OSPIM_Config+0x29c>)
 8002560:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 8002564:	4613      	mov	r3, r2
 8002566:	005b      	lsls	r3, r3, #1
 8002568:	4413      	add	r3, r2
 800256a:	00db      	lsls	r3, r3, #3
 800256c:	3350      	adds	r3, #80	; 0x50
 800256e:	443b      	add	r3, r7
 8002570:	3b38      	subs	r3, #56	; 0x38
 8002572:	681b      	ldr	r3, [r3, #0]
 8002574:	3b01      	subs	r3, #1
 8002576:	009b      	lsls	r3, r3, #2
 8002578:	440b      	add	r3, r1
 800257a:	6859      	ldr	r1, [r3, #4]
 800257c:	483b      	ldr	r0, [pc, #236]	; (800266c <HAL_OSPIM_Config+0x29c>)
 800257e:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 8002582:	4613      	mov	r3, r2
 8002584:	005b      	lsls	r3, r3, #1
 8002586:	4413      	add	r3, r2
 8002588:	00db      	lsls	r3, r3, #3
 800258a:	3350      	adds	r3, #80	; 0x50
 800258c:	443b      	add	r3, r7
 800258e:	3b38      	subs	r3, #56	; 0x38
 8002590:	681b      	ldr	r3, [r3, #0]
 8002592:	3b01      	subs	r3, #1
 8002594:	f041 0220 	orr.w	r2, r1, #32
 8002598:	009b      	lsls	r3, r3, #2
 800259a:	4403      	add	r3, r0
 800259c:	605a      	str	r2, [r3, #4]
        }
        if (IOM_cfg[other_instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
 800259e:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 80025a2:	4613      	mov	r3, r2
 80025a4:	005b      	lsls	r3, r3, #1
 80025a6:	4413      	add	r3, r2
 80025a8:	00db      	lsls	r3, r3, #3
 80025aa:	3350      	adds	r3, #80	; 0x50
 80025ac:	443b      	add	r3, r7
 80025ae:	3b30      	subs	r3, #48	; 0x30
 80025b0:	681b      	ldr	r3, [r3, #0]
 80025b2:	2b00      	cmp	r3, #0
 80025b4:	d023      	beq.n	80025fe <HAL_OSPIM_Config+0x22e>
        {
          SET_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOLowPort - 1U)& OSPI_IOM_PORT_MASK)], \
 80025b6:	492d      	ldr	r1, [pc, #180]	; (800266c <HAL_OSPIM_Config+0x29c>)
 80025b8:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 80025bc:	4613      	mov	r3, r2
 80025be:	005b      	lsls	r3, r3, #1
 80025c0:	4413      	add	r3, r2
 80025c2:	00db      	lsls	r3, r3, #3
 80025c4:	3350      	adds	r3, #80	; 0x50
 80025c6:	443b      	add	r3, r7
 80025c8:	3b30      	subs	r3, #48	; 0x30
 80025ca:	681b      	ldr	r3, [r3, #0]
 80025cc:	3b01      	subs	r3, #1
 80025ce:	f003 0301 	and.w	r3, r3, #1
 80025d2:	009b      	lsls	r3, r3, #2
 80025d4:	440b      	add	r3, r1
 80025d6:	6859      	ldr	r1, [r3, #4]
 80025d8:	4824      	ldr	r0, [pc, #144]	; (800266c <HAL_OSPIM_Config+0x29c>)
 80025da:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 80025de:	4613      	mov	r3, r2
 80025e0:	005b      	lsls	r3, r3, #1
 80025e2:	4413      	add	r3, r2
 80025e4:	00db      	lsls	r3, r3, #3
 80025e6:	3350      	adds	r3, #80	; 0x50
 80025e8:	443b      	add	r3, r7
 80025ea:	3b30      	subs	r3, #48	; 0x30
 80025ec:	681b      	ldr	r3, [r3, #0]
 80025ee:	3b01      	subs	r3, #1
 80025f0:	f003 0301 	and.w	r3, r3, #1
 80025f4:	f441 2280 	orr.w	r2, r1, #262144	; 0x40000
 80025f8:	009b      	lsls	r3, r3, #2
 80025fa:	4403      	add	r3, r0
 80025fc:	605a      	str	r2, [r3, #4]
                  OCTOSPIM_PCR_IOLSRC_1);
        }
        if (IOM_cfg[other_instance].IOHighPort != HAL_OSPIM_IOPORT_NONE)
 80025fe:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 8002602:	4613      	mov	r3, r2
 8002604:	005b      	lsls	r3, r3, #1
 8002606:	4413      	add	r3, r2
 8002608:	00db      	lsls	r3, r3, #3
 800260a:	3350      	adds	r3, #80	; 0x50
 800260c:	443b      	add	r3, r7
 800260e:	3b2c      	subs	r3, #44	; 0x2c
 8002610:	681b      	ldr	r3, [r3, #0]
 8002612:	2b00      	cmp	r3, #0
 8002614:	f000 80d9 	beq.w	80027ca <HAL_OSPIM_Config+0x3fa>
        {
          SET_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOHighPort - 1U)& OSPI_IOM_PORT_MASK)], \
 8002618:	4914      	ldr	r1, [pc, #80]	; (800266c <HAL_OSPIM_Config+0x29c>)
 800261a:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 800261e:	4613      	mov	r3, r2
 8002620:	005b      	lsls	r3, r3, #1
 8002622:	4413      	add	r3, r2
 8002624:	00db      	lsls	r3, r3, #3
 8002626:	3350      	adds	r3, #80	; 0x50
 8002628:	443b      	add	r3, r7
 800262a:	3b2c      	subs	r3, #44	; 0x2c
 800262c:	681b      	ldr	r3, [r3, #0]
 800262e:	3b01      	subs	r3, #1
 8002630:	f003 0301 	and.w	r3, r3, #1
 8002634:	009b      	lsls	r3, r3, #2
 8002636:	440b      	add	r3, r1
 8002638:	6859      	ldr	r1, [r3, #4]
 800263a:	480c      	ldr	r0, [pc, #48]	; (800266c <HAL_OSPIM_Config+0x29c>)
 800263c:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 8002640:	4613      	mov	r3, r2
 8002642:	005b      	lsls	r3, r3, #1
 8002644:	4413      	add	r3, r2
 8002646:	00db      	lsls	r3, r3, #3
 8002648:	3350      	adds	r3, #80	; 0x50
 800264a:	443b      	add	r3, r7
 800264c:	3b2c      	subs	r3, #44	; 0x2c
 800264e:	681b      	ldr	r3, [r3, #0]
 8002650:	3b01      	subs	r3, #1
 8002652:	f003 0301 	and.w	r3, r3, #1
 8002656:	f041 6280 	orr.w	r2, r1, #67108864	; 0x4000000
 800265a:	009b      	lsls	r3, r3, #2
 800265c:	4403      	add	r3, r0
 800265e:	605a      	str	r2, [r3, #4]
 8002660:	e0b3      	b.n	80027ca <HAL_OSPIM_Config+0x3fa>
 8002662:	bf00      	nop
 8002664:	420d1400 	.word	0x420d1400
 8002668:	420d2400 	.word	0x420d2400
 800266c:	420c4000 	.word	0x420c4000
        }
      }
    }
    else
    {
      if (IOM_cfg[instance].ClkPort != 0U)
 8002670:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8002672:	4613      	mov	r3, r2
 8002674:	005b      	lsls	r3, r3, #1
 8002676:	4413      	add	r3, r2
 8002678:	00db      	lsls	r3, r3, #3
 800267a:	3350      	adds	r3, #80	; 0x50
 800267c:	443b      	add	r3, r7
 800267e:	3b3c      	subs	r3, #60	; 0x3c
 8002680:	681b      	ldr	r3, [r3, #0]
 8002682:	2b00      	cmp	r3, #0
 8002684:	f000 80a1 	beq.w	80027ca <HAL_OSPIM_Config+0x3fa>
      {
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].ClkPort - 1U)], OCTOSPIM_PCR_CLKEN);
 8002688:	4993      	ldr	r1, [pc, #588]	; (80028d8 <HAL_OSPIM_Config+0x508>)
 800268a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800268c:	4613      	mov	r3, r2
 800268e:	005b      	lsls	r3, r3, #1
 8002690:	4413      	add	r3, r2
 8002692:	00db      	lsls	r3, r3, #3
 8002694:	3350      	adds	r3, #80	; 0x50
 8002696:	443b      	add	r3, r7
 8002698:	3b3c      	subs	r3, #60	; 0x3c
 800269a:	681b      	ldr	r3, [r3, #0]
 800269c:	3b01      	subs	r3, #1
 800269e:	009b      	lsls	r3, r3, #2
 80026a0:	440b      	add	r3, r1
 80026a2:	6859      	ldr	r1, [r3, #4]
 80026a4:	488c      	ldr	r0, [pc, #560]	; (80028d8 <HAL_OSPIM_Config+0x508>)
 80026a6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80026a8:	4613      	mov	r3, r2
 80026aa:	005b      	lsls	r3, r3, #1
 80026ac:	4413      	add	r3, r2
 80026ae:	00db      	lsls	r3, r3, #3
 80026b0:	3350      	adds	r3, #80	; 0x50
 80026b2:	443b      	add	r3, r7
 80026b4:	3b3c      	subs	r3, #60	; 0x3c
 80026b6:	681b      	ldr	r3, [r3, #0]
 80026b8:	3b01      	subs	r3, #1
 80026ba:	f021 0201 	bic.w	r2, r1, #1
 80026be:	009b      	lsls	r3, r3, #2
 80026c0:	4403      	add	r3, r0
 80026c2:	605a      	str	r2, [r3, #4]
        if (IOM_cfg[instance].DQSPort != 0U)
 80026c4:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80026c6:	4613      	mov	r3, r2
 80026c8:	005b      	lsls	r3, r3, #1
 80026ca:	4413      	add	r3, r2
 80026cc:	00db      	lsls	r3, r3, #3
 80026ce:	3350      	adds	r3, #80	; 0x50
 80026d0:	443b      	add	r3, r7
 80026d2:	3b38      	subs	r3, #56	; 0x38
 80026d4:	681b      	ldr	r3, [r3, #0]
 80026d6:	2b00      	cmp	r3, #0
 80026d8:	d01d      	beq.n	8002716 <HAL_OSPIM_Config+0x346>
        {
          CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].DQSPort - 1U)], OCTOSPIM_PCR_DQSEN);
 80026da:	497f      	ldr	r1, [pc, #508]	; (80028d8 <HAL_OSPIM_Config+0x508>)
 80026dc:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80026de:	4613      	mov	r3, r2
 80026e0:	005b      	lsls	r3, r3, #1
 80026e2:	4413      	add	r3, r2
 80026e4:	00db      	lsls	r3, r3, #3
 80026e6:	3350      	adds	r3, #80	; 0x50
 80026e8:	443b      	add	r3, r7
 80026ea:	3b38      	subs	r3, #56	; 0x38
 80026ec:	681b      	ldr	r3, [r3, #0]
 80026ee:	3b01      	subs	r3, #1
 80026f0:	009b      	lsls	r3, r3, #2
 80026f2:	440b      	add	r3, r1
 80026f4:	6859      	ldr	r1, [r3, #4]
 80026f6:	4878      	ldr	r0, [pc, #480]	; (80028d8 <HAL_OSPIM_Config+0x508>)
 80026f8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80026fa:	4613      	mov	r3, r2
 80026fc:	005b      	lsls	r3, r3, #1
 80026fe:	4413      	add	r3, r2
 8002700:	00db      	lsls	r3, r3, #3
 8002702:	3350      	adds	r3, #80	; 0x50
 8002704:	443b      	add	r3, r7
 8002706:	3b38      	subs	r3, #56	; 0x38
 8002708:	681b      	ldr	r3, [r3, #0]
 800270a:	3b01      	subs	r3, #1
 800270c:	f021 0210 	bic.w	r2, r1, #16
 8002710:	009b      	lsls	r3, r3, #2
 8002712:	4403      	add	r3, r0
 8002714:	605a      	str	r2, [r3, #4]
        }
        if (IOM_cfg[instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
 8002716:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8002718:	4613      	mov	r3, r2
 800271a:	005b      	lsls	r3, r3, #1
 800271c:	4413      	add	r3, r2
 800271e:	00db      	lsls	r3, r3, #3
 8002720:	3350      	adds	r3, #80	; 0x50
 8002722:	443b      	add	r3, r7
 8002724:	3b30      	subs	r3, #48	; 0x30
 8002726:	681b      	ldr	r3, [r3, #0]
 8002728:	2b00      	cmp	r3, #0
 800272a:	d021      	beq.n	8002770 <HAL_OSPIM_Config+0x3a0>
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[instance].IOLowPort - 1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOLEN);
 800272c:	496a      	ldr	r1, [pc, #424]	; (80028d8 <HAL_OSPIM_Config+0x508>)
 800272e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8002730:	4613      	mov	r3, r2
 8002732:	005b      	lsls	r3, r3, #1
 8002734:	4413      	add	r3, r2
 8002736:	00db      	lsls	r3, r3, #3
 8002738:	3350      	adds	r3, #80	; 0x50
 800273a:	443b      	add	r3, r7
 800273c:	3b30      	subs	r3, #48	; 0x30
 800273e:	681b      	ldr	r3, [r3, #0]
 8002740:	3b01      	subs	r3, #1
 8002742:	f003 0301 	and.w	r3, r3, #1
 8002746:	009b      	lsls	r3, r3, #2
 8002748:	440b      	add	r3, r1
 800274a:	6859      	ldr	r1, [r3, #4]
 800274c:	4862      	ldr	r0, [pc, #392]	; (80028d8 <HAL_OSPIM_Config+0x508>)
 800274e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8002750:	4613      	mov	r3, r2
 8002752:	005b      	lsls	r3, r3, #1
 8002754:	4413      	add	r3, r2
 8002756:	00db      	lsls	r3, r3, #3
 8002758:	3350      	adds	r3, #80	; 0x50
 800275a:	443b      	add	r3, r7
 800275c:	3b30      	subs	r3, #48	; 0x30
 800275e:	681b      	ldr	r3, [r3, #0]
 8002760:	3b01      	subs	r3, #1
 8002762:	f003 0301 	and.w	r3, r3, #1
 8002766:	f421 3280 	bic.w	r2, r1, #65536	; 0x10000
 800276a:	009b      	lsls	r3, r3, #2
 800276c:	4403      	add	r3, r0
 800276e:	605a      	str	r2, [r3, #4]
        }
        if (IOM_cfg[instance].IOHighPort != HAL_OSPIM_IOPORT_NONE)
 8002770:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8002772:	4613      	mov	r3, r2
 8002774:	005b      	lsls	r3, r3, #1
 8002776:	4413      	add	r3, r2
 8002778:	00db      	lsls	r3, r3, #3
 800277a:	3350      	adds	r3, #80	; 0x50
 800277c:	443b      	add	r3, r7
 800277e:	3b2c      	subs	r3, #44	; 0x2c
 8002780:	681b      	ldr	r3, [r3, #0]
 8002782:	2b00      	cmp	r3, #0
 8002784:	d021      	beq.n	80027ca <HAL_OSPIM_Config+0x3fa>
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[instance].IOHighPort - 1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOHEN);
 8002786:	4954      	ldr	r1, [pc, #336]	; (80028d8 <HAL_OSPIM_Config+0x508>)
 8002788:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800278a:	4613      	mov	r3, r2
 800278c:	005b      	lsls	r3, r3, #1
 800278e:	4413      	add	r3, r2
 8002790:	00db      	lsls	r3, r3, #3
 8002792:	3350      	adds	r3, #80	; 0x50
 8002794:	443b      	add	r3, r7
 8002796:	3b2c      	subs	r3, #44	; 0x2c
 8002798:	681b      	ldr	r3, [r3, #0]
 800279a:	3b01      	subs	r3, #1
 800279c:	f003 0301 	and.w	r3, r3, #1
 80027a0:	009b      	lsls	r3, r3, #2
 80027a2:	440b      	add	r3, r1
 80027a4:	6859      	ldr	r1, [r3, #4]
 80027a6:	484c      	ldr	r0, [pc, #304]	; (80028d8 <HAL_OSPIM_Config+0x508>)
 80027a8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80027aa:	4613      	mov	r3, r2
 80027ac:	005b      	lsls	r3, r3, #1
 80027ae:	4413      	add	r3, r2
 80027b0:	00db      	lsls	r3, r3, #3
 80027b2:	3350      	adds	r3, #80	; 0x50
 80027b4:	443b      	add	r3, r7
 80027b6:	3b2c      	subs	r3, #44	; 0x2c
 80027b8:	681b      	ldr	r3, [r3, #0]
 80027ba:	3b01      	subs	r3, #1
 80027bc:	f003 0301 	and.w	r3, r3, #1
 80027c0:	f021 7280 	bic.w	r2, r1, #16777216	; 0x1000000
 80027c4:	009b      	lsls	r3, r3, #2
 80027c6:	4403      	add	r3, r0
 80027c8:	605a      	str	r2, [r3, #4]
        }
      }
    }

    /********************* Deactivation of other instance *********************/
    if ((cfg->ClkPort == IOM_cfg[other_instance].ClkPort) || (cfg->DQSPort == IOM_cfg[other_instance].DQSPort)     ||
 80027ca:	68bb      	ldr	r3, [r7, #8]
 80027cc:	6819      	ldr	r1, [r3, #0]
 80027ce:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 80027d2:	4613      	mov	r3, r2
 80027d4:	005b      	lsls	r3, r3, #1
 80027d6:	4413      	add	r3, r2
 80027d8:	00db      	lsls	r3, r3, #3
 80027da:	3350      	adds	r3, #80	; 0x50
 80027dc:	443b      	add	r3, r7
 80027de:	3b3c      	subs	r3, #60	; 0x3c
 80027e0:	681b      	ldr	r3, [r3, #0]
 80027e2:	4299      	cmp	r1, r3
 80027e4:	d038      	beq.n	8002858 <HAL_OSPIM_Config+0x488>
 80027e6:	68bb      	ldr	r3, [r7, #8]
 80027e8:	6859      	ldr	r1, [r3, #4]
 80027ea:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 80027ee:	4613      	mov	r3, r2
 80027f0:	005b      	lsls	r3, r3, #1
 80027f2:	4413      	add	r3, r2
 80027f4:	00db      	lsls	r3, r3, #3
 80027f6:	3350      	adds	r3, #80	; 0x50
 80027f8:	443b      	add	r3, r7
 80027fa:	3b38      	subs	r3, #56	; 0x38
 80027fc:	681b      	ldr	r3, [r3, #0]
 80027fe:	4299      	cmp	r1, r3
 8002800:	d02a      	beq.n	8002858 <HAL_OSPIM_Config+0x488>
        (cfg->NCSPort == IOM_cfg[other_instance].NCSPort) || (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) ||
 8002802:	68bb      	ldr	r3, [r7, #8]
 8002804:	6899      	ldr	r1, [r3, #8]
 8002806:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 800280a:	4613      	mov	r3, r2
 800280c:	005b      	lsls	r3, r3, #1
 800280e:	4413      	add	r3, r2
 8002810:	00db      	lsls	r3, r3, #3
 8002812:	3350      	adds	r3, #80	; 0x50
 8002814:	443b      	add	r3, r7
 8002816:	3b34      	subs	r3, #52	; 0x34
 8002818:	681b      	ldr	r3, [r3, #0]
    if ((cfg->ClkPort == IOM_cfg[other_instance].ClkPort) || (cfg->DQSPort == IOM_cfg[other_instance].DQSPort)     ||
 800281a:	4299      	cmp	r1, r3
 800281c:	d01c      	beq.n	8002858 <HAL_OSPIM_Config+0x488>
        (cfg->NCSPort == IOM_cfg[other_instance].NCSPort) || (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) ||
 800281e:	68bb      	ldr	r3, [r7, #8]
 8002820:	68d9      	ldr	r1, [r3, #12]
 8002822:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 8002826:	4613      	mov	r3, r2
 8002828:	005b      	lsls	r3, r3, #1
 800282a:	4413      	add	r3, r2
 800282c:	00db      	lsls	r3, r3, #3
 800282e:	3350      	adds	r3, #80	; 0x50
 8002830:	443b      	add	r3, r7
 8002832:	3b30      	subs	r3, #48	; 0x30
 8002834:	681b      	ldr	r3, [r3, #0]
 8002836:	4299      	cmp	r1, r3
 8002838:	d00e      	beq.n	8002858 <HAL_OSPIM_Config+0x488>
        (cfg->IOHighPort == IOM_cfg[other_instance].IOHighPort))
 800283a:	68bb      	ldr	r3, [r7, #8]
 800283c:	6919      	ldr	r1, [r3, #16]
 800283e:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 8002842:	4613      	mov	r3, r2
 8002844:	005b      	lsls	r3, r3, #1
 8002846:	4413      	add	r3, r2
 8002848:	00db      	lsls	r3, r3, #3
 800284a:	3350      	adds	r3, #80	; 0x50
 800284c:	443b      	add	r3, r7
 800284e:	3b2c      	subs	r3, #44	; 0x2c
 8002850:	681b      	ldr	r3, [r3, #0]
        (cfg->NCSPort == IOM_cfg[other_instance].NCSPort) || (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) ||
 8002852:	4299      	cmp	r1, r3
 8002854:	f040 810e 	bne.w	8002a74 <HAL_OSPIM_Config+0x6a4>
    {
      if ((cfg->ClkPort   == IOM_cfg[other_instance].ClkPort)   &&
 8002858:	68bb      	ldr	r3, [r7, #8]
 800285a:	6819      	ldr	r1, [r3, #0]
 800285c:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 8002860:	4613      	mov	r3, r2
 8002862:	005b      	lsls	r3, r3, #1
 8002864:	4413      	add	r3, r2
 8002866:	00db      	lsls	r3, r3, #3
 8002868:	3350      	adds	r3, #80	; 0x50
 800286a:	443b      	add	r3, r7
 800286c:	3b3c      	subs	r3, #60	; 0x3c
 800286e:	681b      	ldr	r3, [r3, #0]
 8002870:	4299      	cmp	r1, r3
 8002872:	d133      	bne.n	80028dc <HAL_OSPIM_Config+0x50c>
          (cfg->DQSPort    == IOM_cfg[other_instance].DQSPort)  &&
 8002874:	68bb      	ldr	r3, [r7, #8]
 8002876:	6859      	ldr	r1, [r3, #4]
 8002878:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 800287c:	4613      	mov	r3, r2
 800287e:	005b      	lsls	r3, r3, #1
 8002880:	4413      	add	r3, r2
 8002882:	00db      	lsls	r3, r3, #3
 8002884:	3350      	adds	r3, #80	; 0x50
 8002886:	443b      	add	r3, r7
 8002888:	3b38      	subs	r3, #56	; 0x38
 800288a:	681b      	ldr	r3, [r3, #0]
      if ((cfg->ClkPort   == IOM_cfg[other_instance].ClkPort)   &&
 800288c:	4299      	cmp	r1, r3
 800288e:	d125      	bne.n	80028dc <HAL_OSPIM_Config+0x50c>
          (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) &&
 8002890:	68bb      	ldr	r3, [r7, #8]
 8002892:	68d9      	ldr	r1, [r3, #12]
 8002894:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 8002898:	4613      	mov	r3, r2
 800289a:	005b      	lsls	r3, r3, #1
 800289c:	4413      	add	r3, r2
 800289e:	00db      	lsls	r3, r3, #3
 80028a0:	3350      	adds	r3, #80	; 0x50
 80028a2:	443b      	add	r3, r7
 80028a4:	3b30      	subs	r3, #48	; 0x30
 80028a6:	681b      	ldr	r3, [r3, #0]
          (cfg->DQSPort    == IOM_cfg[other_instance].DQSPort)  &&
 80028a8:	4299      	cmp	r1, r3
 80028aa:	d117      	bne.n	80028dc <HAL_OSPIM_Config+0x50c>
          (cfg->IOHighPort == IOM_cfg[other_instance].IOHighPort))
 80028ac:	68bb      	ldr	r3, [r7, #8]
 80028ae:	6919      	ldr	r1, [r3, #16]
 80028b0:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 80028b4:	4613      	mov	r3, r2
 80028b6:	005b      	lsls	r3, r3, #1
 80028b8:	4413      	add	r3, r2
 80028ba:	00db      	lsls	r3, r3, #3
 80028bc:	3350      	adds	r3, #80	; 0x50
 80028be:	443b      	add	r3, r7
 80028c0:	3b2c      	subs	r3, #44	; 0x2c
 80028c2:	681b      	ldr	r3, [r3, #0]
          (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) &&
 80028c4:	4299      	cmp	r1, r3
 80028c6:	d109      	bne.n	80028dc <HAL_OSPIM_Config+0x50c>
      {
        /* Multiplexing should be performed */
        SET_BIT(OCTOSPIM->CR, OCTOSPIM_CR_MUXEN);
 80028c8:	4b03      	ldr	r3, [pc, #12]	; (80028d8 <HAL_OSPIM_Config+0x508>)
 80028ca:	681b      	ldr	r3, [r3, #0]
 80028cc:	4a02      	ldr	r2, [pc, #8]	; (80028d8 <HAL_OSPIM_Config+0x508>)
 80028ce:	f043 0301 	orr.w	r3, r3, #1
 80028d2:	6013      	str	r3, [r2, #0]
 80028d4:	e0ce      	b.n	8002a74 <HAL_OSPIM_Config+0x6a4>
 80028d6:	bf00      	nop
 80028d8:	420c4000 	.word	0x420c4000
      }
      else
      {
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].ClkPort - 1U)], OCTOSPIM_PCR_CLKEN);
 80028dc:	49a4      	ldr	r1, [pc, #656]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 80028de:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 80028e2:	4613      	mov	r3, r2
 80028e4:	005b      	lsls	r3, r3, #1
 80028e6:	4413      	add	r3, r2
 80028e8:	00db      	lsls	r3, r3, #3
 80028ea:	3350      	adds	r3, #80	; 0x50
 80028ec:	443b      	add	r3, r7
 80028ee:	3b3c      	subs	r3, #60	; 0x3c
 80028f0:	681b      	ldr	r3, [r3, #0]
 80028f2:	3b01      	subs	r3, #1
 80028f4:	009b      	lsls	r3, r3, #2
 80028f6:	440b      	add	r3, r1
 80028f8:	6859      	ldr	r1, [r3, #4]
 80028fa:	489d      	ldr	r0, [pc, #628]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 80028fc:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 8002900:	4613      	mov	r3, r2
 8002902:	005b      	lsls	r3, r3, #1
 8002904:	4413      	add	r3, r2
 8002906:	00db      	lsls	r3, r3, #3
 8002908:	3350      	adds	r3, #80	; 0x50
 800290a:	443b      	add	r3, r7
 800290c:	3b3c      	subs	r3, #60	; 0x3c
 800290e:	681b      	ldr	r3, [r3, #0]
 8002910:	3b01      	subs	r3, #1
 8002912:	f021 0201 	bic.w	r2, r1, #1
 8002916:	009b      	lsls	r3, r3, #2
 8002918:	4403      	add	r3, r0
 800291a:	605a      	str	r2, [r3, #4]
        if (IOM_cfg[other_instance].DQSPort != 0U)
 800291c:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 8002920:	4613      	mov	r3, r2
 8002922:	005b      	lsls	r3, r3, #1
 8002924:	4413      	add	r3, r2
 8002926:	00db      	lsls	r3, r3, #3
 8002928:	3350      	adds	r3, #80	; 0x50
 800292a:	443b      	add	r3, r7
 800292c:	3b38      	subs	r3, #56	; 0x38
 800292e:	681b      	ldr	r3, [r3, #0]
 8002930:	2b00      	cmp	r3, #0
 8002932:	d01f      	beq.n	8002974 <HAL_OSPIM_Config+0x5a4>
        {
          CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].DQSPort - 1U)], OCTOSPIM_PCR_DQSEN);
 8002934:	498e      	ldr	r1, [pc, #568]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002936:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 800293a:	4613      	mov	r3, r2
 800293c:	005b      	lsls	r3, r3, #1
 800293e:	4413      	add	r3, r2
 8002940:	00db      	lsls	r3, r3, #3
 8002942:	3350      	adds	r3, #80	; 0x50
 8002944:	443b      	add	r3, r7
 8002946:	3b38      	subs	r3, #56	; 0x38
 8002948:	681b      	ldr	r3, [r3, #0]
 800294a:	3b01      	subs	r3, #1
 800294c:	009b      	lsls	r3, r3, #2
 800294e:	440b      	add	r3, r1
 8002950:	6859      	ldr	r1, [r3, #4]
 8002952:	4887      	ldr	r0, [pc, #540]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002954:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 8002958:	4613      	mov	r3, r2
 800295a:	005b      	lsls	r3, r3, #1
 800295c:	4413      	add	r3, r2
 800295e:	00db      	lsls	r3, r3, #3
 8002960:	3350      	adds	r3, #80	; 0x50
 8002962:	443b      	add	r3, r7
 8002964:	3b38      	subs	r3, #56	; 0x38
 8002966:	681b      	ldr	r3, [r3, #0]
 8002968:	3b01      	subs	r3, #1
 800296a:	f021 0210 	bic.w	r2, r1, #16
 800296e:	009b      	lsls	r3, r3, #2
 8002970:	4403      	add	r3, r0
 8002972:	605a      	str	r2, [r3, #4]
        }
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].NCSPort - 1U)], OCTOSPIM_PCR_NCSEN);
 8002974:	497e      	ldr	r1, [pc, #504]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002976:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 800297a:	4613      	mov	r3, r2
 800297c:	005b      	lsls	r3, r3, #1
 800297e:	4413      	add	r3, r2
 8002980:	00db      	lsls	r3, r3, #3
 8002982:	3350      	adds	r3, #80	; 0x50
 8002984:	443b      	add	r3, r7
 8002986:	3b34      	subs	r3, #52	; 0x34
 8002988:	681b      	ldr	r3, [r3, #0]
 800298a:	3b01      	subs	r3, #1
 800298c:	009b      	lsls	r3, r3, #2
 800298e:	440b      	add	r3, r1
 8002990:	6859      	ldr	r1, [r3, #4]
 8002992:	4877      	ldr	r0, [pc, #476]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002994:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 8002998:	4613      	mov	r3, r2
 800299a:	005b      	lsls	r3, r3, #1
 800299c:	4413      	add	r3, r2
 800299e:	00db      	lsls	r3, r3, #3
 80029a0:	3350      	adds	r3, #80	; 0x50
 80029a2:	443b      	add	r3, r7
 80029a4:	3b34      	subs	r3, #52	; 0x34
 80029a6:	681b      	ldr	r3, [r3, #0]
 80029a8:	3b01      	subs	r3, #1
 80029aa:	f421 7280 	bic.w	r2, r1, #256	; 0x100
 80029ae:	009b      	lsls	r3, r3, #2
 80029b0:	4403      	add	r3, r0
 80029b2:	605a      	str	r2, [r3, #4]
        if (IOM_cfg[other_instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
 80029b4:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 80029b8:	4613      	mov	r3, r2
 80029ba:	005b      	lsls	r3, r3, #1
 80029bc:	4413      	add	r3, r2
 80029be:	00db      	lsls	r3, r3, #3
 80029c0:	3350      	adds	r3, #80	; 0x50
 80029c2:	443b      	add	r3, r7
 80029c4:	3b30      	subs	r3, #48	; 0x30
 80029c6:	681b      	ldr	r3, [r3, #0]
 80029c8:	2b00      	cmp	r3, #0
 80029ca:	d023      	beq.n	8002a14 <HAL_OSPIM_Config+0x644>
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOLowPort - 1U)& OSPI_IOM_PORT_MASK)],
 80029cc:	4968      	ldr	r1, [pc, #416]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 80029ce:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 80029d2:	4613      	mov	r3, r2
 80029d4:	005b      	lsls	r3, r3, #1
 80029d6:	4413      	add	r3, r2
 80029d8:	00db      	lsls	r3, r3, #3
 80029da:	3350      	adds	r3, #80	; 0x50
 80029dc:	443b      	add	r3, r7
 80029de:	3b30      	subs	r3, #48	; 0x30
 80029e0:	681b      	ldr	r3, [r3, #0]
 80029e2:	3b01      	subs	r3, #1
 80029e4:	f003 0301 	and.w	r3, r3, #1
 80029e8:	009b      	lsls	r3, r3, #2
 80029ea:	440b      	add	r3, r1
 80029ec:	6859      	ldr	r1, [r3, #4]
 80029ee:	4860      	ldr	r0, [pc, #384]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 80029f0:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 80029f4:	4613      	mov	r3, r2
 80029f6:	005b      	lsls	r3, r3, #1
 80029f8:	4413      	add	r3, r2
 80029fa:	00db      	lsls	r3, r3, #3
 80029fc:	3350      	adds	r3, #80	; 0x50
 80029fe:	443b      	add	r3, r7
 8002a00:	3b30      	subs	r3, #48	; 0x30
 8002a02:	681b      	ldr	r3, [r3, #0]
 8002a04:	3b01      	subs	r3, #1
 8002a06:	f003 0301 	and.w	r3, r3, #1
 8002a0a:	f421 3280 	bic.w	r2, r1, #65536	; 0x10000
 8002a0e:	009b      	lsls	r3, r3, #2
 8002a10:	4403      	add	r3, r0
 8002a12:	605a      	str	r2, [r3, #4]
                    OCTOSPIM_PCR_IOLEN);
        }
        if (IOM_cfg[other_instance].IOHighPort != HAL_OSPIM_IOPORT_NONE)
 8002a14:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 8002a18:	4613      	mov	r3, r2
 8002a1a:	005b      	lsls	r3, r3, #1
 8002a1c:	4413      	add	r3, r2
 8002a1e:	00db      	lsls	r3, r3, #3
 8002a20:	3350      	adds	r3, #80	; 0x50
 8002a22:	443b      	add	r3, r7
 8002a24:	3b2c      	subs	r3, #44	; 0x2c
 8002a26:	681b      	ldr	r3, [r3, #0]
 8002a28:	2b00      	cmp	r3, #0
 8002a2a:	d023      	beq.n	8002a74 <HAL_OSPIM_Config+0x6a4>
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOHighPort - 1U)& OSPI_IOM_PORT_MASK)],
 8002a2c:	4950      	ldr	r1, [pc, #320]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002a2e:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 8002a32:	4613      	mov	r3, r2
 8002a34:	005b      	lsls	r3, r3, #1
 8002a36:	4413      	add	r3, r2
 8002a38:	00db      	lsls	r3, r3, #3
 8002a3a:	3350      	adds	r3, #80	; 0x50
 8002a3c:	443b      	add	r3, r7
 8002a3e:	3b2c      	subs	r3, #44	; 0x2c
 8002a40:	681b      	ldr	r3, [r3, #0]
 8002a42:	3b01      	subs	r3, #1
 8002a44:	f003 0301 	and.w	r3, r3, #1
 8002a48:	009b      	lsls	r3, r3, #2
 8002a4a:	440b      	add	r3, r1
 8002a4c:	6859      	ldr	r1, [r3, #4]
 8002a4e:	4848      	ldr	r0, [pc, #288]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002a50:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 8002a54:	4613      	mov	r3, r2
 8002a56:	005b      	lsls	r3, r3, #1
 8002a58:	4413      	add	r3, r2
 8002a5a:	00db      	lsls	r3, r3, #3
 8002a5c:	3350      	adds	r3, #80	; 0x50
 8002a5e:	443b      	add	r3, r7
 8002a60:	3b2c      	subs	r3, #44	; 0x2c
 8002a62:	681b      	ldr	r3, [r3, #0]
 8002a64:	3b01      	subs	r3, #1
 8002a66:	f003 0301 	and.w	r3, r3, #1
 8002a6a:	f021 7280 	bic.w	r2, r1, #16777216	; 0x1000000
 8002a6e:	009b      	lsls	r3, r3, #2
 8002a70:	4403      	add	r3, r0
 8002a72:	605a      	str	r2, [r3, #4]
        }
      }
    }

    /******************** Activation of new configuration *********************/
    MODIFY_REG(OCTOSPIM->PCR[(cfg->NCSPort - 1U)], (OCTOSPIM_PCR_NCSEN | OCTOSPIM_PCR_NCSSRC),
 8002a74:	4a3e      	ldr	r2, [pc, #248]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002a76:	68bb      	ldr	r3, [r7, #8]
 8002a78:	689b      	ldr	r3, [r3, #8]
 8002a7a:	3b01      	subs	r3, #1
 8002a7c:	009b      	lsls	r3, r3, #2
 8002a7e:	4413      	add	r3, r2
 8002a80:	685b      	ldr	r3, [r3, #4]
 8002a82:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8002a86:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002a88:	025b      	lsls	r3, r3, #9
 8002a8a:	431a      	orrs	r2, r3
 8002a8c:	4938      	ldr	r1, [pc, #224]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002a8e:	68bb      	ldr	r3, [r7, #8]
 8002a90:	689b      	ldr	r3, [r3, #8]
 8002a92:	3b01      	subs	r3, #1
 8002a94:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002a98:	009b      	lsls	r3, r3, #2
 8002a9a:	440b      	add	r3, r1
 8002a9c:	605a      	str	r2, [r3, #4]
               (OCTOSPIM_PCR_NCSEN | (instance << OCTOSPIM_PCR_NCSSRC_Pos)));

    if (((cfg->Req2AckTime) >= 1U) && ((cfg->Req2AckTime) <= 256U))
 8002a9e:	68bb      	ldr	r3, [r7, #8]
 8002aa0:	695b      	ldr	r3, [r3, #20]
 8002aa2:	2b00      	cmp	r3, #0
 8002aa4:	d018      	beq.n	8002ad8 <HAL_OSPIM_Config+0x708>
 8002aa6:	68bb      	ldr	r3, [r7, #8]
 8002aa8:	695b      	ldr	r3, [r3, #20]
 8002aaa:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8002aae:	d813      	bhi.n	8002ad8 <HAL_OSPIM_Config+0x708>
    {
      if ((cfg->Req2AckTime - 1U) > ((OCTOSPIM->CR & OCTOSPIM_CR_REQ2ACK_TIME) >> OCTOSPIM_CR_REQ2ACK_TIME_Pos))
 8002ab0:	68bb      	ldr	r3, [r7, #8]
 8002ab2:	695b      	ldr	r3, [r3, #20]
 8002ab4:	1e5a      	subs	r2, r3, #1
 8002ab6:	4b2e      	ldr	r3, [pc, #184]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002ab8:	681b      	ldr	r3, [r3, #0]
 8002aba:	0c1b      	lsrs	r3, r3, #16
 8002abc:	b2db      	uxtb	r3, r3
 8002abe:	429a      	cmp	r2, r3
 8002ac0:	d90a      	bls.n	8002ad8 <HAL_OSPIM_Config+0x708>
      {
        MODIFY_REG(OCTOSPIM->CR, OCTOSPIM_CR_REQ2ACK_TIME, ((cfg->Req2AckTime - 1U) << OCTOSPIM_CR_REQ2ACK_TIME_Pos));
 8002ac2:	4b2b      	ldr	r3, [pc, #172]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002ac4:	681b      	ldr	r3, [r3, #0]
 8002ac6:	f423 027f 	bic.w	r2, r3, #16711680	; 0xff0000
 8002aca:	68bb      	ldr	r3, [r7, #8]
 8002acc:	695b      	ldr	r3, [r3, #20]
 8002ace:	3b01      	subs	r3, #1
 8002ad0:	041b      	lsls	r3, r3, #16
 8002ad2:	4927      	ldr	r1, [pc, #156]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002ad4:	4313      	orrs	r3, r2
 8002ad6:	600b      	str	r3, [r1, #0]
      {
        /* Nothing to do */
      }
    }

    if ((OCTOSPIM->CR & OCTOSPIM_CR_MUXEN) != 0U)
 8002ad8:	4b25      	ldr	r3, [pc, #148]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002ada:	681b      	ldr	r3, [r3, #0]
 8002adc:	f003 0301 	and.w	r3, r3, #1
 8002ae0:	2b00      	cmp	r3, #0
 8002ae2:	f000 809a 	beq.w	8002c1a <HAL_OSPIM_Config+0x84a>
    {
      MODIFY_REG(OCTOSPIM->PCR[(cfg->ClkPort - 1U)], (OCTOSPIM_PCR_CLKEN | OCTOSPIM_PCR_CLKSRC), OCTOSPIM_PCR_CLKEN);
 8002ae6:	4a22      	ldr	r2, [pc, #136]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002ae8:	68bb      	ldr	r3, [r7, #8]
 8002aea:	681b      	ldr	r3, [r3, #0]
 8002aec:	3b01      	subs	r3, #1
 8002aee:	009b      	lsls	r3, r3, #2
 8002af0:	4413      	add	r3, r2
 8002af2:	685b      	ldr	r3, [r3, #4]
 8002af4:	f023 0203 	bic.w	r2, r3, #3
 8002af8:	491d      	ldr	r1, [pc, #116]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002afa:	68bb      	ldr	r3, [r7, #8]
 8002afc:	681b      	ldr	r3, [r3, #0]
 8002afe:	3b01      	subs	r3, #1
 8002b00:	f042 0201 	orr.w	r2, r2, #1
 8002b04:	009b      	lsls	r3, r3, #2
 8002b06:	440b      	add	r3, r1
 8002b08:	605a      	str	r2, [r3, #4]
      if (cfg->DQSPort != 0U)
 8002b0a:	68bb      	ldr	r3, [r7, #8]
 8002b0c:	685b      	ldr	r3, [r3, #4]
 8002b0e:	2b00      	cmp	r3, #0
 8002b10:	d011      	beq.n	8002b36 <HAL_OSPIM_Config+0x766>
      {
        MODIFY_REG(OCTOSPIM->PCR[(cfg->DQSPort - 1U)], (OCTOSPIM_PCR_DQSEN | OCTOSPIM_PCR_DQSSRC), OCTOSPIM_PCR_DQSEN);
 8002b12:	4a17      	ldr	r2, [pc, #92]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002b14:	68bb      	ldr	r3, [r7, #8]
 8002b16:	685b      	ldr	r3, [r3, #4]
 8002b18:	3b01      	subs	r3, #1
 8002b1a:	009b      	lsls	r3, r3, #2
 8002b1c:	4413      	add	r3, r2
 8002b1e:	685b      	ldr	r3, [r3, #4]
 8002b20:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 8002b24:	4912      	ldr	r1, [pc, #72]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002b26:	68bb      	ldr	r3, [r7, #8]
 8002b28:	685b      	ldr	r3, [r3, #4]
 8002b2a:	3b01      	subs	r3, #1
 8002b2c:	f042 0210 	orr.w	r2, r2, #16
 8002b30:	009b      	lsls	r3, r3, #2
 8002b32:	440b      	add	r3, r1
 8002b34:	605a      	str	r2, [r3, #4]
      }

      if ((cfg->IOLowPort & OCTOSPIM_PCR_IOLEN) != 0U)
 8002b36:	68bb      	ldr	r3, [r7, #8]
 8002b38:	68db      	ldr	r3, [r3, #12]
 8002b3a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8002b3e:	2b00      	cmp	r3, #0
 8002b40:	d018      	beq.n	8002b74 <HAL_OSPIM_Config+0x7a4>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort - 1U)& OSPI_IOM_PORT_MASK)],
 8002b42:	4a0b      	ldr	r2, [pc, #44]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002b44:	68bb      	ldr	r3, [r7, #8]
 8002b46:	68db      	ldr	r3, [r3, #12]
 8002b48:	3b01      	subs	r3, #1
 8002b4a:	f003 0301 	and.w	r3, r3, #1
 8002b4e:	009b      	lsls	r3, r3, #2
 8002b50:	4413      	add	r3, r2
 8002b52:	685b      	ldr	r3, [r3, #4]
 8002b54:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
 8002b58:	4905      	ldr	r1, [pc, #20]	; (8002b70 <HAL_OSPIM_Config+0x7a0>)
 8002b5a:	68bb      	ldr	r3, [r7, #8]
 8002b5c:	68db      	ldr	r3, [r3, #12]
 8002b5e:	3b01      	subs	r3, #1
 8002b60:	f003 0301 	and.w	r3, r3, #1
 8002b64:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8002b68:	009b      	lsls	r3, r3, #2
 8002b6a:	440b      	add	r3, r1
 8002b6c:	605a      	str	r2, [r3, #4]
 8002b6e:	e01b      	b.n	8002ba8 <HAL_OSPIM_Config+0x7d8>
 8002b70:	420c4000 	.word	0x420c4000
                   (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC), OCTOSPIM_PCR_IOLEN);
      }
      else if (cfg->IOLowPort != HAL_OSPIM_IOPORT_NONE)
 8002b74:	68bb      	ldr	r3, [r7, #8]
 8002b76:	68db      	ldr	r3, [r3, #12]
 8002b78:	2b00      	cmp	r3, #0
 8002b7a:	d015      	beq.n	8002ba8 <HAL_OSPIM_Config+0x7d8>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort - 1U)& OSPI_IOM_PORT_MASK)],
 8002b7c:	4a8a      	ldr	r2, [pc, #552]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002b7e:	68bb      	ldr	r3, [r7, #8]
 8002b80:	68db      	ldr	r3, [r3, #12]
 8002b82:	3b01      	subs	r3, #1
 8002b84:	f003 0301 	and.w	r3, r3, #1
 8002b88:	009b      	lsls	r3, r3, #2
 8002b8a:	4413      	add	r3, r2
 8002b8c:	685b      	ldr	r3, [r3, #4]
 8002b8e:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
 8002b92:	4985      	ldr	r1, [pc, #532]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002b94:	68bb      	ldr	r3, [r7, #8]
 8002b96:	68db      	ldr	r3, [r3, #12]
 8002b98:	3b01      	subs	r3, #1
 8002b9a:	f003 0301 	and.w	r3, r3, #1
 8002b9e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8002ba2:	009b      	lsls	r3, r3, #2
 8002ba4:	440b      	add	r3, r1
 8002ba6:	605a      	str	r2, [r3, #4]
      else
      {
        /* Nothing to do */
      }

      if ((cfg->IOHighPort & OCTOSPIM_PCR_IOLEN) != 0U)
 8002ba8:	68bb      	ldr	r3, [r7, #8]
 8002baa:	691b      	ldr	r3, [r3, #16]
 8002bac:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8002bb0:	2b00      	cmp	r3, #0
 8002bb2:	d016      	beq.n	8002be2 <HAL_OSPIM_Config+0x812>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort - 1U)& OSPI_IOM_PORT_MASK)],
 8002bb4:	4a7c      	ldr	r2, [pc, #496]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002bb6:	68bb      	ldr	r3, [r7, #8]
 8002bb8:	691b      	ldr	r3, [r3, #16]
 8002bba:	3b01      	subs	r3, #1
 8002bbc:	f003 0301 	and.w	r3, r3, #1
 8002bc0:	009b      	lsls	r3, r3, #2
 8002bc2:	4413      	add	r3, r2
 8002bc4:	685b      	ldr	r3, [r3, #4]
 8002bc6:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
 8002bca:	4977      	ldr	r1, [pc, #476]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002bcc:	68bb      	ldr	r3, [r7, #8]
 8002bce:	691b      	ldr	r3, [r3, #16]
 8002bd0:	3b01      	subs	r3, #1
 8002bd2:	f003 0301 	and.w	r3, r3, #1
 8002bd6:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
 8002bda:	009b      	lsls	r3, r3, #2
 8002bdc:	440b      	add	r3, r1
 8002bde:	605a      	str	r2, [r3, #4]
 8002be0:	e0c3      	b.n	8002d6a <HAL_OSPIM_Config+0x99a>
                   (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC), (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC_0));
      }
      else if (cfg->IOHighPort != HAL_OSPIM_IOPORT_NONE)
 8002be2:	68bb      	ldr	r3, [r7, #8]
 8002be4:	691b      	ldr	r3, [r3, #16]
 8002be6:	2b00      	cmp	r3, #0
 8002be8:	f000 80bf 	beq.w	8002d6a <HAL_OSPIM_Config+0x99a>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort - 1U)& OSPI_IOM_PORT_MASK)],
 8002bec:	4a6e      	ldr	r2, [pc, #440]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002bee:	68bb      	ldr	r3, [r7, #8]
 8002bf0:	691b      	ldr	r3, [r3, #16]
 8002bf2:	3b01      	subs	r3, #1
 8002bf4:	f003 0301 	and.w	r3, r3, #1
 8002bf8:	009b      	lsls	r3, r3, #2
 8002bfa:	4413      	add	r3, r2
 8002bfc:	685b      	ldr	r3, [r3, #4]
 8002bfe:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
 8002c02:	4969      	ldr	r1, [pc, #420]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002c04:	68bb      	ldr	r3, [r7, #8]
 8002c06:	691b      	ldr	r3, [r3, #16]
 8002c08:	3b01      	subs	r3, #1
 8002c0a:	f003 0301 	and.w	r3, r3, #1
 8002c0e:	f042 7240 	orr.w	r2, r2, #50331648	; 0x3000000
 8002c12:	009b      	lsls	r3, r3, #2
 8002c14:	440b      	add	r3, r1
 8002c16:	605a      	str	r2, [r3, #4]
 8002c18:	e0a7      	b.n	8002d6a <HAL_OSPIM_Config+0x99a>
        /* Nothing to do */
      }
    }
    else
    {
      MODIFY_REG(OCTOSPIM->PCR[(cfg->ClkPort - 1U)], (OCTOSPIM_PCR_CLKEN | OCTOSPIM_PCR_CLKSRC),
 8002c1a:	4a63      	ldr	r2, [pc, #396]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002c1c:	68bb      	ldr	r3, [r7, #8]
 8002c1e:	681b      	ldr	r3, [r3, #0]
 8002c20:	3b01      	subs	r3, #1
 8002c22:	009b      	lsls	r3, r3, #2
 8002c24:	4413      	add	r3, r2
 8002c26:	685b      	ldr	r3, [r3, #4]
 8002c28:	f023 0203 	bic.w	r2, r3, #3
 8002c2c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002c2e:	005b      	lsls	r3, r3, #1
 8002c30:	431a      	orrs	r2, r3
 8002c32:	495d      	ldr	r1, [pc, #372]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002c34:	68bb      	ldr	r3, [r7, #8]
 8002c36:	681b      	ldr	r3, [r3, #0]
 8002c38:	3b01      	subs	r3, #1
 8002c3a:	f042 0201 	orr.w	r2, r2, #1
 8002c3e:	009b      	lsls	r3, r3, #2
 8002c40:	440b      	add	r3, r1
 8002c42:	605a      	str	r2, [r3, #4]
                 (OCTOSPIM_PCR_CLKEN | (instance << OCTOSPIM_PCR_CLKSRC_Pos)));
      if (cfg->DQSPort != 0U)
 8002c44:	68bb      	ldr	r3, [r7, #8]
 8002c46:	685b      	ldr	r3, [r3, #4]
 8002c48:	2b00      	cmp	r3, #0
 8002c4a:	d014      	beq.n	8002c76 <HAL_OSPIM_Config+0x8a6>
      {
        MODIFY_REG(OCTOSPIM->PCR[(cfg->DQSPort - 1U)], (OCTOSPIM_PCR_DQSEN | OCTOSPIM_PCR_DQSSRC),
 8002c4c:	4a56      	ldr	r2, [pc, #344]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002c4e:	68bb      	ldr	r3, [r7, #8]
 8002c50:	685b      	ldr	r3, [r3, #4]
 8002c52:	3b01      	subs	r3, #1
 8002c54:	009b      	lsls	r3, r3, #2
 8002c56:	4413      	add	r3, r2
 8002c58:	685b      	ldr	r3, [r3, #4]
 8002c5a:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 8002c5e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002c60:	015b      	lsls	r3, r3, #5
 8002c62:	431a      	orrs	r2, r3
 8002c64:	4950      	ldr	r1, [pc, #320]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002c66:	68bb      	ldr	r3, [r7, #8]
 8002c68:	685b      	ldr	r3, [r3, #4]
 8002c6a:	3b01      	subs	r3, #1
 8002c6c:	f042 0210 	orr.w	r2, r2, #16
 8002c70:	009b      	lsls	r3, r3, #2
 8002c72:	440b      	add	r3, r1
 8002c74:	605a      	str	r2, [r3, #4]
                   (OCTOSPIM_PCR_DQSEN | (instance << OCTOSPIM_PCR_DQSSRC_Pos)));
      }

      if ((cfg->IOLowPort & OCTOSPIM_PCR_IOLEN) != 0U)
 8002c76:	68bb      	ldr	r3, [r7, #8]
 8002c78:	68db      	ldr	r3, [r3, #12]
 8002c7a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8002c7e:	2b00      	cmp	r3, #0
 8002c80:	d019      	beq.n	8002cb6 <HAL_OSPIM_Config+0x8e6>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort - 1U)& OSPI_IOM_PORT_MASK)],
 8002c82:	4a49      	ldr	r2, [pc, #292]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002c84:	68bb      	ldr	r3, [r7, #8]
 8002c86:	68db      	ldr	r3, [r3, #12]
 8002c88:	3b01      	subs	r3, #1
 8002c8a:	f003 0301 	and.w	r3, r3, #1
 8002c8e:	009b      	lsls	r3, r3, #2
 8002c90:	4413      	add	r3, r2
 8002c92:	685b      	ldr	r3, [r3, #4]
 8002c94:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
 8002c98:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002c9a:	049b      	lsls	r3, r3, #18
 8002c9c:	431a      	orrs	r2, r3
 8002c9e:	4942      	ldr	r1, [pc, #264]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002ca0:	68bb      	ldr	r3, [r7, #8]
 8002ca2:	68db      	ldr	r3, [r3, #12]
 8002ca4:	3b01      	subs	r3, #1
 8002ca6:	f003 0301 	and.w	r3, r3, #1
 8002caa:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8002cae:	009b      	lsls	r3, r3, #2
 8002cb0:	440b      	add	r3, r1
 8002cb2:	605a      	str	r2, [r3, #4]
 8002cb4:	e01c      	b.n	8002cf0 <HAL_OSPIM_Config+0x920>
                   (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC),
                   (OCTOSPIM_PCR_IOLEN | (instance << (OCTOSPIM_PCR_IOLSRC_Pos + 1U))));
      }
      else if (cfg->IOLowPort != HAL_OSPIM_IOPORT_NONE)
 8002cb6:	68bb      	ldr	r3, [r7, #8]
 8002cb8:	68db      	ldr	r3, [r3, #12]
 8002cba:	2b00      	cmp	r3, #0
 8002cbc:	d018      	beq.n	8002cf0 <HAL_OSPIM_Config+0x920>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort - 1U)& OSPI_IOM_PORT_MASK)],
 8002cbe:	4a3a      	ldr	r2, [pc, #232]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002cc0:	68bb      	ldr	r3, [r7, #8]
 8002cc2:	68db      	ldr	r3, [r3, #12]
 8002cc4:	3b01      	subs	r3, #1
 8002cc6:	f003 0301 	and.w	r3, r3, #1
 8002cca:	009b      	lsls	r3, r3, #2
 8002ccc:	4413      	add	r3, r2
 8002cce:	685b      	ldr	r3, [r3, #4]
 8002cd0:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
 8002cd4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002cd6:	069b      	lsls	r3, r3, #26
 8002cd8:	431a      	orrs	r2, r3
 8002cda:	4933      	ldr	r1, [pc, #204]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002cdc:	68bb      	ldr	r3, [r7, #8]
 8002cde:	68db      	ldr	r3, [r3, #12]
 8002ce0:	3b01      	subs	r3, #1
 8002ce2:	f003 0301 	and.w	r3, r3, #1
 8002ce6:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8002cea:	009b      	lsls	r3, r3, #2
 8002cec:	440b      	add	r3, r1
 8002cee:	605a      	str	r2, [r3, #4]
      else
      {
        /* Nothing to do */
      }

      if ((cfg->IOHighPort & OCTOSPIM_PCR_IOLEN) != 0U)
 8002cf0:	68bb      	ldr	r3, [r7, #8]
 8002cf2:	691b      	ldr	r3, [r3, #16]
 8002cf4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8002cf8:	2b00      	cmp	r3, #0
 8002cfa:	d019      	beq.n	8002d30 <HAL_OSPIM_Config+0x960>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort - 1U)& OSPI_IOM_PORT_MASK)],
 8002cfc:	4a2a      	ldr	r2, [pc, #168]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002cfe:	68bb      	ldr	r3, [r7, #8]
 8002d00:	691b      	ldr	r3, [r3, #16]
 8002d02:	3b01      	subs	r3, #1
 8002d04:	f003 0301 	and.w	r3, r3, #1
 8002d08:	009b      	lsls	r3, r3, #2
 8002d0a:	4413      	add	r3, r2
 8002d0c:	685b      	ldr	r3, [r3, #4]
 8002d0e:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
 8002d12:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002d14:	049b      	lsls	r3, r3, #18
 8002d16:	431a      	orrs	r2, r3
 8002d18:	4923      	ldr	r1, [pc, #140]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002d1a:	68bb      	ldr	r3, [r7, #8]
 8002d1c:	691b      	ldr	r3, [r3, #16]
 8002d1e:	3b01      	subs	r3, #1
 8002d20:	f003 0301 	and.w	r3, r3, #1
 8002d24:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
 8002d28:	009b      	lsls	r3, r3, #2
 8002d2a:	440b      	add	r3, r1
 8002d2c:	605a      	str	r2, [r3, #4]
 8002d2e:	e01c      	b.n	8002d6a <HAL_OSPIM_Config+0x99a>
                   (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC),
                   (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC_0 | (instance << (OCTOSPIM_PCR_IOLSRC_Pos + 1U))));
      }
      else if (cfg->IOHighPort != HAL_OSPIM_IOPORT_NONE)
 8002d30:	68bb      	ldr	r3, [r7, #8]
 8002d32:	691b      	ldr	r3, [r3, #16]
 8002d34:	2b00      	cmp	r3, #0
 8002d36:	d018      	beq.n	8002d6a <HAL_OSPIM_Config+0x99a>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort - 1U)& OSPI_IOM_PORT_MASK)],
 8002d38:	4a1b      	ldr	r2, [pc, #108]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002d3a:	68bb      	ldr	r3, [r7, #8]
 8002d3c:	691b      	ldr	r3, [r3, #16]
 8002d3e:	3b01      	subs	r3, #1
 8002d40:	f003 0301 	and.w	r3, r3, #1
 8002d44:	009b      	lsls	r3, r3, #2
 8002d46:	4413      	add	r3, r2
 8002d48:	685b      	ldr	r3, [r3, #4]
 8002d4a:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
 8002d4e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002d50:	069b      	lsls	r3, r3, #26
 8002d52:	431a      	orrs	r2, r3
 8002d54:	4914      	ldr	r1, [pc, #80]	; (8002da8 <HAL_OSPIM_Config+0x9d8>)
 8002d56:	68bb      	ldr	r3, [r7, #8]
 8002d58:	691b      	ldr	r3, [r3, #16]
 8002d5a:	3b01      	subs	r3, #1
 8002d5c:	f003 0301 	and.w	r3, r3, #1
 8002d60:	f042 7240 	orr.w	r2, r2, #50331648	; 0x3000000
 8002d64:	009b      	lsls	r3, r3, #2
 8002d66:	440b      	add	r3, r1
 8002d68:	605a      	str	r2, [r3, #4]
        /* Nothing to do */
      }
    }

    /******* Re-enable both OctoSPI after configure OctoSPI IO Manager ********/
    if ((ospi_enabled & 0x1U) != 0U)
 8002d6a:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 8002d6e:	f003 0301 	and.w	r3, r3, #1
 8002d72:	2b00      	cmp	r3, #0
 8002d74:	d005      	beq.n	8002d82 <HAL_OSPIM_Config+0x9b2>
    {
      SET_BIT(OCTOSPI1->CR, OCTOSPI_CR_EN);
 8002d76:	4b0d      	ldr	r3, [pc, #52]	; (8002dac <HAL_OSPIM_Config+0x9dc>)
 8002d78:	681b      	ldr	r3, [r3, #0]
 8002d7a:	4a0c      	ldr	r2, [pc, #48]	; (8002dac <HAL_OSPIM_Config+0x9dc>)
 8002d7c:	f043 0301 	orr.w	r3, r3, #1
 8002d80:	6013      	str	r3, [r2, #0]
    }
    if ((ospi_enabled & 0x2U) != 0U)
 8002d82:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 8002d86:	f003 0302 	and.w	r3, r3, #2
 8002d8a:	2b00      	cmp	r3, #0
 8002d8c:	d005      	beq.n	8002d9a <HAL_OSPIM_Config+0x9ca>
    {
      SET_BIT(OCTOSPI2->CR, OCTOSPI_CR_EN);
 8002d8e:	4b08      	ldr	r3, [pc, #32]	; (8002db0 <HAL_OSPIM_Config+0x9e0>)
 8002d90:	681b      	ldr	r3, [r3, #0]
 8002d92:	4a07      	ldr	r2, [pc, #28]	; (8002db0 <HAL_OSPIM_Config+0x9e0>)
 8002d94:	f043 0301 	orr.w	r3, r3, #1
 8002d98:	6013      	str	r3, [r2, #0]
    }
  }

  /* Return function status */
  return status;
 8002d9a:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
}
 8002d9e:	4618      	mov	r0, r3
 8002da0:	3750      	adds	r7, #80	; 0x50
 8002da2:	46bd      	mov	sp, r7
 8002da4:	bd80      	pop	{r7, pc}
 8002da6:	bf00      	nop
 8002da8:	420c4000 	.word	0x420c4000
 8002dac:	420d1400 	.word	0x420d1400
 8002db0:	420d2400 	.word	0x420d2400

08002db4 <OSPI_DMAAbortCplt>:
  * @brief  DMA OSPI abort complete callback.
  * @param  hdma : DMA handle
  * @retval None
  */
static void OSPI_DMAAbortCplt(DMA_HandleTypeDef *hdma)
{
 8002db4:	b580      	push	{r7, lr}
 8002db6:	b084      	sub	sp, #16
 8002db8:	af00      	add	r7, sp, #0
 8002dba:	6078      	str	r0, [r7, #4]
  OSPI_HandleTypeDef *hospi = (OSPI_HandleTypeDef *)(hdma->Parent);
 8002dbc:	687b      	ldr	r3, [r7, #4]
 8002dbe:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002dc0:	60fb      	str	r3, [r7, #12]
  hospi->XferCount = 0;
 8002dc2:	68fb      	ldr	r3, [r7, #12]
 8002dc4:	2200      	movs	r2, #0
 8002dc6:	649a      	str	r2, [r3, #72]	; 0x48

  /* Check the state */
  if (hospi->State == HAL_OSPI_STATE_ABORT)
 8002dc8:	68fb      	ldr	r3, [r7, #12]
 8002dca:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8002dcc:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8002dd0:	d122      	bne.n	8002e18 <OSPI_DMAAbortCplt+0x64>
  {
    /* DMA abort called by OctoSPI abort */
    if (__HAL_OSPI_GET_FLAG(hospi, HAL_OSPI_FLAG_BUSY) != RESET)
 8002dd2:	68fb      	ldr	r3, [r7, #12]
 8002dd4:	681b      	ldr	r3, [r3, #0]
 8002dd6:	6a1b      	ldr	r3, [r3, #32]
 8002dd8:	f003 0320 	and.w	r3, r3, #32
 8002ddc:	2b00      	cmp	r3, #0
 8002dde:	d014      	beq.n	8002e0a <OSPI_DMAAbortCplt+0x56>
    {
      /* Clear transfer complete flag */
      __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 8002de0:	68fb      	ldr	r3, [r7, #12]
 8002de2:	681b      	ldr	r3, [r3, #0]
 8002de4:	2202      	movs	r2, #2
 8002de6:	625a      	str	r2, [r3, #36]	; 0x24

      /* Enable the transfer complete interrupts */
      __HAL_OSPI_ENABLE_IT(hospi, HAL_OSPI_IT_TC);
 8002de8:	68fb      	ldr	r3, [r7, #12]
 8002dea:	681b      	ldr	r3, [r3, #0]
 8002dec:	681a      	ldr	r2, [r3, #0]
 8002dee:	68fb      	ldr	r3, [r7, #12]
 8002df0:	681b      	ldr	r3, [r3, #0]
 8002df2:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8002df6:	601a      	str	r2, [r3, #0]

      /* Perform an abort of the OctoSPI */
      SET_BIT(hospi->Instance->CR, OCTOSPI_CR_ABORT);
 8002df8:	68fb      	ldr	r3, [r7, #12]
 8002dfa:	681b      	ldr	r3, [r3, #0]
 8002dfc:	681a      	ldr	r2, [r3, #0]
 8002dfe:	68fb      	ldr	r3, [r7, #12]
 8002e00:	681b      	ldr	r3, [r3, #0]
 8002e02:	f042 0202 	orr.w	r2, r2, #2
 8002e06:	601a      	str	r2, [r3, #0]
    hospi->ErrorCallback(hospi);
#else
    HAL_OSPI_ErrorCallback(hospi);
#endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)*/
  }
}
 8002e08:	e00c      	b.n	8002e24 <OSPI_DMAAbortCplt+0x70>
      hospi->State = HAL_OSPI_STATE_READY;
 8002e0a:	68fb      	ldr	r3, [r7, #12]
 8002e0c:	2202      	movs	r2, #2
 8002e0e:	651a      	str	r2, [r3, #80]	; 0x50
      HAL_OSPI_AbortCpltCallback(hospi);
 8002e10:	68f8      	ldr	r0, [r7, #12]
 8002e12:	f7ff fa12 	bl	800223a <HAL_OSPI_AbortCpltCallback>
}
 8002e16:	e005      	b.n	8002e24 <OSPI_DMAAbortCplt+0x70>
    hospi->State = HAL_OSPI_STATE_READY;
 8002e18:	68fb      	ldr	r3, [r7, #12]
 8002e1a:	2202      	movs	r2, #2
 8002e1c:	651a      	str	r2, [r3, #80]	; 0x50
    HAL_OSPI_ErrorCallback(hospi);
 8002e1e:	68f8      	ldr	r0, [r7, #12]
 8002e20:	f7ff fa01 	bl	8002226 <HAL_OSPI_ErrorCallback>
}
 8002e24:	bf00      	nop
 8002e26:	3710      	adds	r7, #16
 8002e28:	46bd      	mov	sp, r7
 8002e2a:	bd80      	pop	{r7, pc}

08002e2c <OSPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart : Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef OSPI_WaitFlagStateUntilTimeout(OSPI_HandleTypeDef *hospi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
 8002e2c:	b580      	push	{r7, lr}
 8002e2e:	b084      	sub	sp, #16
 8002e30:	af00      	add	r7, sp, #0
 8002e32:	60f8      	str	r0, [r7, #12]
 8002e34:	60b9      	str	r1, [r7, #8]
 8002e36:	603b      	str	r3, [r7, #0]
 8002e38:	4613      	mov	r3, r2
 8002e3a:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while ((__HAL_OSPI_GET_FLAG(hospi, Flag)) != State)
 8002e3c:	e022      	b.n	8002e84 <OSPI_WaitFlagStateUntilTimeout+0x58>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8002e3e:	69bb      	ldr	r3, [r7, #24]
 8002e40:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8002e44:	d01e      	beq.n	8002e84 <OSPI_WaitFlagStateUntilTimeout+0x58>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8002e46:	f7fe f8e7 	bl	8001018 <HAL_GetTick>
 8002e4a:	4602      	mov	r2, r0
 8002e4c:	683b      	ldr	r3, [r7, #0]
 8002e4e:	1ad3      	subs	r3, r2, r3
 8002e50:	69ba      	ldr	r2, [r7, #24]
 8002e52:	429a      	cmp	r2, r3
 8002e54:	d302      	bcc.n	8002e5c <OSPI_WaitFlagStateUntilTimeout+0x30>
 8002e56:	69bb      	ldr	r3, [r7, #24]
 8002e58:	2b00      	cmp	r3, #0
 8002e5a:	d113      	bne.n	8002e84 <OSPI_WaitFlagStateUntilTimeout+0x58>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if ((hospi->Instance->SR & Flag) != (uint32_t)State)
 8002e5c:	68fb      	ldr	r3, [r7, #12]
 8002e5e:	681b      	ldr	r3, [r3, #0]
 8002e60:	6a1a      	ldr	r2, [r3, #32]
 8002e62:	68bb      	ldr	r3, [r7, #8]
 8002e64:	401a      	ands	r2, r3
 8002e66:	79fb      	ldrb	r3, [r7, #7]
 8002e68:	429a      	cmp	r2, r3
 8002e6a:	d00b      	beq.n	8002e84 <OSPI_WaitFlagStateUntilTimeout+0x58>
        {
          hospi->State     = HAL_OSPI_STATE_ERROR;
 8002e6c:	68fb      	ldr	r3, [r7, #12]
 8002e6e:	f44f 7200 	mov.w	r2, #512	; 0x200
 8002e72:	651a      	str	r2, [r3, #80]	; 0x50
          hospi->ErrorCode |= HAL_OSPI_ERROR_TIMEOUT;
 8002e74:	68fb      	ldr	r3, [r7, #12]
 8002e76:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8002e78:	f043 0201 	orr.w	r2, r3, #1
 8002e7c:	68fb      	ldr	r3, [r7, #12]
 8002e7e:	655a      	str	r2, [r3, #84]	; 0x54

          return HAL_ERROR;
 8002e80:	2301      	movs	r3, #1
 8002e82:	e00e      	b.n	8002ea2 <OSPI_WaitFlagStateUntilTimeout+0x76>
  while ((__HAL_OSPI_GET_FLAG(hospi, Flag)) != State)
 8002e84:	68fb      	ldr	r3, [r7, #12]
 8002e86:	681b      	ldr	r3, [r3, #0]
 8002e88:	6a1a      	ldr	r2, [r3, #32]
 8002e8a:	68bb      	ldr	r3, [r7, #8]
 8002e8c:	4013      	ands	r3, r2
 8002e8e:	2b00      	cmp	r3, #0
 8002e90:	bf14      	ite	ne
 8002e92:	2301      	movne	r3, #1
 8002e94:	2300      	moveq	r3, #0
 8002e96:	b2db      	uxtb	r3, r3
 8002e98:	461a      	mov	r2, r3
 8002e9a:	79fb      	ldrb	r3, [r7, #7]
 8002e9c:	429a      	cmp	r2, r3
 8002e9e:	d1ce      	bne.n	8002e3e <OSPI_WaitFlagStateUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 8002ea0:	2300      	movs	r3, #0
}
 8002ea2:	4618      	mov	r0, r3
 8002ea4:	3710      	adds	r7, #16
 8002ea6:	46bd      	mov	sp, r7
 8002ea8:	bd80      	pop	{r7, pc}
	...

08002eac <OSPI_ConfigCmd>:
  * @param  hospi : OSPI handle
  * @param  cmd   : structure that contains the command configuration information
  * @retval HAL status
  */
static HAL_StatusTypeDef OSPI_ConfigCmd(OSPI_HandleTypeDef *hospi, OSPI_RegularCmdTypeDef *cmd)
{
 8002eac:	b480      	push	{r7}
 8002eae:	b089      	sub	sp, #36	; 0x24
 8002eb0:	af00      	add	r7, sp, #0
 8002eb2:	6078      	str	r0, [r7, #4]
 8002eb4:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8002eb6:	2300      	movs	r3, #0
 8002eb8:	77fb      	strb	r3, [r7, #31]
  __IO uint32_t *tcr_reg;
  __IO uint32_t *ir_reg;
  __IO uint32_t *abr_reg;

  /* Re-initialize the value of the functional mode */
  MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, 0U);
 8002eba:	687b      	ldr	r3, [r7, #4]
 8002ebc:	681b      	ldr	r3, [r3, #0]
 8002ebe:	681a      	ldr	r2, [r3, #0]
 8002ec0:	687b      	ldr	r3, [r7, #4]
 8002ec2:	681b      	ldr	r3, [r3, #0]
 8002ec4:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8002ec8:	601a      	str	r2, [r3, #0]

  /* Configure the flash ID */
  if (hospi->Init.DualQuad == HAL_OSPI_DUALQUAD_DISABLE)
 8002eca:	687b      	ldr	r3, [r7, #4]
 8002ecc:	689b      	ldr	r3, [r3, #8]
 8002ece:	2b00      	cmp	r3, #0
 8002ed0:	d10a      	bne.n	8002ee8 <OSPI_ConfigCmd+0x3c>
  {
    MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_MSEL, cmd->FlashId);
 8002ed2:	687b      	ldr	r3, [r7, #4]
 8002ed4:	681b      	ldr	r3, [r3, #0]
 8002ed6:	681b      	ldr	r3, [r3, #0]
 8002ed8:	f023 0180 	bic.w	r1, r3, #128	; 0x80
 8002edc:	683b      	ldr	r3, [r7, #0]
 8002ede:	685a      	ldr	r2, [r3, #4]
 8002ee0:	687b      	ldr	r3, [r7, #4]
 8002ee2:	681b      	ldr	r3, [r3, #0]
 8002ee4:	430a      	orrs	r2, r1
 8002ee6:	601a      	str	r2, [r3, #0]
  }

  if (cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG)
 8002ee8:	683b      	ldr	r3, [r7, #0]
 8002eea:	681b      	ldr	r3, [r3, #0]
 8002eec:	2b02      	cmp	r3, #2
 8002eee:	d114      	bne.n	8002f1a <OSPI_ConfigCmd+0x6e>
  {
    ccr_reg = &(hospi->Instance->WCCR);
 8002ef0:	687b      	ldr	r3, [r7, #4]
 8002ef2:	681b      	ldr	r3, [r3, #0]
 8002ef4:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 8002ef8:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hospi->Instance->WTCR);
 8002efa:	687b      	ldr	r3, [r7, #4]
 8002efc:	681b      	ldr	r3, [r3, #0]
 8002efe:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 8002f02:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hospi->Instance->WIR);
 8002f04:	687b      	ldr	r3, [r7, #4]
 8002f06:	681b      	ldr	r3, [r3, #0]
 8002f08:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8002f0c:	613b      	str	r3, [r7, #16]
    abr_reg = &(hospi->Instance->WABR);
 8002f0e:	687b      	ldr	r3, [r7, #4]
 8002f10:	681b      	ldr	r3, [r3, #0]
 8002f12:	f503 73d0 	add.w	r3, r3, #416	; 0x1a0
 8002f16:	60fb      	str	r3, [r7, #12]
 8002f18:	e02c      	b.n	8002f74 <OSPI_ConfigCmd+0xc8>
  }
  else if (cmd->OperationType == HAL_OSPI_OPTYPE_WRAP_CFG)
 8002f1a:	683b      	ldr	r3, [r7, #0]
 8002f1c:	681b      	ldr	r3, [r3, #0]
 8002f1e:	2b03      	cmp	r3, #3
 8002f20:	d114      	bne.n	8002f4c <OSPI_ConfigCmd+0xa0>
  {
    ccr_reg = &(hospi->Instance->WPCCR);
 8002f22:	687b      	ldr	r3, [r7, #4]
 8002f24:	681b      	ldr	r3, [r3, #0]
 8002f26:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 8002f2a:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hospi->Instance->WPTCR);
 8002f2c:	687b      	ldr	r3, [r7, #4]
 8002f2e:	681b      	ldr	r3, [r3, #0]
 8002f30:	f503 73a4 	add.w	r3, r3, #328	; 0x148
 8002f34:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hospi->Instance->WPIR);
 8002f36:	687b      	ldr	r3, [r7, #4]
 8002f38:	681b      	ldr	r3, [r3, #0]
 8002f3a:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 8002f3e:	613b      	str	r3, [r7, #16]
    abr_reg = &(hospi->Instance->WPABR);
 8002f40:	687b      	ldr	r3, [r7, #4]
 8002f42:	681b      	ldr	r3, [r3, #0]
 8002f44:	f503 73b0 	add.w	r3, r3, #352	; 0x160
 8002f48:	60fb      	str	r3, [r7, #12]
 8002f4a:	e013      	b.n	8002f74 <OSPI_ConfigCmd+0xc8>
  }
  else
  {
    ccr_reg = &(hospi->Instance->CCR);
 8002f4c:	687b      	ldr	r3, [r7, #4]
 8002f4e:	681b      	ldr	r3, [r3, #0]
 8002f50:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8002f54:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hospi->Instance->TCR);
 8002f56:	687b      	ldr	r3, [r7, #4]
 8002f58:	681b      	ldr	r3, [r3, #0]
 8002f5a:	f503 7384 	add.w	r3, r3, #264	; 0x108
 8002f5e:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hospi->Instance->IR);
 8002f60:	687b      	ldr	r3, [r7, #4]
 8002f62:	681b      	ldr	r3, [r3, #0]
 8002f64:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8002f68:	613b      	str	r3, [r7, #16]
    abr_reg = &(hospi->Instance->ABR);
 8002f6a:	687b      	ldr	r3, [r7, #4]
 8002f6c:	681b      	ldr	r3, [r3, #0]
 8002f6e:	f503 7390 	add.w	r3, r3, #288	; 0x120
 8002f72:	60fb      	str	r3, [r7, #12]
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = (cmd->DQSMode | cmd->SIOOMode);
 8002f74:	683b      	ldr	r3, [r7, #0]
 8002f76:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8002f78:	683b      	ldr	r3, [r7, #0]
 8002f7a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8002f7c:	431a      	orrs	r2, r3
 8002f7e:	69bb      	ldr	r3, [r7, #24]
 8002f80:	601a      	str	r2, [r3, #0]

  if (cmd->AlternateBytesMode != HAL_OSPI_ALTERNATE_BYTES_NONE)
 8002f82:	683b      	ldr	r3, [r7, #0]
 8002f84:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002f86:	2b00      	cmp	r3, #0
 8002f88:	d012      	beq.n	8002fb0 <OSPI_ConfigCmd+0x104>
  {
    /* Configure the ABR register with alternate bytes value */
    *abr_reg = cmd->AlternateBytes;
 8002f8a:	683b      	ldr	r3, [r7, #0]
 8002f8c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002f8e:	68fb      	ldr	r3, [r7, #12]
 8002f90:	601a      	str	r2, [r3, #0]

    /* Configure the CCR register with alternate bytes communication parameters */
    MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ABMODE | OCTOSPI_CCR_ABDTR | OCTOSPI_CCR_ABSIZE),
 8002f92:	69bb      	ldr	r3, [r7, #24]
 8002f94:	681b      	ldr	r3, [r3, #0]
 8002f96:	f423 127c 	bic.w	r2, r3, #4128768	; 0x3f0000
 8002f9a:	683b      	ldr	r3, [r7, #0]
 8002f9c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8002f9e:	683b      	ldr	r3, [r7, #0]
 8002fa0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002fa2:	4319      	orrs	r1, r3
 8002fa4:	683b      	ldr	r3, [r7, #0]
 8002fa6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002fa8:	430b      	orrs	r3, r1
 8002faa:	431a      	orrs	r2, r3
 8002fac:	69bb      	ldr	r3, [r7, #24]
 8002fae:	601a      	str	r2, [r3, #0]
               (cmd->AlternateBytesMode | cmd->AlternateBytesDtrMode | cmd->AlternateBytesSize));
  }

  /* Configure the TCR register with the number of dummy cycles */
  MODIFY_REG((*tcr_reg), OCTOSPI_TCR_DCYC, cmd->DummyCycles);
 8002fb0:	697b      	ldr	r3, [r7, #20]
 8002fb2:	681b      	ldr	r3, [r3, #0]
 8002fb4:	f023 021f 	bic.w	r2, r3, #31
 8002fb8:	683b      	ldr	r3, [r7, #0]
 8002fba:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002fbc:	431a      	orrs	r2, r3
 8002fbe:	697b      	ldr	r3, [r7, #20]
 8002fc0:	601a      	str	r2, [r3, #0]

  if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 8002fc2:	683b      	ldr	r3, [r7, #0]
 8002fc4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002fc6:	2b00      	cmp	r3, #0
 8002fc8:	d009      	beq.n	8002fde <OSPI_ConfigCmd+0x132>
  {
    if (cmd->OperationType == HAL_OSPI_OPTYPE_COMMON_CFG)
 8002fca:	683b      	ldr	r3, [r7, #0]
 8002fcc:	681b      	ldr	r3, [r3, #0]
 8002fce:	2b00      	cmp	r3, #0
 8002fd0:	d105      	bne.n	8002fde <OSPI_ConfigCmd+0x132>
    {
      /* Configure the DLR register with the number of data */
      hospi->Instance->DLR = (cmd->NbData - 1U);
 8002fd2:	683b      	ldr	r3, [r7, #0]
 8002fd4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8002fd6:	687b      	ldr	r3, [r7, #4]
 8002fd8:	681b      	ldr	r3, [r3, #0]
 8002fda:	3a01      	subs	r2, #1
 8002fdc:	641a      	str	r2, [r3, #64]	; 0x40
    }
  }

  if (cmd->InstructionMode != HAL_OSPI_INSTRUCTION_NONE)
 8002fde:	683b      	ldr	r3, [r7, #0]
 8002fe0:	68db      	ldr	r3, [r3, #12]
 8002fe2:	2b00      	cmp	r3, #0
 8002fe4:	f000 8099 	beq.w	800311a <OSPI_ConfigCmd+0x26e>
  {
    if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
 8002fe8:	683b      	ldr	r3, [r7, #0]
 8002fea:	69db      	ldr	r3, [r3, #28]
 8002fec:	2b00      	cmp	r3, #0
 8002fee:	d055      	beq.n	800309c <OSPI_ConfigCmd+0x1f0>
    {
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 8002ff0:	683b      	ldr	r3, [r7, #0]
 8002ff2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002ff4:	2b00      	cmp	r3, #0
 8002ff6:	d01e      	beq.n	8003036 <OSPI_ConfigCmd+0x18a>
      {
        /* ---- Command with instruction, address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE  | OCTOSPI_CCR_IDTR  | OCTOSPI_CCR_ISIZE  |
 8002ff8:	69bb      	ldr	r3, [r7, #24]
 8002ffa:	681a      	ldr	r2, [r3, #0]
 8002ffc:	4b67      	ldr	r3, [pc, #412]	; (800319c <OSPI_ConfigCmd+0x2f0>)
 8002ffe:	4013      	ands	r3, r2
 8003000:	683a      	ldr	r2, [r7, #0]
 8003002:	68d1      	ldr	r1, [r2, #12]
 8003004:	683a      	ldr	r2, [r7, #0]
 8003006:	6952      	ldr	r2, [r2, #20]
 8003008:	4311      	orrs	r1, r2
 800300a:	683a      	ldr	r2, [r7, #0]
 800300c:	6912      	ldr	r2, [r2, #16]
 800300e:	4311      	orrs	r1, r2
 8003010:	683a      	ldr	r2, [r7, #0]
 8003012:	69d2      	ldr	r2, [r2, #28]
 8003014:	4311      	orrs	r1, r2
 8003016:	683a      	ldr	r2, [r7, #0]
 8003018:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800301a:	4311      	orrs	r1, r2
 800301c:	683a      	ldr	r2, [r7, #0]
 800301e:	6a12      	ldr	r2, [r2, #32]
 8003020:	4311      	orrs	r1, r2
 8003022:	683a      	ldr	r2, [r7, #0]
 8003024:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8003026:	4311      	orrs	r1, r2
 8003028:	683a      	ldr	r2, [r7, #0]
 800302a:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800302c:	430a      	orrs	r2, r1
 800302e:	431a      	orrs	r2, r3
 8003030:	69bb      	ldr	r3, [r7, #24]
 8003032:	601a      	str	r2, [r3, #0]
 8003034:	e028      	b.n	8003088 <OSPI_ConfigCmd+0x1dc>
      else
      {
        /* ---- Command with instruction and address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE  | OCTOSPI_CCR_IDTR  | OCTOSPI_CCR_ISIZE  |
 8003036:	69bb      	ldr	r3, [r7, #24]
 8003038:	681b      	ldr	r3, [r3, #0]
 800303a:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 800303e:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8003042:	683a      	ldr	r2, [r7, #0]
 8003044:	68d1      	ldr	r1, [r2, #12]
 8003046:	683a      	ldr	r2, [r7, #0]
 8003048:	6952      	ldr	r2, [r2, #20]
 800304a:	4311      	orrs	r1, r2
 800304c:	683a      	ldr	r2, [r7, #0]
 800304e:	6912      	ldr	r2, [r2, #16]
 8003050:	4311      	orrs	r1, r2
 8003052:	683a      	ldr	r2, [r7, #0]
 8003054:	69d2      	ldr	r2, [r2, #28]
 8003056:	4311      	orrs	r1, r2
 8003058:	683a      	ldr	r2, [r7, #0]
 800305a:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800305c:	4311      	orrs	r1, r2
 800305e:	683a      	ldr	r2, [r7, #0]
 8003060:	6a12      	ldr	r2, [r2, #32]
 8003062:	430a      	orrs	r2, r1
 8003064:	431a      	orrs	r2, r3
 8003066:	69bb      	ldr	r3, [r7, #24]
 8003068:	601a      	str	r2, [r3, #0]
                                OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE),
                   (cmd->InstructionMode | cmd->InstructionDtrMode | cmd->InstructionSize |
                    cmd->AddressMode     | cmd->AddressDtrMode     | cmd->AddressSize));

        /* The DHQC bit is linked with DDTR bit which should be activated */
        if ((hospi->Init.DelayHoldQuarterCycle == HAL_OSPI_DHQC_ENABLE) &&
 800306a:	687b      	ldr	r3, [r7, #4]
 800306c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800306e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8003072:	d109      	bne.n	8003088 <OSPI_ConfigCmd+0x1dc>
            (cmd->InstructionDtrMode == HAL_OSPI_INSTRUCTION_DTR_ENABLE))
 8003074:	683b      	ldr	r3, [r7, #0]
 8003076:	695b      	ldr	r3, [r3, #20]
        if ((hospi->Init.DelayHoldQuarterCycle == HAL_OSPI_DHQC_ENABLE) &&
 8003078:	2b08      	cmp	r3, #8
 800307a:	d105      	bne.n	8003088 <OSPI_ConfigCmd+0x1dc>
        {
          MODIFY_REG((*ccr_reg), OCTOSPI_CCR_DDTR, HAL_OSPI_DATA_DTR_ENABLE);
 800307c:	69bb      	ldr	r3, [r7, #24]
 800307e:	681b      	ldr	r3, [r3, #0]
 8003080:	f043 6200 	orr.w	r2, r3, #134217728	; 0x8000000
 8003084:	69bb      	ldr	r3, [r7, #24]
 8003086:	601a      	str	r2, [r3, #0]
        }
      }

      /* Configure the IR register with the instruction value */
      *ir_reg = cmd->Instruction;
 8003088:	683b      	ldr	r3, [r7, #0]
 800308a:	689a      	ldr	r2, [r3, #8]
 800308c:	693b      	ldr	r3, [r7, #16]
 800308e:	601a      	str	r2, [r3, #0]

      /* Configure the AR register with the address value */
      hospi->Instance->AR = cmd->Address;
 8003090:	687b      	ldr	r3, [r7, #4]
 8003092:	681b      	ldr	r3, [r3, #0]
 8003094:	683a      	ldr	r2, [r7, #0]
 8003096:	6992      	ldr	r2, [r2, #24]
 8003098:	649a      	str	r2, [r3, #72]	; 0x48
 800309a:	e078      	b.n	800318e <OSPI_ConfigCmd+0x2e2>
    }
    else
    {
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 800309c:	683b      	ldr	r3, [r7, #0]
 800309e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80030a0:	2b00      	cmp	r3, #0
 80030a2:	d017      	beq.n	80030d4 <OSPI_ConfigCmd+0x228>
      {
        /* ---- Command with instruction and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE | OCTOSPI_CCR_IDTR | OCTOSPI_CCR_ISIZE |
 80030a4:	69bb      	ldr	r3, [r7, #24]
 80030a6:	681b      	ldr	r3, [r3, #0]
 80030a8:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 80030ac:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80030b0:	683a      	ldr	r2, [r7, #0]
 80030b2:	68d1      	ldr	r1, [r2, #12]
 80030b4:	683a      	ldr	r2, [r7, #0]
 80030b6:	6952      	ldr	r2, [r2, #20]
 80030b8:	4311      	orrs	r1, r2
 80030ba:	683a      	ldr	r2, [r7, #0]
 80030bc:	6912      	ldr	r2, [r2, #16]
 80030be:	4311      	orrs	r1, r2
 80030c0:	683a      	ldr	r2, [r7, #0]
 80030c2:	6b92      	ldr	r2, [r2, #56]	; 0x38
 80030c4:	4311      	orrs	r1, r2
 80030c6:	683a      	ldr	r2, [r7, #0]
 80030c8:	6c12      	ldr	r2, [r2, #64]	; 0x40
 80030ca:	430a      	orrs	r2, r1
 80030cc:	431a      	orrs	r2, r3
 80030ce:	69bb      	ldr	r3, [r7, #24]
 80030d0:	601a      	str	r2, [r3, #0]
 80030d2:	e01d      	b.n	8003110 <OSPI_ConfigCmd+0x264>
      else
      {
        /* ---- Command with only instruction ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE | OCTOSPI_CCR_IDTR | OCTOSPI_CCR_ISIZE),
 80030d4:	69bb      	ldr	r3, [r7, #24]
 80030d6:	681b      	ldr	r3, [r3, #0]
 80030d8:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
 80030dc:	683b      	ldr	r3, [r7, #0]
 80030de:	68d9      	ldr	r1, [r3, #12]
 80030e0:	683b      	ldr	r3, [r7, #0]
 80030e2:	695b      	ldr	r3, [r3, #20]
 80030e4:	4319      	orrs	r1, r3
 80030e6:	683b      	ldr	r3, [r7, #0]
 80030e8:	691b      	ldr	r3, [r3, #16]
 80030ea:	430b      	orrs	r3, r1
 80030ec:	431a      	orrs	r2, r3
 80030ee:	69bb      	ldr	r3, [r7, #24]
 80030f0:	601a      	str	r2, [r3, #0]
                   (cmd->InstructionMode | cmd->InstructionDtrMode | cmd->InstructionSize));

        /* The DHQC bit is linked with DDTR bit which should be activated */
        if ((hospi->Init.DelayHoldQuarterCycle == HAL_OSPI_DHQC_ENABLE) &&
 80030f2:	687b      	ldr	r3, [r7, #4]
 80030f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80030f6:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 80030fa:	d109      	bne.n	8003110 <OSPI_ConfigCmd+0x264>
            (cmd->InstructionDtrMode == HAL_OSPI_INSTRUCTION_DTR_ENABLE))
 80030fc:	683b      	ldr	r3, [r7, #0]
 80030fe:	695b      	ldr	r3, [r3, #20]
        if ((hospi->Init.DelayHoldQuarterCycle == HAL_OSPI_DHQC_ENABLE) &&
 8003100:	2b08      	cmp	r3, #8
 8003102:	d105      	bne.n	8003110 <OSPI_ConfigCmd+0x264>
        {
          MODIFY_REG((*ccr_reg), OCTOSPI_CCR_DDTR, HAL_OSPI_DATA_DTR_ENABLE);
 8003104:	69bb      	ldr	r3, [r7, #24]
 8003106:	681b      	ldr	r3, [r3, #0]
 8003108:	f043 6200 	orr.w	r2, r3, #134217728	; 0x8000000
 800310c:	69bb      	ldr	r3, [r7, #24]
 800310e:	601a      	str	r2, [r3, #0]
        }
      }

      /* Configure the IR register with the instruction value */
      *ir_reg = cmd->Instruction;
 8003110:	683b      	ldr	r3, [r7, #0]
 8003112:	689a      	ldr	r2, [r3, #8]
 8003114:	693b      	ldr	r3, [r7, #16]
 8003116:	601a      	str	r2, [r3, #0]
 8003118:	e039      	b.n	800318e <OSPI_ConfigCmd+0x2e2>

    }
  }
  else
  {
    if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
 800311a:	683b      	ldr	r3, [r7, #0]
 800311c:	69db      	ldr	r3, [r3, #28]
 800311e:	2b00      	cmp	r3, #0
 8003120:	d030      	beq.n	8003184 <OSPI_ConfigCmd+0x2d8>
    {
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 8003122:	683b      	ldr	r3, [r7, #0]
 8003124:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003126:	2b00      	cmp	r3, #0
 8003128:	d017      	beq.n	800315a <OSPI_ConfigCmd+0x2ae>
      {
        /* ---- Command with address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE |
 800312a:	69bb      	ldr	r3, [r7, #24]
 800312c:	681b      	ldr	r3, [r3, #0]
 800312e:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 8003132:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 8003136:	683a      	ldr	r2, [r7, #0]
 8003138:	69d1      	ldr	r1, [r2, #28]
 800313a:	683a      	ldr	r2, [r7, #0]
 800313c:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800313e:	4311      	orrs	r1, r2
 8003140:	683a      	ldr	r2, [r7, #0]
 8003142:	6a12      	ldr	r2, [r2, #32]
 8003144:	4311      	orrs	r1, r2
 8003146:	683a      	ldr	r2, [r7, #0]
 8003148:	6b92      	ldr	r2, [r2, #56]	; 0x38
 800314a:	4311      	orrs	r1, r2
 800314c:	683a      	ldr	r2, [r7, #0]
 800314e:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8003150:	430a      	orrs	r2, r1
 8003152:	431a      	orrs	r2, r3
 8003154:	69bb      	ldr	r3, [r7, #24]
 8003156:	601a      	str	r2, [r3, #0]
 8003158:	e00e      	b.n	8003178 <OSPI_ConfigCmd+0x2cc>
      else
      {
        /* ---- Command with only address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE),
 800315a:	69bb      	ldr	r3, [r7, #24]
 800315c:	681b      	ldr	r3, [r3, #0]
 800315e:	f423 527c 	bic.w	r2, r3, #16128	; 0x3f00
 8003162:	683b      	ldr	r3, [r7, #0]
 8003164:	69d9      	ldr	r1, [r3, #28]
 8003166:	683b      	ldr	r3, [r7, #0]
 8003168:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800316a:	4319      	orrs	r1, r3
 800316c:	683b      	ldr	r3, [r7, #0]
 800316e:	6a1b      	ldr	r3, [r3, #32]
 8003170:	430b      	orrs	r3, r1
 8003172:	431a      	orrs	r2, r3
 8003174:	69bb      	ldr	r3, [r7, #24]
 8003176:	601a      	str	r2, [r3, #0]
                   (cmd->AddressMode | cmd->AddressDtrMode | cmd->AddressSize));
      }

      /* Configure the AR register with the instruction value */
      hospi->Instance->AR = cmd->Address;
 8003178:	687b      	ldr	r3, [r7, #4]
 800317a:	681b      	ldr	r3, [r3, #0]
 800317c:	683a      	ldr	r2, [r7, #0]
 800317e:	6992      	ldr	r2, [r2, #24]
 8003180:	649a      	str	r2, [r3, #72]	; 0x48
 8003182:	e004      	b.n	800318e <OSPI_ConfigCmd+0x2e2>
    }
    else
    {
      /* ---- Invalid command configuration (no instruction, no address) ---- */
      status = HAL_ERROR;
 8003184:	2301      	movs	r3, #1
 8003186:	77fb      	strb	r3, [r7, #31]
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
 8003188:	687b      	ldr	r3, [r7, #4]
 800318a:	2208      	movs	r2, #8
 800318c:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }

  /* Return function status */
  return status;
 800318e:	7ffb      	ldrb	r3, [r7, #31]
}
 8003190:	4618      	mov	r0, r3
 8003192:	3724      	adds	r7, #36	; 0x24
 8003194:	46bd      	mov	sp, r7
 8003196:	f85d 7b04 	ldr.w	r7, [sp], #4
 800319a:	4770      	bx	lr
 800319c:	f0ffc0c0 	.word	0xf0ffc0c0

080031a0 <OSPIM_GetConfig>:
  * @param  instance_nb : number of the instance
  * @param  cfg         : configuration of the IO Manager for the instance
  * @retval HAL status
  */
static HAL_StatusTypeDef OSPIM_GetConfig(uint8_t instance_nb, OSPIM_CfgTypeDef *cfg)
{
 80031a0:	b480      	push	{r7}
 80031a2:	b087      	sub	sp, #28
 80031a4:	af00      	add	r7, sp, #0
 80031a6:	4603      	mov	r3, r0
 80031a8:	6039      	str	r1, [r7, #0]
 80031aa:	71fb      	strb	r3, [r7, #7]
  HAL_StatusTypeDef status = HAL_OK;
 80031ac:	2300      	movs	r3, #0
 80031ae:	75fb      	strb	r3, [r7, #23]
  uint32_t reg;
  uint32_t value = 0U;
 80031b0:	2300      	movs	r3, #0
 80031b2:	613b      	str	r3, [r7, #16]
  uint32_t index;

  if ((instance_nb == 0U) || (instance_nb > OSPI_NB_INSTANCE) || (cfg == NULL))
 80031b4:	79fb      	ldrb	r3, [r7, #7]
 80031b6:	2b00      	cmp	r3, #0
 80031b8:	d005      	beq.n	80031c6 <OSPIM_GetConfig+0x26>
 80031ba:	79fb      	ldrb	r3, [r7, #7]
 80031bc:	2b02      	cmp	r3, #2
 80031be:	d802      	bhi.n	80031c6 <OSPIM_GetConfig+0x26>
 80031c0:	683b      	ldr	r3, [r7, #0]
 80031c2:	2b00      	cmp	r3, #0
 80031c4:	d102      	bne.n	80031cc <OSPIM_GetConfig+0x2c>
  {
    /* Invalid parameter -> error returned */
    status = HAL_ERROR;
 80031c6:	2301      	movs	r3, #1
 80031c8:	75fb      	strb	r3, [r7, #23]
 80031ca:	e098      	b.n	80032fe <OSPIM_GetConfig+0x15e>
  }
  else
  {
    /* Initialize the structure */
    cfg->ClkPort    = 0U;
 80031cc:	683b      	ldr	r3, [r7, #0]
 80031ce:	2200      	movs	r2, #0
 80031d0:	601a      	str	r2, [r3, #0]
    cfg->DQSPort    = 0U;
 80031d2:	683b      	ldr	r3, [r7, #0]
 80031d4:	2200      	movs	r2, #0
 80031d6:	605a      	str	r2, [r3, #4]
    cfg->NCSPort    = 0U;
 80031d8:	683b      	ldr	r3, [r7, #0]
 80031da:	2200      	movs	r2, #0
 80031dc:	609a      	str	r2, [r3, #8]
    cfg->IOLowPort  = 0U;
 80031de:	683b      	ldr	r3, [r7, #0]
 80031e0:	2200      	movs	r2, #0
 80031e2:	60da      	str	r2, [r3, #12]
    cfg->IOHighPort = 0U;
 80031e4:	683b      	ldr	r3, [r7, #0]
 80031e6:	2200      	movs	r2, #0
 80031e8:	611a      	str	r2, [r3, #16]

    if (instance_nb == 2U)
 80031ea:	79fb      	ldrb	r3, [r7, #7]
 80031ec:	2b02      	cmp	r3, #2
 80031ee:	d10b      	bne.n	8003208 <OSPIM_GetConfig+0x68>
    {
      if ((OCTOSPIM->CR & OCTOSPIM_CR_MUXEN) == 0U)
 80031f0:	4b46      	ldr	r3, [pc, #280]	; (800330c <OSPIM_GetConfig+0x16c>)
 80031f2:	681b      	ldr	r3, [r3, #0]
 80031f4:	f003 0301 	and.w	r3, r3, #1
 80031f8:	2b00      	cmp	r3, #0
 80031fa:	d102      	bne.n	8003202 <OSPIM_GetConfig+0x62>
      {
        value = (OCTOSPIM_PCR_CLKSRC | OCTOSPIM_PCR_DQSSRC | OCTOSPIM_PCR_NCSSRC
 80031fc:	4b44      	ldr	r3, [pc, #272]	; (8003310 <OSPIM_GetConfig+0x170>)
 80031fe:	613b      	str	r3, [r7, #16]
 8003200:	e002      	b.n	8003208 <OSPIM_GetConfig+0x68>
                 | OCTOSPIM_PCR_IOLSRC_1 | OCTOSPIM_PCR_IOHSRC_1);
      }
      else
      {
        value = OCTOSPIM_PCR_NCSSRC;
 8003202:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003206:	613b      	str	r3, [r7, #16]
      }
    }

    /* Get the information about the instance */
    for (index = 0U; index < OSPI_IOM_NB_PORTS; index ++)
 8003208:	2300      	movs	r3, #0
 800320a:	60fb      	str	r3, [r7, #12]
 800320c:	e074      	b.n	80032f8 <OSPIM_GetConfig+0x158>
    {
      reg = OCTOSPIM->PCR[index];
 800320e:	4a3f      	ldr	r2, [pc, #252]	; (800330c <OSPIM_GetConfig+0x16c>)
 8003210:	68fb      	ldr	r3, [r7, #12]
 8003212:	009b      	lsls	r3, r3, #2
 8003214:	4413      	add	r3, r2
 8003216:	685b      	ldr	r3, [r3, #4]
 8003218:	60bb      	str	r3, [r7, #8]

      if ((reg & OCTOSPIM_PCR_CLKEN) != 0U)
 800321a:	68bb      	ldr	r3, [r7, #8]
 800321c:	f003 0301 	and.w	r3, r3, #1
 8003220:	2b00      	cmp	r3, #0
 8003222:	d00a      	beq.n	800323a <OSPIM_GetConfig+0x9a>
      {
        /* The clock is enabled on this port */
        if ((reg & OCTOSPIM_PCR_CLKSRC) == (value & OCTOSPIM_PCR_CLKSRC))
 8003224:	68ba      	ldr	r2, [r7, #8]
 8003226:	693b      	ldr	r3, [r7, #16]
 8003228:	4053      	eors	r3, r2
 800322a:	f003 0302 	and.w	r3, r3, #2
 800322e:	2b00      	cmp	r3, #0
 8003230:	d103      	bne.n	800323a <OSPIM_GetConfig+0x9a>
        {
          /* The clock correspond to the instance passed as parameter */
          cfg->ClkPort = index + 1U;
 8003232:	68fb      	ldr	r3, [r7, #12]
 8003234:	1c5a      	adds	r2, r3, #1
 8003236:	683b      	ldr	r3, [r7, #0]
 8003238:	601a      	str	r2, [r3, #0]
        }
      }

      if ((reg & OCTOSPIM_PCR_DQSEN) != 0U)
 800323a:	68bb      	ldr	r3, [r7, #8]
 800323c:	f003 0310 	and.w	r3, r3, #16
 8003240:	2b00      	cmp	r3, #0
 8003242:	d00a      	beq.n	800325a <OSPIM_GetConfig+0xba>
      {
        /* The DQS is enabled on this port */
        if ((reg & OCTOSPIM_PCR_DQSSRC) == (value & OCTOSPIM_PCR_DQSSRC))
 8003244:	68ba      	ldr	r2, [r7, #8]
 8003246:	693b      	ldr	r3, [r7, #16]
 8003248:	4053      	eors	r3, r2
 800324a:	f003 0320 	and.w	r3, r3, #32
 800324e:	2b00      	cmp	r3, #0
 8003250:	d103      	bne.n	800325a <OSPIM_GetConfig+0xba>
        {
          /* The DQS correspond to the instance passed as parameter */
          cfg->DQSPort = index + 1U;
 8003252:	68fb      	ldr	r3, [r7, #12]
 8003254:	1c5a      	adds	r2, r3, #1
 8003256:	683b      	ldr	r3, [r7, #0]
 8003258:	605a      	str	r2, [r3, #4]
        }
      }

      if ((reg & OCTOSPIM_PCR_NCSEN) != 0U)
 800325a:	68bb      	ldr	r3, [r7, #8]
 800325c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8003260:	2b00      	cmp	r3, #0
 8003262:	d00a      	beq.n	800327a <OSPIM_GetConfig+0xda>
      {
        /* The nCS is enabled on this port */
        if ((reg & OCTOSPIM_PCR_NCSSRC) == (value & OCTOSPIM_PCR_NCSSRC))
 8003264:	68ba      	ldr	r2, [r7, #8]
 8003266:	693b      	ldr	r3, [r7, #16]
 8003268:	4053      	eors	r3, r2
 800326a:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800326e:	2b00      	cmp	r3, #0
 8003270:	d103      	bne.n	800327a <OSPIM_GetConfig+0xda>
        {
          /* The nCS correspond to the instance passed as parameter */
          cfg->NCSPort = index + 1U;
 8003272:	68fb      	ldr	r3, [r7, #12]
 8003274:	1c5a      	adds	r2, r3, #1
 8003276:	683b      	ldr	r3, [r7, #0]
 8003278:	609a      	str	r2, [r3, #8]
        }
      }

      if ((reg & OCTOSPIM_PCR_IOLEN) != 0U)
 800327a:	68bb      	ldr	r3, [r7, #8]
 800327c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8003280:	2b00      	cmp	r3, #0
 8003282:	d018      	beq.n	80032b6 <OSPIM_GetConfig+0x116>
      {
        /* The IO Low is enabled on this port */
        if ((reg & OCTOSPIM_PCR_IOLSRC_1) == (value & OCTOSPIM_PCR_IOLSRC_1))
 8003284:	68ba      	ldr	r2, [r7, #8]
 8003286:	693b      	ldr	r3, [r7, #16]
 8003288:	4053      	eors	r3, r2
 800328a:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800328e:	2b00      	cmp	r3, #0
 8003290:	d111      	bne.n	80032b6 <OSPIM_GetConfig+0x116>
        {
          /* The IO Low correspond to the instance passed as parameter */
          if ((reg & OCTOSPIM_PCR_IOLSRC_0) == 0U)
 8003292:	68bb      	ldr	r3, [r7, #8]
 8003294:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003298:	2b00      	cmp	r3, #0
 800329a:	d106      	bne.n	80032aa <OSPIM_GetConfig+0x10a>
          {
            cfg->IOLowPort = (OCTOSPIM_PCR_IOLEN | (index + 1U));
 800329c:	68fb      	ldr	r3, [r7, #12]
 800329e:	3301      	adds	r3, #1
 80032a0:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 80032a4:	683b      	ldr	r3, [r7, #0]
 80032a6:	60da      	str	r2, [r3, #12]
 80032a8:	e005      	b.n	80032b6 <OSPIM_GetConfig+0x116>
          }
          else
          {
            cfg->IOLowPort = (OCTOSPIM_PCR_IOHEN | (index + 1U));
 80032aa:	68fb      	ldr	r3, [r7, #12]
 80032ac:	3301      	adds	r3, #1
 80032ae:	f043 7280 	orr.w	r2, r3, #16777216	; 0x1000000
 80032b2:	683b      	ldr	r3, [r7, #0]
 80032b4:	60da      	str	r2, [r3, #12]
          }
        }
      }

      if ((reg & OCTOSPIM_PCR_IOHEN) != 0U)
 80032b6:	68bb      	ldr	r3, [r7, #8]
 80032b8:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80032bc:	2b00      	cmp	r3, #0
 80032be:	d018      	beq.n	80032f2 <OSPIM_GetConfig+0x152>
      {
        /* The IO High is enabled on this port */
        if ((reg & OCTOSPIM_PCR_IOHSRC_1) == (value & OCTOSPIM_PCR_IOHSRC_1))
 80032c0:	68ba      	ldr	r2, [r7, #8]
 80032c2:	693b      	ldr	r3, [r7, #16]
 80032c4:	4053      	eors	r3, r2
 80032c6:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 80032ca:	2b00      	cmp	r3, #0
 80032cc:	d111      	bne.n	80032f2 <OSPIM_GetConfig+0x152>
        {
          /* The IO High correspond to the instance passed as parameter */
          if ((reg & OCTOSPIM_PCR_IOHSRC_0) == 0U)
 80032ce:	68bb      	ldr	r3, [r7, #8]
 80032d0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80032d4:	2b00      	cmp	r3, #0
 80032d6:	d106      	bne.n	80032e6 <OSPIM_GetConfig+0x146>
          {
            cfg->IOHighPort = (OCTOSPIM_PCR_IOLEN | (index + 1U));
 80032d8:	68fb      	ldr	r3, [r7, #12]
 80032da:	3301      	adds	r3, #1
 80032dc:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 80032e0:	683b      	ldr	r3, [r7, #0]
 80032e2:	611a      	str	r2, [r3, #16]
 80032e4:	e005      	b.n	80032f2 <OSPIM_GetConfig+0x152>
          }
          else
          {
            cfg->IOHighPort = (OCTOSPIM_PCR_IOHEN | (index + 1U));
 80032e6:	68fb      	ldr	r3, [r7, #12]
 80032e8:	3301      	adds	r3, #1
 80032ea:	f043 7280 	orr.w	r2, r3, #16777216	; 0x1000000
 80032ee:	683b      	ldr	r3, [r7, #0]
 80032f0:	611a      	str	r2, [r3, #16]
    for (index = 0U; index < OSPI_IOM_NB_PORTS; index ++)
 80032f2:	68fb      	ldr	r3, [r7, #12]
 80032f4:	3301      	adds	r3, #1
 80032f6:	60fb      	str	r3, [r7, #12]
 80032f8:	68fb      	ldr	r3, [r7, #12]
 80032fa:	2b01      	cmp	r3, #1
 80032fc:	d987      	bls.n	800320e <OSPIM_GetConfig+0x6e>
      }
    }
  }

  /* Return function status */
  return status;
 80032fe:	7dfb      	ldrb	r3, [r7, #23]
}
 8003300:	4618      	mov	r0, r3
 8003302:	371c      	adds	r7, #28
 8003304:	46bd      	mov	sp, r7
 8003306:	f85d 7b04 	ldr.w	r7, [sp], #4
 800330a:	4770      	bx	lr
 800330c:	420c4000 	.word	0x420c4000
 8003310:	04040222 	.word	0x04040222

08003314 <HAL_OSPI_DLYB_SetConfig>:
  * @param  hospi   : OSPI handle.
  * @param  pdlyb_cfg: Pointer to DLYB configuration structure.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_OSPI_DLYB_SetConfig(OSPI_HandleTypeDef *hospi, HAL_OSPI_DLYB_CfgTypeDef  *pdlyb_cfg)
{
 8003314:	b580      	push	{r7, lr}
 8003316:	b084      	sub	sp, #16
 8003318:	af00      	add	r7, sp, #0
 800331a:	6078      	str	r0, [r7, #4]
 800331c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_ERROR;
 800331e:	2301      	movs	r3, #1
 8003320:	73fb      	strb	r3, [r7, #15]

  /* Enable OCTOSPI Free Running Clock (mandatory) */
  SET_BIT(hospi->Instance->DCR1, OCTOSPI_DCR1_FRCK);
 8003322:	687b      	ldr	r3, [r7, #4]
 8003324:	681b      	ldr	r3, [r3, #0]
 8003326:	689a      	ldr	r2, [r3, #8]
 8003328:	687b      	ldr	r3, [r7, #4]
 800332a:	681b      	ldr	r3, [r3, #0]
 800332c:	f042 0202 	orr.w	r2, r2, #2
 8003330:	609a      	str	r2, [r3, #8]

  /* Update OCTOSPI state */
  hospi->State = HAL_OSPI_STATE_BUSY_CMD;
 8003332:	687b      	ldr	r3, [r7, #4]
 8003334:	2208      	movs	r2, #8
 8003336:	651a      	str	r2, [r3, #80]	; 0x50

  if (hospi->Instance == OCTOSPI1)
 8003338:	687b      	ldr	r3, [r7, #4]
 800333a:	681b      	ldr	r3, [r3, #0]
 800333c:	4a15      	ldr	r2, [pc, #84]	; (8003394 <HAL_OSPI_DLYB_SetConfig+0x80>)
 800333e:	4293      	cmp	r3, r2
 8003340:	d109      	bne.n	8003356 <HAL_OSPI_DLYB_SetConfig+0x42>
  {
    /* Enable the DelayBlock */
    LL_DLYB_Enable(DLYB_OCTOSPI1);
 8003342:	4815      	ldr	r0, [pc, #84]	; (8003398 <HAL_OSPI_DLYB_SetConfig+0x84>)
 8003344:	f7fe fb96 	bl	8001a74 <LL_DLYB_Enable>

    /* Set the Delay Block configuration */
    LL_DLYB_SetDelay(DLYB_OCTOSPI1, pdlyb_cfg);
 8003348:	6839      	ldr	r1, [r7, #0]
 800334a:	4813      	ldr	r0, [pc, #76]	; (8003398 <HAL_OSPI_DLYB_SetConfig+0x84>)
 800334c:	f002 fa76 	bl	800583c <LL_DLYB_SetDelay>
    status = HAL_OK;
 8003350:	2300      	movs	r3, #0
 8003352:	73fb      	strb	r3, [r7, #15]
 8003354:	e00d      	b.n	8003372 <HAL_OSPI_DLYB_SetConfig+0x5e>
  }

#if defined (OCTOSPI2)
  else if (hospi->Instance == OCTOSPI2)
 8003356:	687b      	ldr	r3, [r7, #4]
 8003358:	681b      	ldr	r3, [r3, #0]
 800335a:	4a10      	ldr	r2, [pc, #64]	; (800339c <HAL_OSPI_DLYB_SetConfig+0x88>)
 800335c:	4293      	cmp	r3, r2
 800335e:	d108      	bne.n	8003372 <HAL_OSPI_DLYB_SetConfig+0x5e>
  {
    /* Enable the DelayBlock */
    LL_DLYB_Enable(DLYB_OCTOSPI2);
 8003360:	480f      	ldr	r0, [pc, #60]	; (80033a0 <HAL_OSPI_DLYB_SetConfig+0x8c>)
 8003362:	f7fe fb87 	bl	8001a74 <LL_DLYB_Enable>

    /* Set the Delay Block configuration */
    LL_DLYB_SetDelay(DLYB_OCTOSPI2, pdlyb_cfg);
 8003366:	6839      	ldr	r1, [r7, #0]
 8003368:	480d      	ldr	r0, [pc, #52]	; (80033a0 <HAL_OSPI_DLYB_SetConfig+0x8c>)
 800336a:	f002 fa67 	bl	800583c <LL_DLYB_SetDelay>
    status = HAL_OK;
 800336e:	2300      	movs	r3, #0
 8003370:	73fb      	strb	r3, [r7, #15]
  {
    /* Nothing to do */
  }

  /* Abort the current OCTOSPI operation if exist */
  (void)HAL_OSPI_Abort(hospi);
 8003372:	6878      	ldr	r0, [r7, #4]
 8003374:	f7fe ffa7 	bl	80022c6 <HAL_OSPI_Abort>

  /* Disable Free Running Clock */
  CLEAR_BIT(hospi->Instance->DCR1, OCTOSPI_DCR1_FRCK);
 8003378:	687b      	ldr	r3, [r7, #4]
 800337a:	681b      	ldr	r3, [r3, #0]
 800337c:	689a      	ldr	r2, [r3, #8]
 800337e:	687b      	ldr	r3, [r7, #4]
 8003380:	681b      	ldr	r3, [r3, #0]
 8003382:	f022 0202 	bic.w	r2, r2, #2
 8003386:	609a      	str	r2, [r3, #8]

  /* Return function status */
  return status;
 8003388:	7bfb      	ldrb	r3, [r7, #15]
}
 800338a:	4618      	mov	r0, r3
 800338c:	3710      	adds	r7, #16
 800338e:	46bd      	mov	sp, r7
 8003390:	bd80      	pop	{r7, pc}
 8003392:	bf00      	nop
 8003394:	420d1400 	.word	0x420d1400
 8003398:	420cf000 	.word	0x420cf000
 800339c:	420d2400 	.word	0x420d2400
 80033a0:	420cf400 	.word	0x420cf400

080033a4 <HAL_PWREx_ControlVoltageScaling>:
  * @note  Before moving to voltage scaling 4, it is mandatory to ensure that
  *        the system frequency is below 24 MHz.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 80033a4:	b480      	push	{r7}
 80033a6:	b085      	sub	sp, #20
 80033a8:	af00      	add	r7, sp, #0
 80033aa:	6078      	str	r0, [r7, #4]

  /* Check the parameter */
  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));

  /* Get the current voltage scale applied */
  vos_old = READ_BIT(PWR->SVMSR, PWR_SVMSR_ACTVOS);
 80033ac:	4b39      	ldr	r3, [pc, #228]	; (8003494 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 80033ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80033b0:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 80033b4:	60bb      	str	r3, [r7, #8]

  /* No change, nothing to do */
  if (vos_old == VoltageScaling)
 80033b6:	68ba      	ldr	r2, [r7, #8]
 80033b8:	687b      	ldr	r3, [r7, #4]
 80033ba:	429a      	cmp	r2, r3
 80033bc:	d10b      	bne.n	80033d6 <HAL_PWREx_ControlVoltageScaling+0x32>
  {
    /* Enable USB BOOST after wake up from Stop mode */
    if (VoltageScaling > PWR_REGULATOR_VOLTAGE_SCALE3)
 80033be:	687b      	ldr	r3, [r7, #4]
 80033c0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80033c4:	d905      	bls.n	80033d2 <HAL_PWREx_ControlVoltageScaling+0x2e>
    {
      /* Enable USB BOOST */
      SET_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN);
 80033c6:	4b33      	ldr	r3, [pc, #204]	; (8003494 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 80033c8:	68db      	ldr	r3, [r3, #12]
 80033ca:	4a32      	ldr	r2, [pc, #200]	; (8003494 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 80033cc:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80033d0:	60d3      	str	r3, [r2, #12]
    }

    return HAL_OK;
 80033d2:	2300      	movs	r3, #0
 80033d4:	e057      	b.n	8003486 <HAL_PWREx_ControlVoltageScaling+0xe2>
  /* Check voltage scaling level */
  /*
   *  The Embedded power distribution (EPOD) must be enabled before switching to
   *  voltage scale 1 / 2 from voltage scale lower.
   */
  if (VoltageScaling > PWR_REGULATOR_VOLTAGE_SCALE3)
 80033d6:	687b      	ldr	r3, [r7, #4]
 80033d8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80033dc:	d90a      	bls.n	80033f4 <HAL_PWREx_ControlVoltageScaling+0x50>
  {
    MODIFY_REG(PWR->VOSR, (PWR_VOSR_VOS | PWR_VOSR_BOOSTEN), (VoltageScaling | PWR_VOSR_BOOSTEN));
 80033de:	4b2d      	ldr	r3, [pc, #180]	; (8003494 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 80033e0:	68db      	ldr	r3, [r3, #12]
 80033e2:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
 80033e6:	687b      	ldr	r3, [r7, #4]
 80033e8:	4313      	orrs	r3, r2
 80033ea:	4a2a      	ldr	r2, [pc, #168]	; (8003494 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 80033ec:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80033f0:	60d3      	str	r3, [r2, #12]
 80033f2:	e007      	b.n	8003404 <HAL_PWREx_ControlVoltageScaling+0x60>
  }
  else
  {
    MODIFY_REG(PWR->VOSR, (PWR_VOSR_VOS | PWR_VOSR_BOOSTEN), VoltageScaling);
 80033f4:	4b27      	ldr	r3, [pc, #156]	; (8003494 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 80033f6:	68db      	ldr	r3, [r3, #12]
 80033f8:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
 80033fc:	4925      	ldr	r1, [pc, #148]	; (8003494 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 80033fe:	687b      	ldr	r3, [r7, #4]
 8003400:	4313      	orrs	r3, r2
 8003402:	60cb      	str	r3, [r1, #12]
  }

  /* Wait until VOSRDY is raised */
  timeout = ((PWR_FLAG_SETTING_DELAY * (SystemCoreClock / 1000U)) / 1000U) + 1U;
 8003404:	4b24      	ldr	r3, [pc, #144]	; (8003498 <HAL_PWREx_ControlVoltageScaling+0xf4>)
 8003406:	681b      	ldr	r3, [r3, #0]
 8003408:	4a24      	ldr	r2, [pc, #144]	; (800349c <HAL_PWREx_ControlVoltageScaling+0xf8>)
 800340a:	fba2 2303 	umull	r2, r3, r2, r3
 800340e:	099b      	lsrs	r3, r3, #6
 8003410:	2232      	movs	r2, #50	; 0x32
 8003412:	fb02 f303 	mul.w	r3, r2, r3
 8003416:	4a21      	ldr	r2, [pc, #132]	; (800349c <HAL_PWREx_ControlVoltageScaling+0xf8>)
 8003418:	fba2 2303 	umull	r2, r3, r2, r3
 800341c:	099b      	lsrs	r3, r3, #6
 800341e:	3301      	adds	r3, #1
 8003420:	60fb      	str	r3, [r7, #12]
  while (HAL_IS_BIT_CLR(PWR->VOSR, PWR_VOSR_VOSRDY) && (timeout != 0U))
 8003422:	e002      	b.n	800342a <HAL_PWREx_ControlVoltageScaling+0x86>
  {
    timeout--;
 8003424:	68fb      	ldr	r3, [r7, #12]
 8003426:	3b01      	subs	r3, #1
 8003428:	60fb      	str	r3, [r7, #12]
  while (HAL_IS_BIT_CLR(PWR->VOSR, PWR_VOSR_VOSRDY) && (timeout != 0U))
 800342a:	4b1a      	ldr	r3, [pc, #104]	; (8003494 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 800342c:	68db      	ldr	r3, [r3, #12]
 800342e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8003432:	2b00      	cmp	r3, #0
 8003434:	d102      	bne.n	800343c <HAL_PWREx_ControlVoltageScaling+0x98>
 8003436:	68fb      	ldr	r3, [r7, #12]
 8003438:	2b00      	cmp	r3, #0
 800343a:	d1f3      	bne.n	8003424 <HAL_PWREx_ControlVoltageScaling+0x80>
  }

  /* Check time out */
  if (timeout != 0U)
 800343c:	68fb      	ldr	r3, [r7, #12]
 800343e:	2b00      	cmp	r3, #0
 8003440:	d01b      	beq.n	800347a <HAL_PWREx_ControlVoltageScaling+0xd6>
  {
    /* Wait until ACTVOSRDY is raised */
    timeout = ((PWR_FLAG_SETTING_DELAY * (SystemCoreClock / 1000U)) / 1000U) + 1U;
 8003442:	4b15      	ldr	r3, [pc, #84]	; (8003498 <HAL_PWREx_ControlVoltageScaling+0xf4>)
 8003444:	681b      	ldr	r3, [r3, #0]
 8003446:	4a15      	ldr	r2, [pc, #84]	; (800349c <HAL_PWREx_ControlVoltageScaling+0xf8>)
 8003448:	fba2 2303 	umull	r2, r3, r2, r3
 800344c:	099b      	lsrs	r3, r3, #6
 800344e:	2232      	movs	r2, #50	; 0x32
 8003450:	fb02 f303 	mul.w	r3, r2, r3
 8003454:	4a11      	ldr	r2, [pc, #68]	; (800349c <HAL_PWREx_ControlVoltageScaling+0xf8>)
 8003456:	fba2 2303 	umull	r2, r3, r2, r3
 800345a:	099b      	lsrs	r3, r3, #6
 800345c:	3301      	adds	r3, #1
 800345e:	60fb      	str	r3, [r7, #12]
    while ((HAL_IS_BIT_CLR(PWR->SVMSR, PWR_SVMSR_ACTVOSRDY)) && (timeout != 0U))
 8003460:	e002      	b.n	8003468 <HAL_PWREx_ControlVoltageScaling+0xc4>
    {
      timeout--;
 8003462:	68fb      	ldr	r3, [r7, #12]
 8003464:	3b01      	subs	r3, #1
 8003466:	60fb      	str	r3, [r7, #12]
    while ((HAL_IS_BIT_CLR(PWR->SVMSR, PWR_SVMSR_ACTVOSRDY)) && (timeout != 0U))
 8003468:	4b0a      	ldr	r3, [pc, #40]	; (8003494 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 800346a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800346c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8003470:	2b00      	cmp	r3, #0
 8003472:	d102      	bne.n	800347a <HAL_PWREx_ControlVoltageScaling+0xd6>
 8003474:	68fb      	ldr	r3, [r7, #12]
 8003476:	2b00      	cmp	r3, #0
 8003478:	d1f3      	bne.n	8003462 <HAL_PWREx_ControlVoltageScaling+0xbe>
    }
  }

  /* Check time out */
  if (timeout == 0U)
 800347a:	68fb      	ldr	r3, [r7, #12]
 800347c:	2b00      	cmp	r3, #0
 800347e:	d101      	bne.n	8003484 <HAL_PWREx_ControlVoltageScaling+0xe0>
  {
    return HAL_TIMEOUT;
 8003480:	2303      	movs	r3, #3
 8003482:	e000      	b.n	8003486 <HAL_PWREx_ControlVoltageScaling+0xe2>
  }

  return HAL_OK;
 8003484:	2300      	movs	r3, #0
}
 8003486:	4618      	mov	r0, r3
 8003488:	3714      	adds	r7, #20
 800348a:	46bd      	mov	sp, r7
 800348c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003490:	4770      	bx	lr
 8003492:	bf00      	nop
 8003494:	46020800 	.word	0x46020800
 8003498:	20000008 	.word	0x20000008
 800349c:	10624dd3 	.word	0x10624dd3

080034a0 <HAL_PWREx_GetVoltageRange>:
/**
  * @brief  Return Voltage Scaling Range.
  * @retval Applied voltage scaling value.
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
 80034a0:	b480      	push	{r7}
 80034a2:	af00      	add	r7, sp, #0
  return (PWR->SVMSR & PWR_SVMSR_ACTVOS);
 80034a4:	4b04      	ldr	r3, [pc, #16]	; (80034b8 <HAL_PWREx_GetVoltageRange+0x18>)
 80034a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80034a8:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
}
 80034ac:	4618      	mov	r0, r3
 80034ae:	46bd      	mov	sp, r7
 80034b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80034b4:	4770      	bx	lr
 80034b6:	bf00      	nop
 80034b8:	46020800 	.word	0x46020800

080034bc <HAL_PWREx_ConfigSupply>:
  *                        @arg PWR_LDO_SUPPLY  : The LDO regulator supplies the Vcore Power Domains.
  *                        @arg PWR_SMPS_SUPPLY : The SMPS regulator supplies the Vcore Power Domains.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply(uint32_t SupplySource)
{
 80034bc:	b480      	push	{r7}
 80034be:	b085      	sub	sp, #20
 80034c0:	af00      	add	r7, sp, #0
 80034c2:	6078      	str	r0, [r7, #4]

  /* Check the parameter */
  assert_param(IS_PWR_SUPPLY(SupplySource));

  /* Set maximum time out */
  timeout = ((PWR_FLAG_SETTING_DELAY * (SystemCoreClock / 1000U)) / 1000U) + 1U;
 80034c4:	4b22      	ldr	r3, [pc, #136]	; (8003550 <HAL_PWREx_ConfigSupply+0x94>)
 80034c6:	681b      	ldr	r3, [r3, #0]
 80034c8:	4a22      	ldr	r2, [pc, #136]	; (8003554 <HAL_PWREx_ConfigSupply+0x98>)
 80034ca:	fba2 2303 	umull	r2, r3, r2, r3
 80034ce:	099b      	lsrs	r3, r3, #6
 80034d0:	2232      	movs	r2, #50	; 0x32
 80034d2:	fb02 f303 	mul.w	r3, r2, r3
 80034d6:	4a1f      	ldr	r2, [pc, #124]	; (8003554 <HAL_PWREx_ConfigSupply+0x98>)
 80034d8:	fba2 2303 	umull	r2, r3, r2, r3
 80034dc:	099b      	lsrs	r3, r3, #6
 80034de:	3301      	adds	r3, #1
 80034e0:	60fb      	str	r3, [r7, #12]

  /* Configure the LDO as system regulator supply */
  if (SupplySource == PWR_LDO_SUPPLY)
 80034e2:	687b      	ldr	r3, [r7, #4]
 80034e4:	2b00      	cmp	r3, #0
 80034e6:	d113      	bne.n	8003510 <HAL_PWREx_ConfigSupply+0x54>
  {
    /* Set the power supply configuration */
    CLEAR_BIT(PWR->CR3, PWR_CR3_REGSEL);
 80034e8:	4b1b      	ldr	r3, [pc, #108]	; (8003558 <HAL_PWREx_ConfigSupply+0x9c>)
 80034ea:	689b      	ldr	r3, [r3, #8]
 80034ec:	4a1a      	ldr	r2, [pc, #104]	; (8003558 <HAL_PWREx_ConfigSupply+0x9c>)
 80034ee:	f023 0302 	bic.w	r3, r3, #2
 80034f2:	6093      	str	r3, [r2, #8]

    /* Wait until system switch on new regulator */
    while (HAL_IS_BIT_SET(PWR->SVMSR, PWR_SVMSR_REGS) && (timeout != 0U))
 80034f4:	e002      	b.n	80034fc <HAL_PWREx_ConfigSupply+0x40>
    {
      timeout--;
 80034f6:	68fb      	ldr	r3, [r7, #12]
 80034f8:	3b01      	subs	r3, #1
 80034fa:	60fb      	str	r3, [r7, #12]
    while (HAL_IS_BIT_SET(PWR->SVMSR, PWR_SVMSR_REGS) && (timeout != 0U))
 80034fc:	4b16      	ldr	r3, [pc, #88]	; (8003558 <HAL_PWREx_ConfigSupply+0x9c>)
 80034fe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8003500:	f003 0302 	and.w	r3, r3, #2
 8003504:	2b02      	cmp	r3, #2
 8003506:	d116      	bne.n	8003536 <HAL_PWREx_ConfigSupply+0x7a>
 8003508:	68fb      	ldr	r3, [r7, #12]
 800350a:	2b00      	cmp	r3, #0
 800350c:	d1f3      	bne.n	80034f6 <HAL_PWREx_ConfigSupply+0x3a>
 800350e:	e012      	b.n	8003536 <HAL_PWREx_ConfigSupply+0x7a>
  }
  /* Configure the SMPS as system regulator supply */
  else
  {
    /* Set the power supply configuration */
    SET_BIT(PWR->CR3, PWR_CR3_REGSEL);
 8003510:	4b11      	ldr	r3, [pc, #68]	; (8003558 <HAL_PWREx_ConfigSupply+0x9c>)
 8003512:	689b      	ldr	r3, [r3, #8]
 8003514:	4a10      	ldr	r2, [pc, #64]	; (8003558 <HAL_PWREx_ConfigSupply+0x9c>)
 8003516:	f043 0302 	orr.w	r3, r3, #2
 800351a:	6093      	str	r3, [r2, #8]

    /* Wait until system switch on new regulator */
    while (HAL_IS_BIT_CLR(PWR->SVMSR, PWR_SVMSR_REGS) && (timeout != 0U))
 800351c:	e002      	b.n	8003524 <HAL_PWREx_ConfigSupply+0x68>
    {
      timeout--;
 800351e:	68fb      	ldr	r3, [r7, #12]
 8003520:	3b01      	subs	r3, #1
 8003522:	60fb      	str	r3, [r7, #12]
    while (HAL_IS_BIT_CLR(PWR->SVMSR, PWR_SVMSR_REGS) && (timeout != 0U))
 8003524:	4b0c      	ldr	r3, [pc, #48]	; (8003558 <HAL_PWREx_ConfigSupply+0x9c>)
 8003526:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8003528:	f003 0302 	and.w	r3, r3, #2
 800352c:	2b00      	cmp	r3, #0
 800352e:	d102      	bne.n	8003536 <HAL_PWREx_ConfigSupply+0x7a>
 8003530:	68fb      	ldr	r3, [r7, #12]
 8003532:	2b00      	cmp	r3, #0
 8003534:	d1f3      	bne.n	800351e <HAL_PWREx_ConfigSupply+0x62>
    }
  }

  /* Check time out */
  if (timeout == 0U)
 8003536:	68fb      	ldr	r3, [r7, #12]
 8003538:	2b00      	cmp	r3, #0
 800353a:	d101      	bne.n	8003540 <HAL_PWREx_ConfigSupply+0x84>
  {
    return HAL_TIMEOUT;
 800353c:	2303      	movs	r3, #3
 800353e:	e000      	b.n	8003542 <HAL_PWREx_ConfigSupply+0x86>
  }

  return HAL_OK;
 8003540:	2300      	movs	r3, #0
}
 8003542:	4618      	mov	r0, r3
 8003544:	3714      	adds	r7, #20
 8003546:	46bd      	mov	sp, r7
 8003548:	f85d 7b04 	ldr.w	r7, [sp], #4
 800354c:	4770      	bx	lr
 800354e:	bf00      	nop
 8003550:	20000008 	.word	0x20000008
 8003554:	10624dd3 	.word	0x10624dd3
 8003558:	46020800 	.word	0x46020800

0800355c <HAL_PWREx_DisableUCPDDeadBattery>:
  *         pull-down or to handover control to the UCPD (the UCPD must be
  *         initialized before doing the disable).
  * @retval None.
  */
void HAL_PWREx_DisableUCPDDeadBattery(void)
{
 800355c:	b480      	push	{r7}
 800355e:	af00      	add	r7, sp, #0
  SET_BIT(PWR->UCPDR, PWR_UCPDR_UCPD_DBDIS);
 8003560:	4b05      	ldr	r3, [pc, #20]	; (8003578 <HAL_PWREx_DisableUCPDDeadBattery+0x1c>)
 8003562:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003564:	4a04      	ldr	r2, [pc, #16]	; (8003578 <HAL_PWREx_DisableUCPDDeadBattery+0x1c>)
 8003566:	f043 0301 	orr.w	r3, r3, #1
 800356a:	62d3      	str	r3, [r2, #44]	; 0x2c
}
 800356c:	bf00      	nop
 800356e:	46bd      	mov	sp, r7
 8003570:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003574:	4770      	bx	lr
 8003576:	bf00      	nop
 8003578:	46020800 	.word	0x46020800

0800357c <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *pRCC_OscInitStruct)
{
 800357c:	b580      	push	{r7, lr}
 800357e:	b08e      	sub	sp, #56	; 0x38
 8003580:	af00      	add	r7, sp, #0
 8003582:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source;
  uint32_t pll_config;
  FlagStatus pwrboosten = RESET;
 8003584:	2300      	movs	r3, #0
 8003586:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
  uint32_t temp1_pllckcfg;
  uint32_t temp2_pllckcfg;

  /* Check Null pointer */
  if (pRCC_OscInitStruct == NULL)
 800358a:	687b      	ldr	r3, [r7, #4]
 800358c:	2b00      	cmp	r3, #0
 800358e:	d102      	bne.n	8003596 <HAL_RCC_OscConfig+0x1a>
  {
    return HAL_ERROR;
 8003590:	2301      	movs	r3, #1
 8003592:	f000 bec8 	b.w	8004326 <HAL_RCC_OscConfig+0xdaa>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(pRCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8003596:	4b99      	ldr	r3, [pc, #612]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 8003598:	69db      	ldr	r3, [r3, #28]
 800359a:	f003 030c 	and.w	r3, r3, #12
 800359e:	633b      	str	r3, [r7, #48]	; 0x30
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 80035a0:	4b96      	ldr	r3, [pc, #600]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80035a2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80035a4:	f003 0303 	and.w	r3, r3, #3
 80035a8:	62fb      	str	r3, [r7, #44]	; 0x2c

  /*----------------------------- MSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80035aa:	687b      	ldr	r3, [r7, #4]
 80035ac:	681b      	ldr	r3, [r3, #0]
 80035ae:	f003 0310 	and.w	r3, r3, #16
 80035b2:	2b00      	cmp	r3, #0
 80035b4:	f000 816c 	beq.w	8003890 <HAL_RCC_OscConfig+0x314>
    assert_param(IS_RCC_MSICALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(pRCC_OscInitStruct->MSIClockRange));

    /*Check if MSI is used as system clock or as PLL source when PLL is selected as system clock*/

    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 80035b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80035ba:	2b00      	cmp	r3, #0
 80035bc:	d007      	beq.n	80035ce <HAL_RCC_OscConfig+0x52>
 80035be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80035c0:	2b0c      	cmp	r3, #12
 80035c2:	f040 80de 	bne.w	8003782 <HAL_RCC_OscConfig+0x206>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_MSI)))
 80035c6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80035c8:	2b01      	cmp	r3, #1
 80035ca:	f040 80da 	bne.w	8003782 <HAL_RCC_OscConfig+0x206>
    {
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
 80035ce:	687b      	ldr	r3, [r7, #4]
 80035d0:	69db      	ldr	r3, [r3, #28]
 80035d2:	2b00      	cmp	r3, #0
 80035d4:	d102      	bne.n	80035dc <HAL_RCC_OscConfig+0x60>
      {
        return HAL_ERROR;
 80035d6:	2301      	movs	r3, #1
 80035d8:	f000 bea5 	b.w	8004326 <HAL_RCC_OscConfig+0xdaa>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device */
        if (pRCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 80035dc:	687b      	ldr	r3, [r7, #4]
 80035de:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80035e0:	4b86      	ldr	r3, [pc, #536]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80035e2:	689b      	ldr	r3, [r3, #8]
 80035e4:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80035e8:	2b00      	cmp	r3, #0
 80035ea:	d004      	beq.n	80035f6 <HAL_RCC_OscConfig+0x7a>
 80035ec:	4b83      	ldr	r3, [pc, #524]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80035ee:	689b      	ldr	r3, [r3, #8]
 80035f0:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 80035f4:	e005      	b.n	8003602 <HAL_RCC_OscConfig+0x86>
 80035f6:	4b81      	ldr	r3, [pc, #516]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80035f8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 80035fc:	041b      	lsls	r3, r3, #16
 80035fe:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 8003602:	4293      	cmp	r3, r2
 8003604:	d255      	bcs.n	80036b2 <HAL_RCC_OscConfig+0x136>
        {
          /* Decrease number of wait states update if necessary */
          /* Only possible when MSI is the System clock source  */
          if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8003606:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003608:	2b00      	cmp	r3, #0
 800360a:	d10a      	bne.n	8003622 <HAL_RCC_OscConfig+0xa6>
          {
            if (RCC_SetFlashLatencyFromMSIRange(pRCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800360c:	687b      	ldr	r3, [r7, #4]
 800360e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003610:	4618      	mov	r0, r3
 8003612:	f001 f99d 	bl	8004950 <RCC_SetFlashLatencyFromMSIRange>
 8003616:	4603      	mov	r3, r0
 8003618:	2b00      	cmp	r3, #0
 800361a:	d002      	beq.n	8003622 <HAL_RCC_OscConfig+0xa6>
            {
              return HAL_ERROR;
 800361c:	2301      	movs	r3, #1
 800361e:	f000 be82 	b.w	8004326 <HAL_RCC_OscConfig+0xdaa>
            }
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range */
          __HAL_RCC_MSI_RANGE_CONFIG(pRCC_OscInitStruct->MSIClockRange);
 8003622:	4b76      	ldr	r3, [pc, #472]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 8003624:	689b      	ldr	r3, [r3, #8]
 8003626:	4a75      	ldr	r2, [pc, #468]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 8003628:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800362c:	6093      	str	r3, [r2, #8]
 800362e:	4b73      	ldr	r3, [pc, #460]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 8003630:	689b      	ldr	r3, [r3, #8]
 8003632:	f023 4270 	bic.w	r2, r3, #4026531840	; 0xf0000000
 8003636:	687b      	ldr	r3, [r7, #4]
 8003638:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800363a:	4970      	ldr	r1, [pc, #448]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 800363c:	4313      	orrs	r3, r2
 800363e:	608b      	str	r3, [r1, #8]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value */
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST((pRCC_OscInitStruct->MSICalibrationValue), \
 8003640:	687b      	ldr	r3, [r7, #4]
 8003642:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003644:	f1b3 4f40 	cmp.w	r3, #3221225472	; 0xc0000000
 8003648:	d309      	bcc.n	800365e <HAL_RCC_OscConfig+0xe2>
 800364a:	4b6c      	ldr	r3, [pc, #432]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 800364c:	68db      	ldr	r3, [r3, #12]
 800364e:	f023 021f 	bic.w	r2, r3, #31
 8003652:	687b      	ldr	r3, [r7, #4]
 8003654:	6a1b      	ldr	r3, [r3, #32]
 8003656:	4969      	ldr	r1, [pc, #420]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 8003658:	4313      	orrs	r3, r2
 800365a:	60cb      	str	r3, [r1, #12]
 800365c:	e07e      	b.n	800375c <HAL_RCC_OscConfig+0x1e0>
 800365e:	687b      	ldr	r3, [r7, #4]
 8003660:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003662:	2b00      	cmp	r3, #0
 8003664:	da0a      	bge.n	800367c <HAL_RCC_OscConfig+0x100>
 8003666:	4b65      	ldr	r3, [pc, #404]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 8003668:	68db      	ldr	r3, [r3, #12]
 800366a:	f423 7278 	bic.w	r2, r3, #992	; 0x3e0
 800366e:	687b      	ldr	r3, [r7, #4]
 8003670:	6a1b      	ldr	r3, [r3, #32]
 8003672:	015b      	lsls	r3, r3, #5
 8003674:	4961      	ldr	r1, [pc, #388]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 8003676:	4313      	orrs	r3, r2
 8003678:	60cb      	str	r3, [r1, #12]
 800367a:	e06f      	b.n	800375c <HAL_RCC_OscConfig+0x1e0>
 800367c:	687b      	ldr	r3, [r7, #4]
 800367e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003680:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8003684:	d30a      	bcc.n	800369c <HAL_RCC_OscConfig+0x120>
 8003686:	4b5d      	ldr	r3, [pc, #372]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 8003688:	68db      	ldr	r3, [r3, #12]
 800368a:	f423 42f8 	bic.w	r2, r3, #31744	; 0x7c00
 800368e:	687b      	ldr	r3, [r7, #4]
 8003690:	6a1b      	ldr	r3, [r3, #32]
 8003692:	029b      	lsls	r3, r3, #10
 8003694:	4959      	ldr	r1, [pc, #356]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 8003696:	4313      	orrs	r3, r2
 8003698:	60cb      	str	r3, [r1, #12]
 800369a:	e05f      	b.n	800375c <HAL_RCC_OscConfig+0x1e0>
 800369c:	4b57      	ldr	r3, [pc, #348]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 800369e:	68db      	ldr	r3, [r3, #12]
 80036a0:	f423 2278 	bic.w	r2, r3, #1015808	; 0xf8000
 80036a4:	687b      	ldr	r3, [r7, #4]
 80036a6:	6a1b      	ldr	r3, [r3, #32]
 80036a8:	03db      	lsls	r3, r3, #15
 80036aa:	4954      	ldr	r1, [pc, #336]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80036ac:	4313      	orrs	r3, r2
 80036ae:	60cb      	str	r3, [r1, #12]
 80036b0:	e054      	b.n	800375c <HAL_RCC_OscConfig+0x1e0>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range */
          __HAL_RCC_MSI_RANGE_CONFIG(pRCC_OscInitStruct->MSIClockRange);
 80036b2:	4b52      	ldr	r3, [pc, #328]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80036b4:	689b      	ldr	r3, [r3, #8]
 80036b6:	4a51      	ldr	r2, [pc, #324]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80036b8:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80036bc:	6093      	str	r3, [r2, #8]
 80036be:	4b4f      	ldr	r3, [pc, #316]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80036c0:	689b      	ldr	r3, [r3, #8]
 80036c2:	f023 4270 	bic.w	r2, r3, #4026531840	; 0xf0000000
 80036c6:	687b      	ldr	r3, [r7, #4]
 80036c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80036ca:	494c      	ldr	r1, [pc, #304]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80036cc:	4313      	orrs	r3, r2
 80036ce:	608b      	str	r3, [r1, #8]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value */
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST((pRCC_OscInitStruct->MSICalibrationValue), \
 80036d0:	687b      	ldr	r3, [r7, #4]
 80036d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80036d4:	f1b3 4f40 	cmp.w	r3, #3221225472	; 0xc0000000
 80036d8:	d309      	bcc.n	80036ee <HAL_RCC_OscConfig+0x172>
 80036da:	4b48      	ldr	r3, [pc, #288]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80036dc:	68db      	ldr	r3, [r3, #12]
 80036de:	f023 021f 	bic.w	r2, r3, #31
 80036e2:	687b      	ldr	r3, [r7, #4]
 80036e4:	6a1b      	ldr	r3, [r3, #32]
 80036e6:	4945      	ldr	r1, [pc, #276]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80036e8:	4313      	orrs	r3, r2
 80036ea:	60cb      	str	r3, [r1, #12]
 80036ec:	e028      	b.n	8003740 <HAL_RCC_OscConfig+0x1c4>
 80036ee:	687b      	ldr	r3, [r7, #4]
 80036f0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80036f2:	2b00      	cmp	r3, #0
 80036f4:	da0a      	bge.n	800370c <HAL_RCC_OscConfig+0x190>
 80036f6:	4b41      	ldr	r3, [pc, #260]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80036f8:	68db      	ldr	r3, [r3, #12]
 80036fa:	f423 7278 	bic.w	r2, r3, #992	; 0x3e0
 80036fe:	687b      	ldr	r3, [r7, #4]
 8003700:	6a1b      	ldr	r3, [r3, #32]
 8003702:	015b      	lsls	r3, r3, #5
 8003704:	493d      	ldr	r1, [pc, #244]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 8003706:	4313      	orrs	r3, r2
 8003708:	60cb      	str	r3, [r1, #12]
 800370a:	e019      	b.n	8003740 <HAL_RCC_OscConfig+0x1c4>
 800370c:	687b      	ldr	r3, [r7, #4]
 800370e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003710:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8003714:	d30a      	bcc.n	800372c <HAL_RCC_OscConfig+0x1b0>
 8003716:	4b39      	ldr	r3, [pc, #228]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 8003718:	68db      	ldr	r3, [r3, #12]
 800371a:	f423 42f8 	bic.w	r2, r3, #31744	; 0x7c00
 800371e:	687b      	ldr	r3, [r7, #4]
 8003720:	6a1b      	ldr	r3, [r3, #32]
 8003722:	029b      	lsls	r3, r3, #10
 8003724:	4935      	ldr	r1, [pc, #212]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 8003726:	4313      	orrs	r3, r2
 8003728:	60cb      	str	r3, [r1, #12]
 800372a:	e009      	b.n	8003740 <HAL_RCC_OscConfig+0x1c4>
 800372c:	4b33      	ldr	r3, [pc, #204]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 800372e:	68db      	ldr	r3, [r3, #12]
 8003730:	f423 2278 	bic.w	r2, r3, #1015808	; 0xf8000
 8003734:	687b      	ldr	r3, [r7, #4]
 8003736:	6a1b      	ldr	r3, [r3, #32]
 8003738:	03db      	lsls	r3, r3, #15
 800373a:	4930      	ldr	r1, [pc, #192]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 800373c:	4313      	orrs	r3, r2
 800373e:	60cb      	str	r3, [r1, #12]
                                                (pRCC_OscInitStruct->MSIClockRange));

          if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8003740:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003742:	2b00      	cmp	r3, #0
 8003744:	d10a      	bne.n	800375c <HAL_RCC_OscConfig+0x1e0>
          {
            if (RCC_SetFlashLatencyFromMSIRange(pRCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8003746:	687b      	ldr	r3, [r7, #4]
 8003748:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800374a:	4618      	mov	r0, r3
 800374c:	f001 f900 	bl	8004950 <RCC_SetFlashLatencyFromMSIRange>
 8003750:	4603      	mov	r3, r0
 8003752:	2b00      	cmp	r3, #0
 8003754:	d002      	beq.n	800375c <HAL_RCC_OscConfig+0x1e0>
            {
              return HAL_ERROR;
 8003756:	2301      	movs	r3, #1
 8003758:	f000 bde5 	b.w	8004326 <HAL_RCC_OscConfig+0xdaa>
            }
          }
        }

        /* Update the SystemCoreClock global variable */
        (void) HAL_RCC_GetHCLKFreq();
 800375c:	f001 f8de 	bl	800491c <HAL_RCC_GetHCLKFreq>
        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick(uwTickPrio);
 8003760:	4b27      	ldr	r3, [pc, #156]	; (8003800 <HAL_RCC_OscConfig+0x284>)
 8003762:	681b      	ldr	r3, [r3, #0]
 8003764:	4618      	mov	r0, r3
 8003766:	f7fd fc0d 	bl	8000f84 <HAL_InitTick>
 800376a:	4603      	mov	r3, r0
 800376c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        if (status != HAL_OK)
 8003770:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8003774:	2b00      	cmp	r3, #0
 8003776:	f000 808a 	beq.w	800388e <HAL_RCC_OscConfig+0x312>
        {
          return status;
 800377a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800377e:	f000 bdd2 	b.w	8004326 <HAL_RCC_OscConfig+0xdaa>
      }
    }
    else
    {
      /* Check the MSI State */
      if (pRCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8003782:	687b      	ldr	r3, [r7, #4]
 8003784:	69db      	ldr	r3, [r3, #28]
 8003786:	2b00      	cmp	r3, #0
 8003788:	d066      	beq.n	8003858 <HAL_RCC_OscConfig+0x2dc>
      {
        /* Enable the Internal High Speed oscillator (MSI) */
        __HAL_RCC_MSI_ENABLE();
 800378a:	4b1c      	ldr	r3, [pc, #112]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 800378c:	681b      	ldr	r3, [r3, #0]
 800378e:	4a1b      	ldr	r2, [pc, #108]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 8003790:	f043 0301 	orr.w	r3, r3, #1
 8003794:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8003796:	f7fd fc3f 	bl	8001018 <HAL_GetTick>
 800379a:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till MSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) == 0U)
 800379c:	e009      	b.n	80037b2 <HAL_RCC_OscConfig+0x236>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800379e:	f7fd fc3b 	bl	8001018 <HAL_GetTick>
 80037a2:	4602      	mov	r2, r0
 80037a4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80037a6:	1ad3      	subs	r3, r2, r3
 80037a8:	2b02      	cmp	r3, #2
 80037aa:	d902      	bls.n	80037b2 <HAL_RCC_OscConfig+0x236>
          {
            return HAL_TIMEOUT;
 80037ac:	2303      	movs	r3, #3
 80037ae:	f000 bdba 	b.w	8004326 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) == 0U)
 80037b2:	4b12      	ldr	r3, [pc, #72]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80037b4:	681b      	ldr	r3, [r3, #0]
 80037b6:	f003 0304 	and.w	r3, r3, #4
 80037ba:	2b00      	cmp	r3, #0
 80037bc:	d0ef      	beq.n	800379e <HAL_RCC_OscConfig+0x222>
          }
        }
        /* Selects the Multiple Speed oscillator (MSI) clock range */
        __HAL_RCC_MSI_RANGE_CONFIG(pRCC_OscInitStruct->MSIClockRange);
 80037be:	4b0f      	ldr	r3, [pc, #60]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80037c0:	689b      	ldr	r3, [r3, #8]
 80037c2:	4a0e      	ldr	r2, [pc, #56]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80037c4:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80037c8:	6093      	str	r3, [r2, #8]
 80037ca:	4b0c      	ldr	r3, [pc, #48]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80037cc:	689b      	ldr	r3, [r3, #8]
 80037ce:	f023 4270 	bic.w	r2, r3, #4026531840	; 0xf0000000
 80037d2:	687b      	ldr	r3, [r7, #4]
 80037d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80037d6:	4909      	ldr	r1, [pc, #36]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80037d8:	4313      	orrs	r3, r2
 80037da:	608b      	str	r3, [r1, #8]
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value */
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST((pRCC_OscInitStruct->MSICalibrationValue), \
 80037dc:	687b      	ldr	r3, [r7, #4]
 80037de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80037e0:	f1b3 4f40 	cmp.w	r3, #3221225472	; 0xc0000000
 80037e4:	d30e      	bcc.n	8003804 <HAL_RCC_OscConfig+0x288>
 80037e6:	4b05      	ldr	r3, [pc, #20]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80037e8:	68db      	ldr	r3, [r3, #12]
 80037ea:	f023 021f 	bic.w	r2, r3, #31
 80037ee:	687b      	ldr	r3, [r7, #4]
 80037f0:	6a1b      	ldr	r3, [r3, #32]
 80037f2:	4902      	ldr	r1, [pc, #8]	; (80037fc <HAL_RCC_OscConfig+0x280>)
 80037f4:	4313      	orrs	r3, r2
 80037f6:	60cb      	str	r3, [r1, #12]
 80037f8:	e04a      	b.n	8003890 <HAL_RCC_OscConfig+0x314>
 80037fa:	bf00      	nop
 80037fc:	46020c00 	.word	0x46020c00
 8003800:	2000000c 	.word	0x2000000c
 8003804:	687b      	ldr	r3, [r7, #4]
 8003806:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003808:	2b00      	cmp	r3, #0
 800380a:	da0a      	bge.n	8003822 <HAL_RCC_OscConfig+0x2a6>
 800380c:	4b98      	ldr	r3, [pc, #608]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 800380e:	68db      	ldr	r3, [r3, #12]
 8003810:	f423 7278 	bic.w	r2, r3, #992	; 0x3e0
 8003814:	687b      	ldr	r3, [r7, #4]
 8003816:	6a1b      	ldr	r3, [r3, #32]
 8003818:	015b      	lsls	r3, r3, #5
 800381a:	4995      	ldr	r1, [pc, #596]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 800381c:	4313      	orrs	r3, r2
 800381e:	60cb      	str	r3, [r1, #12]
 8003820:	e036      	b.n	8003890 <HAL_RCC_OscConfig+0x314>
 8003822:	687b      	ldr	r3, [r7, #4]
 8003824:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003826:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800382a:	d30a      	bcc.n	8003842 <HAL_RCC_OscConfig+0x2c6>
 800382c:	4b90      	ldr	r3, [pc, #576]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 800382e:	68db      	ldr	r3, [r3, #12]
 8003830:	f423 42f8 	bic.w	r2, r3, #31744	; 0x7c00
 8003834:	687b      	ldr	r3, [r7, #4]
 8003836:	6a1b      	ldr	r3, [r3, #32]
 8003838:	029b      	lsls	r3, r3, #10
 800383a:	498d      	ldr	r1, [pc, #564]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 800383c:	4313      	orrs	r3, r2
 800383e:	60cb      	str	r3, [r1, #12]
 8003840:	e026      	b.n	8003890 <HAL_RCC_OscConfig+0x314>
 8003842:	4b8b      	ldr	r3, [pc, #556]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003844:	68db      	ldr	r3, [r3, #12]
 8003846:	f423 2278 	bic.w	r2, r3, #1015808	; 0xf8000
 800384a:	687b      	ldr	r3, [r7, #4]
 800384c:	6a1b      	ldr	r3, [r3, #32]
 800384e:	03db      	lsls	r3, r3, #15
 8003850:	4987      	ldr	r1, [pc, #540]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003852:	4313      	orrs	r3, r2
 8003854:	60cb      	str	r3, [r1, #12]
 8003856:	e01b      	b.n	8003890 <HAL_RCC_OscConfig+0x314>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI) */
        __HAL_RCC_MSI_DISABLE();
 8003858:	4b85      	ldr	r3, [pc, #532]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 800385a:	681b      	ldr	r3, [r3, #0]
 800385c:	4a84      	ldr	r2, [pc, #528]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 800385e:	f023 0301 	bic.w	r3, r3, #1
 8003862:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8003864:	f7fd fbd8 	bl	8001018 <HAL_GetTick>
 8003868:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till MSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) != 0U)
 800386a:	e009      	b.n	8003880 <HAL_RCC_OscConfig+0x304>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800386c:	f7fd fbd4 	bl	8001018 <HAL_GetTick>
 8003870:	4602      	mov	r2, r0
 8003872:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003874:	1ad3      	subs	r3, r2, r3
 8003876:	2b02      	cmp	r3, #2
 8003878:	d902      	bls.n	8003880 <HAL_RCC_OscConfig+0x304>
          {
            return HAL_TIMEOUT;
 800387a:	2303      	movs	r3, #3
 800387c:	f000 bd53 	b.w	8004326 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) != 0U)
 8003880:	4b7b      	ldr	r3, [pc, #492]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003882:	681b      	ldr	r3, [r3, #0]
 8003884:	f003 0304 	and.w	r3, r3, #4
 8003888:	2b00      	cmp	r3, #0
 800388a:	d1ef      	bne.n	800386c <HAL_RCC_OscConfig+0x2f0>
 800388c:	e000      	b.n	8003890 <HAL_RCC_OscConfig+0x314>
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
 800388e:	bf00      	nop
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8003890:	687b      	ldr	r3, [r7, #4]
 8003892:	681b      	ldr	r3, [r3, #0]
 8003894:	f003 0301 	and.w	r3, r3, #1
 8003898:	2b00      	cmp	r3, #0
 800389a:	f000 808b 	beq.w	80039b4 <HAL_RCC_OscConfig+0x438>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(pRCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 800389e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80038a0:	2b08      	cmp	r3, #8
 80038a2:	d005      	beq.n	80038b0 <HAL_RCC_OscConfig+0x334>
 80038a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80038a6:	2b0c      	cmp	r3, #12
 80038a8:	d109      	bne.n	80038be <HAL_RCC_OscConfig+0x342>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 80038aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80038ac:	2b03      	cmp	r3, #3
 80038ae:	d106      	bne.n	80038be <HAL_RCC_OscConfig+0x342>
    {
      if (pRCC_OscInitStruct->HSEState == RCC_HSE_OFF)
 80038b0:	687b      	ldr	r3, [r7, #4]
 80038b2:	685b      	ldr	r3, [r3, #4]
 80038b4:	2b00      	cmp	r3, #0
 80038b6:	d17d      	bne.n	80039b4 <HAL_RCC_OscConfig+0x438>
      {
        return HAL_ERROR;
 80038b8:	2301      	movs	r3, #1
 80038ba:	f000 bd34 	b.w	8004326 <HAL_RCC_OscConfig+0xdaa>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
 80038be:	687b      	ldr	r3, [r7, #4]
 80038c0:	685b      	ldr	r3, [r3, #4]
 80038c2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80038c6:	d106      	bne.n	80038d6 <HAL_RCC_OscConfig+0x35a>
 80038c8:	4b69      	ldr	r3, [pc, #420]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 80038ca:	681b      	ldr	r3, [r3, #0]
 80038cc:	4a68      	ldr	r2, [pc, #416]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 80038ce:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80038d2:	6013      	str	r3, [r2, #0]
 80038d4:	e041      	b.n	800395a <HAL_RCC_OscConfig+0x3de>
 80038d6:	687b      	ldr	r3, [r7, #4]
 80038d8:	685b      	ldr	r3, [r3, #4]
 80038da:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80038de:	d112      	bne.n	8003906 <HAL_RCC_OscConfig+0x38a>
 80038e0:	4b63      	ldr	r3, [pc, #396]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 80038e2:	681b      	ldr	r3, [r3, #0]
 80038e4:	4a62      	ldr	r2, [pc, #392]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 80038e6:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80038ea:	6013      	str	r3, [r2, #0]
 80038ec:	4b60      	ldr	r3, [pc, #384]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 80038ee:	681b      	ldr	r3, [r3, #0]
 80038f0:	4a5f      	ldr	r2, [pc, #380]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 80038f2:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 80038f6:	6013      	str	r3, [r2, #0]
 80038f8:	4b5d      	ldr	r3, [pc, #372]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 80038fa:	681b      	ldr	r3, [r3, #0]
 80038fc:	4a5c      	ldr	r2, [pc, #368]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 80038fe:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003902:	6013      	str	r3, [r2, #0]
 8003904:	e029      	b.n	800395a <HAL_RCC_OscConfig+0x3de>
 8003906:	687b      	ldr	r3, [r7, #4]
 8003908:	685b      	ldr	r3, [r3, #4]
 800390a:	f5b3 1fa8 	cmp.w	r3, #1376256	; 0x150000
 800390e:	d112      	bne.n	8003936 <HAL_RCC_OscConfig+0x3ba>
 8003910:	4b57      	ldr	r3, [pc, #348]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003912:	681b      	ldr	r3, [r3, #0]
 8003914:	4a56      	ldr	r2, [pc, #344]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003916:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800391a:	6013      	str	r3, [r2, #0]
 800391c:	4b54      	ldr	r3, [pc, #336]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 800391e:	681b      	ldr	r3, [r3, #0]
 8003920:	4a53      	ldr	r2, [pc, #332]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003922:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8003926:	6013      	str	r3, [r2, #0]
 8003928:	4b51      	ldr	r3, [pc, #324]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 800392a:	681b      	ldr	r3, [r3, #0]
 800392c:	4a50      	ldr	r2, [pc, #320]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 800392e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003932:	6013      	str	r3, [r2, #0]
 8003934:	e011      	b.n	800395a <HAL_RCC_OscConfig+0x3de>
 8003936:	4b4e      	ldr	r3, [pc, #312]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003938:	681b      	ldr	r3, [r3, #0]
 800393a:	4a4d      	ldr	r2, [pc, #308]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 800393c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003940:	6013      	str	r3, [r2, #0]
 8003942:	4b4b      	ldr	r3, [pc, #300]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003944:	681b      	ldr	r3, [r3, #0]
 8003946:	4a4a      	ldr	r2, [pc, #296]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003948:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800394c:	6013      	str	r3, [r2, #0]
 800394e:	4b48      	ldr	r3, [pc, #288]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003950:	681b      	ldr	r3, [r3, #0]
 8003952:	4a47      	ldr	r2, [pc, #284]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003954:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8003958:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800395a:	687b      	ldr	r3, [r7, #4]
 800395c:	685b      	ldr	r3, [r3, #4]
 800395e:	2b00      	cmp	r3, #0
 8003960:	d014      	beq.n	800398c <HAL_RCC_OscConfig+0x410>
      {
        tickstart = HAL_GetTick();
 8003962:	f7fd fb59 	bl	8001018 <HAL_GetTick>
 8003966:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till HSE is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8003968:	e009      	b.n	800397e <HAL_RCC_OscConfig+0x402>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800396a:	f7fd fb55 	bl	8001018 <HAL_GetTick>
 800396e:	4602      	mov	r2, r0
 8003970:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003972:	1ad3      	subs	r3, r2, r3
 8003974:	2b64      	cmp	r3, #100	; 0x64
 8003976:	d902      	bls.n	800397e <HAL_RCC_OscConfig+0x402>
          {
            return HAL_TIMEOUT;
 8003978:	2303      	movs	r3, #3
 800397a:	f000 bcd4 	b.w	8004326 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800397e:	4b3c      	ldr	r3, [pc, #240]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003980:	681b      	ldr	r3, [r3, #0]
 8003982:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003986:	2b00      	cmp	r3, #0
 8003988:	d0ef      	beq.n	800396a <HAL_RCC_OscConfig+0x3ee>
 800398a:	e013      	b.n	80039b4 <HAL_RCC_OscConfig+0x438>
          }
        }
      }
      else
      {
        tickstart = HAL_GetTick();
 800398c:	f7fd fb44 	bl	8001018 <HAL_GetTick>
 8003990:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8003992:	e009      	b.n	80039a8 <HAL_RCC_OscConfig+0x42c>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8003994:	f7fd fb40 	bl	8001018 <HAL_GetTick>
 8003998:	4602      	mov	r2, r0
 800399a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800399c:	1ad3      	subs	r3, r2, r3
 800399e:	2b64      	cmp	r3, #100	; 0x64
 80039a0:	d902      	bls.n	80039a8 <HAL_RCC_OscConfig+0x42c>
          {
            return HAL_TIMEOUT;
 80039a2:	2303      	movs	r3, #3
 80039a4:	f000 bcbf 	b.w	8004326 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 80039a8:	4b31      	ldr	r3, [pc, #196]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 80039aa:	681b      	ldr	r3, [r3, #0]
 80039ac:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80039b0:	2b00      	cmp	r3, #0
 80039b2:	d1ef      	bne.n	8003994 <HAL_RCC_OscConfig+0x418>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80039b4:	687b      	ldr	r3, [r7, #4]
 80039b6:	681b      	ldr	r3, [r3, #0]
 80039b8:	f003 0302 	and.w	r3, r3, #2
 80039bc:	2b00      	cmp	r3, #0
 80039be:	d05f      	beq.n	8003a80 <HAL_RCC_OscConfig+0x504>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(pRCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 80039c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80039c2:	2b04      	cmp	r3, #4
 80039c4:	d005      	beq.n	80039d2 <HAL_RCC_OscConfig+0x456>
 80039c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80039c8:	2b0c      	cmp	r3, #12
 80039ca:	d114      	bne.n	80039f6 <HAL_RCC_OscConfig+0x47a>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 80039cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80039ce:	2b02      	cmp	r3, #2
 80039d0:	d111      	bne.n	80039f6 <HAL_RCC_OscConfig+0x47a>
    {
      /* When HSI is used as system clock it will not be disabled */
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
 80039d2:	687b      	ldr	r3, [r7, #4]
 80039d4:	68db      	ldr	r3, [r3, #12]
 80039d6:	2b00      	cmp	r3, #0
 80039d8:	d102      	bne.n	80039e0 <HAL_RCC_OscConfig+0x464>
      {
        return HAL_ERROR;
 80039da:	2301      	movs	r3, #1
 80039dc:	f000 bca3 	b.w	8004326 <HAL_RCC_OscConfig+0xdaa>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
 80039e0:	4b23      	ldr	r3, [pc, #140]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 80039e2:	691b      	ldr	r3, [r3, #16]
 80039e4:	f423 12f8 	bic.w	r2, r3, #2031616	; 0x1f0000
 80039e8:	687b      	ldr	r3, [r7, #4]
 80039ea:	691b      	ldr	r3, [r3, #16]
 80039ec:	041b      	lsls	r3, r3, #16
 80039ee:	4920      	ldr	r1, [pc, #128]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 80039f0:	4313      	orrs	r3, r2
 80039f2:	610b      	str	r3, [r1, #16]
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
 80039f4:	e044      	b.n	8003a80 <HAL_RCC_OscConfig+0x504>
      }
    }
    else
    {
      /* Check the HSI State */
      if (pRCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80039f6:	687b      	ldr	r3, [r7, #4]
 80039f8:	68db      	ldr	r3, [r3, #12]
 80039fa:	2b00      	cmp	r3, #0
 80039fc:	d024      	beq.n	8003a48 <HAL_RCC_OscConfig+0x4cc>
      {
        /* Enable the Internal High Speed oscillator (HSI) */
        __HAL_RCC_HSI_ENABLE();
 80039fe:	4b1c      	ldr	r3, [pc, #112]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003a00:	681b      	ldr	r3, [r3, #0]
 8003a02:	4a1b      	ldr	r2, [pc, #108]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003a04:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003a08:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8003a0a:	f7fd fb05 	bl	8001018 <HAL_GetTick>
 8003a0e:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till HSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8003a10:	e009      	b.n	8003a26 <HAL_RCC_OscConfig+0x4aa>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8003a12:	f7fd fb01 	bl	8001018 <HAL_GetTick>
 8003a16:	4602      	mov	r2, r0
 8003a18:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003a1a:	1ad3      	subs	r3, r2, r3
 8003a1c:	2b02      	cmp	r3, #2
 8003a1e:	d902      	bls.n	8003a26 <HAL_RCC_OscConfig+0x4aa>
          {
            return HAL_TIMEOUT;
 8003a20:	2303      	movs	r3, #3
 8003a22:	f000 bc80 	b.w	8004326 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8003a26:	4b12      	ldr	r3, [pc, #72]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003a28:	681b      	ldr	r3, [r3, #0]
 8003a2a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8003a2e:	2b00      	cmp	r3, #0
 8003a30:	d0ef      	beq.n	8003a12 <HAL_RCC_OscConfig+0x496>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
 8003a32:	4b0f      	ldr	r3, [pc, #60]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003a34:	691b      	ldr	r3, [r3, #16]
 8003a36:	f423 12f8 	bic.w	r2, r3, #2031616	; 0x1f0000
 8003a3a:	687b      	ldr	r3, [r7, #4]
 8003a3c:	691b      	ldr	r3, [r3, #16]
 8003a3e:	041b      	lsls	r3, r3, #16
 8003a40:	490b      	ldr	r1, [pc, #44]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003a42:	4313      	orrs	r3, r2
 8003a44:	610b      	str	r3, [r1, #16]
 8003a46:	e01b      	b.n	8003a80 <HAL_RCC_OscConfig+0x504>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI) */
        __HAL_RCC_HSI_DISABLE();
 8003a48:	4b09      	ldr	r3, [pc, #36]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003a4a:	681b      	ldr	r3, [r3, #0]
 8003a4c:	4a08      	ldr	r2, [pc, #32]	; (8003a70 <HAL_RCC_OscConfig+0x4f4>)
 8003a4e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003a52:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8003a54:	f7fd fae0 	bl	8001018 <HAL_GetTick>
 8003a58:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till HSI is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8003a5a:	e00b      	b.n	8003a74 <HAL_RCC_OscConfig+0x4f8>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8003a5c:	f7fd fadc 	bl	8001018 <HAL_GetTick>
 8003a60:	4602      	mov	r2, r0
 8003a62:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003a64:	1ad3      	subs	r3, r2, r3
 8003a66:	2b02      	cmp	r3, #2
 8003a68:	d904      	bls.n	8003a74 <HAL_RCC_OscConfig+0x4f8>
          {
            return HAL_TIMEOUT;
 8003a6a:	2303      	movs	r3, #3
 8003a6c:	f000 bc5b 	b.w	8004326 <HAL_RCC_OscConfig+0xdaa>
 8003a70:	46020c00 	.word	0x46020c00
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8003a74:	4baf      	ldr	r3, [pc, #700]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003a76:	681b      	ldr	r3, [r3, #0]
 8003a78:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8003a7c:	2b00      	cmp	r3, #0
 8003a7e:	d1ed      	bne.n	8003a5c <HAL_RCC_OscConfig+0x4e0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8003a80:	687b      	ldr	r3, [r7, #4]
 8003a82:	681b      	ldr	r3, [r3, #0]
 8003a84:	f003 0308 	and.w	r3, r3, #8
 8003a88:	2b00      	cmp	r3, #0
 8003a8a:	f000 80c8 	beq.w	8003c1e <HAL_RCC_OscConfig+0x6a2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(pRCC_OscInitStruct->LSIState));

    FlagStatus  pwrclkchanged = RESET;
 8003a8e:	2300      	movs	r3, #0
 8003a90:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    /* Update LSI configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8003a94:	4ba7      	ldr	r3, [pc, #668]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003a96:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003a9a:	f003 0304 	and.w	r3, r3, #4
 8003a9e:	2b00      	cmp	r3, #0
 8003aa0:	d111      	bne.n	8003ac6 <HAL_RCC_OscConfig+0x54a>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8003aa2:	4ba4      	ldr	r3, [pc, #656]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003aa4:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003aa8:	4aa2      	ldr	r2, [pc, #648]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003aaa:	f043 0304 	orr.w	r3, r3, #4
 8003aae:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 8003ab2:	4ba0      	ldr	r3, [pc, #640]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003ab4:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003ab8:	f003 0304 	and.w	r3, r3, #4
 8003abc:	617b      	str	r3, [r7, #20]
 8003abe:	697b      	ldr	r3, [r7, #20]
      pwrclkchanged = SET;
 8003ac0:	2301      	movs	r3, #1
 8003ac2:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
    }

    if (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8003ac6:	4b9c      	ldr	r3, [pc, #624]	; (8003d38 <HAL_RCC_OscConfig+0x7bc>)
 8003ac8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003aca:	f003 0301 	and.w	r3, r3, #1
 8003ace:	2b00      	cmp	r3, #0
 8003ad0:	d119      	bne.n	8003b06 <HAL_RCC_OscConfig+0x58a>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPR, PWR_DBPR_DBP);
 8003ad2:	4b99      	ldr	r3, [pc, #612]	; (8003d38 <HAL_RCC_OscConfig+0x7bc>)
 8003ad4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003ad6:	4a98      	ldr	r2, [pc, #608]	; (8003d38 <HAL_RCC_OscConfig+0x7bc>)
 8003ad8:	f043 0301 	orr.w	r3, r3, #1
 8003adc:	6293      	str	r3, [r2, #40]	; 0x28

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8003ade:	f7fd fa9b 	bl	8001018 <HAL_GetTick>
 8003ae2:	62b8      	str	r0, [r7, #40]	; 0x28

      while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8003ae4:	e009      	b.n	8003afa <HAL_RCC_OscConfig+0x57e>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8003ae6:	f7fd fa97 	bl	8001018 <HAL_GetTick>
 8003aea:	4602      	mov	r2, r0
 8003aec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003aee:	1ad3      	subs	r3, r2, r3
 8003af0:	2b02      	cmp	r3, #2
 8003af2:	d902      	bls.n	8003afa <HAL_RCC_OscConfig+0x57e>
        {
          return HAL_TIMEOUT;
 8003af4:	2303      	movs	r3, #3
 8003af6:	f000 bc16 	b.w	8004326 <HAL_RCC_OscConfig+0xdaa>
      while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8003afa:	4b8f      	ldr	r3, [pc, #572]	; (8003d38 <HAL_RCC_OscConfig+0x7bc>)
 8003afc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003afe:	f003 0301 	and.w	r3, r3, #1
 8003b02:	2b00      	cmp	r3, #0
 8003b04:	d0ef      	beq.n	8003ae6 <HAL_RCC_OscConfig+0x56a>
        }
      }
    }
    /* Check the LSI State */
    if (pRCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8003b06:	687b      	ldr	r3, [r7, #4]
 8003b08:	695b      	ldr	r3, [r3, #20]
 8003b0a:	2b00      	cmp	r3, #0
 8003b0c:	d05f      	beq.n	8003bce <HAL_RCC_OscConfig+0x652>
    {
      uint32_t bdcr_temp = RCC->BDCR;
 8003b0e:	4b89      	ldr	r3, [pc, #548]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003b10:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003b14:	623b      	str	r3, [r7, #32]

      /* Check LSI division factor */
      assert_param(IS_RCC_LSIDIV(pRCC_OscInitStruct->LSIDiv));

      if (pRCC_OscInitStruct->LSIDiv != (bdcr_temp & RCC_BDCR_LSIPREDIV))
 8003b16:	687b      	ldr	r3, [r7, #4]
 8003b18:	699a      	ldr	r2, [r3, #24]
 8003b1a:	6a3b      	ldr	r3, [r7, #32]
 8003b1c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003b20:	429a      	cmp	r2, r3
 8003b22:	d037      	beq.n	8003b94 <HAL_RCC_OscConfig+0x618>
      {
        if (((bdcr_temp & RCC_BDCR_LSIRDY) == RCC_BDCR_LSIRDY) && \
 8003b24:	6a3b      	ldr	r3, [r7, #32]
 8003b26:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8003b2a:	2b00      	cmp	r3, #0
 8003b2c:	d006      	beq.n	8003b3c <HAL_RCC_OscConfig+0x5c0>
            ((bdcr_temp & RCC_BDCR_LSION) != RCC_BDCR_LSION))
 8003b2e:	6a3b      	ldr	r3, [r7, #32]
 8003b30:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
        if (((bdcr_temp & RCC_BDCR_LSIRDY) == RCC_BDCR_LSIRDY) && \
 8003b34:	2b00      	cmp	r3, #0
 8003b36:	d101      	bne.n	8003b3c <HAL_RCC_OscConfig+0x5c0>
        {
          /* If LSIRDY is set while LSION is not enabled, LSIPREDIV can't be updated */
          /* The LSIPREDIV cannot be changed if the LSI is used by the IWDG or by the RTC */
          return HAL_ERROR;
 8003b38:	2301      	movs	r3, #1
 8003b3a:	e3f4      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
        }

        /* Turn off LSI before changing RCC_BDCR_LSIPREDIV */
        if ((bdcr_temp & RCC_BDCR_LSION) == RCC_BDCR_LSION)
 8003b3c:	6a3b      	ldr	r3, [r7, #32]
 8003b3e:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8003b42:	2b00      	cmp	r3, #0
 8003b44:	d01b      	beq.n	8003b7e <HAL_RCC_OscConfig+0x602>
        {
          __HAL_RCC_LSI_DISABLE();
 8003b46:	4b7b      	ldr	r3, [pc, #492]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003b48:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003b4c:	4a79      	ldr	r2, [pc, #484]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003b4e:	f023 53a0 	bic.w	r3, r3, #335544320	; 0x14000000
 8003b52:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0

          tickstart = HAL_GetTick();
 8003b56:	f7fd fa5f 	bl	8001018 <HAL_GetTick>
 8003b5a:	62b8      	str	r0, [r7, #40]	; 0x28

          /* Wait till LSI is disabled */
          while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 8003b5c:	e008      	b.n	8003b70 <HAL_RCC_OscConfig+0x5f4>
          {
            if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8003b5e:	f7fd fa5b 	bl	8001018 <HAL_GetTick>
 8003b62:	4602      	mov	r2, r0
 8003b64:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003b66:	1ad3      	subs	r3, r2, r3
 8003b68:	2b05      	cmp	r3, #5
 8003b6a:	d901      	bls.n	8003b70 <HAL_RCC_OscConfig+0x5f4>
            {
              return HAL_TIMEOUT;
 8003b6c:	2303      	movs	r3, #3
 8003b6e:	e3da      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
          while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 8003b70:	4b70      	ldr	r3, [pc, #448]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003b72:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003b76:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8003b7a:	2b00      	cmp	r3, #0
 8003b7c:	d1ef      	bne.n	8003b5e <HAL_RCC_OscConfig+0x5e2>
            }
          }
        }

        /* Set LSI division factor */
        MODIFY_REG(RCC->BDCR, RCC_BDCR_LSIPREDIV, pRCC_OscInitStruct->LSIDiv);
 8003b7e:	4b6d      	ldr	r3, [pc, #436]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003b80:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003b84:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
 8003b88:	687b      	ldr	r3, [r7, #4]
 8003b8a:	699b      	ldr	r3, [r3, #24]
 8003b8c:	4969      	ldr	r1, [pc, #420]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003b8e:	4313      	orrs	r3, r2
 8003b90:	f8c1 30f0 	str.w	r3, [r1, #240]	; 0xf0
      }

      /* Enable the Internal Low Speed oscillator (LSI) */
      __HAL_RCC_LSI_ENABLE();
 8003b94:	4b67      	ldr	r3, [pc, #412]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003b96:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003b9a:	4a66      	ldr	r2, [pc, #408]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003b9c:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8003ba0:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0

      tickstart = HAL_GetTick();
 8003ba4:	f7fd fa38 	bl	8001018 <HAL_GetTick>
 8003ba8:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till LSI is ready */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) == 0U)
 8003baa:	e008      	b.n	8003bbe <HAL_RCC_OscConfig+0x642>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8003bac:	f7fd fa34 	bl	8001018 <HAL_GetTick>
 8003bb0:	4602      	mov	r2, r0
 8003bb2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003bb4:	1ad3      	subs	r3, r2, r3
 8003bb6:	2b05      	cmp	r3, #5
 8003bb8:	d901      	bls.n	8003bbe <HAL_RCC_OscConfig+0x642>
        {
          return HAL_TIMEOUT;
 8003bba:	2303      	movs	r3, #3
 8003bbc:	e3b3      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) == 0U)
 8003bbe:	4b5d      	ldr	r3, [pc, #372]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003bc0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003bc4:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8003bc8:	2b00      	cmp	r3, #0
 8003bca:	d0ef      	beq.n	8003bac <HAL_RCC_OscConfig+0x630>
 8003bcc:	e01b      	b.n	8003c06 <HAL_RCC_OscConfig+0x68a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI) */
      __HAL_RCC_LSI_DISABLE();
 8003bce:	4b59      	ldr	r3, [pc, #356]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003bd0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003bd4:	4a57      	ldr	r2, [pc, #348]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003bd6:	f023 53a0 	bic.w	r3, r3, #335544320	; 0x14000000
 8003bda:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0

      tickstart = HAL_GetTick();
 8003bde:	f7fd fa1b 	bl	8001018 <HAL_GetTick>
 8003be2:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till LSI is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 8003be4:	e008      	b.n	8003bf8 <HAL_RCC_OscConfig+0x67c>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8003be6:	f7fd fa17 	bl	8001018 <HAL_GetTick>
 8003bea:	4602      	mov	r2, r0
 8003bec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003bee:	1ad3      	subs	r3, r2, r3
 8003bf0:	2b05      	cmp	r3, #5
 8003bf2:	d901      	bls.n	8003bf8 <HAL_RCC_OscConfig+0x67c>
        {
          return HAL_TIMEOUT;
 8003bf4:	2303      	movs	r3, #3
 8003bf6:	e396      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 8003bf8:	4b4e      	ldr	r3, [pc, #312]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003bfa:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003bfe:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8003c02:	2b00      	cmp	r3, #0
 8003c04:	d1ef      	bne.n	8003be6 <HAL_RCC_OscConfig+0x66a>
        }
      }
    }
    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 8003c06:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8003c0a:	2b01      	cmp	r3, #1
 8003c0c:	d107      	bne.n	8003c1e <HAL_RCC_OscConfig+0x6a2>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8003c0e:	4b49      	ldr	r3, [pc, #292]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003c10:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003c14:	4a47      	ldr	r2, [pc, #284]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003c16:	f023 0304 	bic.w	r3, r3, #4
 8003c1a:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8003c1e:	687b      	ldr	r3, [r7, #4]
 8003c20:	681b      	ldr	r3, [r3, #0]
 8003c22:	f003 0304 	and.w	r3, r3, #4
 8003c26:	2b00      	cmp	r3, #0
 8003c28:	f000 8111 	beq.w	8003e4e <HAL_RCC_OscConfig+0x8d2>
  {
    FlagStatus pwrclkchanged = RESET;
 8003c2c:	2300      	movs	r3, #0
 8003c2e:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
    /* Check the parameters */
    assert_param(IS_RCC_LSE(pRCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8003c32:	4b40      	ldr	r3, [pc, #256]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003c34:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003c38:	f003 0304 	and.w	r3, r3, #4
 8003c3c:	2b00      	cmp	r3, #0
 8003c3e:	d111      	bne.n	8003c64 <HAL_RCC_OscConfig+0x6e8>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8003c40:	4b3c      	ldr	r3, [pc, #240]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003c42:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003c46:	4a3b      	ldr	r2, [pc, #236]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003c48:	f043 0304 	orr.w	r3, r3, #4
 8003c4c:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 8003c50:	4b38      	ldr	r3, [pc, #224]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003c52:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003c56:	f003 0304 	and.w	r3, r3, #4
 8003c5a:	613b      	str	r3, [r7, #16]
 8003c5c:	693b      	ldr	r3, [r7, #16]
      pwrclkchanged = SET;
 8003c5e:	2301      	movs	r3, #1
 8003c60:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
    }

    if (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8003c64:	4b34      	ldr	r3, [pc, #208]	; (8003d38 <HAL_RCC_OscConfig+0x7bc>)
 8003c66:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003c68:	f003 0301 	and.w	r3, r3, #1
 8003c6c:	2b00      	cmp	r3, #0
 8003c6e:	d118      	bne.n	8003ca2 <HAL_RCC_OscConfig+0x726>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPR, PWR_DBPR_DBP);
 8003c70:	4b31      	ldr	r3, [pc, #196]	; (8003d38 <HAL_RCC_OscConfig+0x7bc>)
 8003c72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003c74:	4a30      	ldr	r2, [pc, #192]	; (8003d38 <HAL_RCC_OscConfig+0x7bc>)
 8003c76:	f043 0301 	orr.w	r3, r3, #1
 8003c7a:	6293      	str	r3, [r2, #40]	; 0x28

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8003c7c:	f7fd f9cc 	bl	8001018 <HAL_GetTick>
 8003c80:	62b8      	str	r0, [r7, #40]	; 0x28

      while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8003c82:	e008      	b.n	8003c96 <HAL_RCC_OscConfig+0x71a>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8003c84:	f7fd f9c8 	bl	8001018 <HAL_GetTick>
 8003c88:	4602      	mov	r2, r0
 8003c8a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003c8c:	1ad3      	subs	r3, r2, r3
 8003c8e:	2b02      	cmp	r3, #2
 8003c90:	d901      	bls.n	8003c96 <HAL_RCC_OscConfig+0x71a>
        {
          return HAL_TIMEOUT;
 8003c92:	2303      	movs	r3, #3
 8003c94:	e347      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
      while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8003c96:	4b28      	ldr	r3, [pc, #160]	; (8003d38 <HAL_RCC_OscConfig+0x7bc>)
 8003c98:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003c9a:	f003 0301 	and.w	r3, r3, #1
 8003c9e:	2b00      	cmp	r3, #0
 8003ca0:	d0f0      	beq.n	8003c84 <HAL_RCC_OscConfig+0x708>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    if ((pRCC_OscInitStruct->LSEState & RCC_BDCR_LSEON) != 0U)
 8003ca2:	687b      	ldr	r3, [r7, #4]
 8003ca4:	689b      	ldr	r3, [r3, #8]
 8003ca6:	f003 0301 	and.w	r3, r3, #1
 8003caa:	2b00      	cmp	r3, #0
 8003cac:	d01f      	beq.n	8003cee <HAL_RCC_OscConfig+0x772>
    {
      if ((pRCC_OscInitStruct->LSEState & RCC_BDCR_LSEBYP) != 0U)
 8003cae:	687b      	ldr	r3, [r7, #4]
 8003cb0:	689b      	ldr	r3, [r3, #8]
 8003cb2:	f003 0304 	and.w	r3, r3, #4
 8003cb6:	2b00      	cmp	r3, #0
 8003cb8:	d010      	beq.n	8003cdc <HAL_RCC_OscConfig+0x760>
      {
        /* LSE oscillator bypass enable */
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 8003cba:	4b1e      	ldr	r3, [pc, #120]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003cbc:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003cc0:	4a1c      	ldr	r2, [pc, #112]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003cc2:	f043 0304 	orr.w	r3, r3, #4
 8003cc6:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8003cca:	4b1a      	ldr	r3, [pc, #104]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003ccc:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003cd0:	4a18      	ldr	r2, [pc, #96]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003cd2:	f043 0301 	orr.w	r3, r3, #1
 8003cd6:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
 8003cda:	e018      	b.n	8003d0e <HAL_RCC_OscConfig+0x792>
      }
      else
      {
        /* LSE oscillator enable */
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8003cdc:	4b15      	ldr	r3, [pc, #84]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003cde:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003ce2:	4a14      	ldr	r2, [pc, #80]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003ce4:	f043 0301 	orr.w	r3, r3, #1
 8003ce8:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
 8003cec:	e00f      	b.n	8003d0e <HAL_RCC_OscConfig+0x792>
      }
    }
    else
    {
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8003cee:	4b11      	ldr	r3, [pc, #68]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003cf0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003cf4:	4a0f      	ldr	r2, [pc, #60]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003cf6:	f023 0301 	bic.w	r3, r3, #1
 8003cfa:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 8003cfe:	4b0d      	ldr	r3, [pc, #52]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003d00:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003d04:	4a0b      	ldr	r2, [pc, #44]	; (8003d34 <HAL_RCC_OscConfig+0x7b8>)
 8003d06:	f023 0304 	bic.w	r3, r3, #4
 8003d0a:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
    }

    /* Check the LSE State */
    if (pRCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8003d0e:	687b      	ldr	r3, [r7, #4]
 8003d10:	689b      	ldr	r3, [r3, #8]
 8003d12:	2b00      	cmp	r3, #0
 8003d14:	d057      	beq.n	8003dc6 <HAL_RCC_OscConfig+0x84a>
    {
      tickstart = HAL_GetTick();
 8003d16:	f7fd f97f 	bl	8001018 <HAL_GetTick>
 8003d1a:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till LSE is ready */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8003d1c:	e00e      	b.n	8003d3c <HAL_RCC_OscConfig+0x7c0>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003d1e:	f7fd f97b 	bl	8001018 <HAL_GetTick>
 8003d22:	4602      	mov	r2, r0
 8003d24:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003d26:	1ad3      	subs	r3, r2, r3
 8003d28:	f241 3288 	movw	r2, #5000	; 0x1388
 8003d2c:	4293      	cmp	r3, r2
 8003d2e:	d905      	bls.n	8003d3c <HAL_RCC_OscConfig+0x7c0>
        {
          return HAL_TIMEOUT;
 8003d30:	2303      	movs	r3, #3
 8003d32:	e2f8      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
 8003d34:	46020c00 	.word	0x46020c00
 8003d38:	46020800 	.word	0x46020800
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8003d3c:	4b9c      	ldr	r3, [pc, #624]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003d3e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003d42:	f003 0302 	and.w	r3, r3, #2
 8003d46:	2b00      	cmp	r3, #0
 8003d48:	d0e9      	beq.n	8003d1e <HAL_RCC_OscConfig+0x7a2>
        }
      }

      /* Enable LSESYS additionally if requested */
      if ((pRCC_OscInitStruct->LSEState & RCC_BDCR_LSESYSEN) != 0U)
 8003d4a:	687b      	ldr	r3, [r7, #4]
 8003d4c:	689b      	ldr	r3, [r3, #8]
 8003d4e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8003d52:	2b00      	cmp	r3, #0
 8003d54:	d01b      	beq.n	8003d8e <HAL_RCC_OscConfig+0x812>
      {
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8003d56:	4b96      	ldr	r3, [pc, #600]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003d58:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003d5c:	4a94      	ldr	r2, [pc, #592]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003d5e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003d62:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0

        /* Wait till LSESYS is ready */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 8003d66:	e00a      	b.n	8003d7e <HAL_RCC_OscConfig+0x802>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003d68:	f7fd f956 	bl	8001018 <HAL_GetTick>
 8003d6c:	4602      	mov	r2, r0
 8003d6e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003d70:	1ad3      	subs	r3, r2, r3
 8003d72:	f241 3288 	movw	r2, #5000	; 0x1388
 8003d76:	4293      	cmp	r3, r2
 8003d78:	d901      	bls.n	8003d7e <HAL_RCC_OscConfig+0x802>
          {
            return HAL_TIMEOUT;
 8003d7a:	2303      	movs	r3, #3
 8003d7c:	e2d3      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 8003d7e:	4b8c      	ldr	r3, [pc, #560]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003d80:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003d84:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8003d88:	2b00      	cmp	r3, #0
 8003d8a:	d0ed      	beq.n	8003d68 <HAL_RCC_OscConfig+0x7ec>
 8003d8c:	e053      	b.n	8003e36 <HAL_RCC_OscConfig+0x8ba>
        }
      }
      else
      {
        /* Make sure LSESYSEN/LSESYSRDY are reset */
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8003d8e:	4b88      	ldr	r3, [pc, #544]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003d90:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003d94:	4a86      	ldr	r2, [pc, #536]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003d96:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8003d9a:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0

        /* Wait till LSESYSRDY is cleared */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8003d9e:	e00a      	b.n	8003db6 <HAL_RCC_OscConfig+0x83a>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003da0:	f7fd f93a 	bl	8001018 <HAL_GetTick>
 8003da4:	4602      	mov	r2, r0
 8003da6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003da8:	1ad3      	subs	r3, r2, r3
 8003daa:	f241 3288 	movw	r2, #5000	; 0x1388
 8003dae:	4293      	cmp	r3, r2
 8003db0:	d901      	bls.n	8003db6 <HAL_RCC_OscConfig+0x83a>
          {
            return HAL_TIMEOUT;
 8003db2:	2303      	movs	r3, #3
 8003db4:	e2b7      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8003db6:	4b7e      	ldr	r3, [pc, #504]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003db8:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003dbc:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8003dc0:	2b00      	cmp	r3, #0
 8003dc2:	d1ed      	bne.n	8003da0 <HAL_RCC_OscConfig+0x824>
 8003dc4:	e037      	b.n	8003e36 <HAL_RCC_OscConfig+0x8ba>
        }
      }
    }
    else
    {
      tickstart = HAL_GetTick();
 8003dc6:	f7fd f927 	bl	8001018 <HAL_GetTick>
 8003dca:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till LSE is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8003dcc:	e00a      	b.n	8003de4 <HAL_RCC_OscConfig+0x868>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003dce:	f7fd f923 	bl	8001018 <HAL_GetTick>
 8003dd2:	4602      	mov	r2, r0
 8003dd4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003dd6:	1ad3      	subs	r3, r2, r3
 8003dd8:	f241 3288 	movw	r2, #5000	; 0x1388
 8003ddc:	4293      	cmp	r3, r2
 8003dde:	d901      	bls.n	8003de4 <HAL_RCC_OscConfig+0x868>
        {
          return HAL_TIMEOUT;
 8003de0:	2303      	movs	r3, #3
 8003de2:	e2a0      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8003de4:	4b72      	ldr	r3, [pc, #456]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003de6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003dea:	f003 0302 	and.w	r3, r3, #2
 8003dee:	2b00      	cmp	r3, #0
 8003df0:	d1ed      	bne.n	8003dce <HAL_RCC_OscConfig+0x852>
        }
      }

      if (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN) != 0U)
 8003df2:	4b6f      	ldr	r3, [pc, #444]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003df4:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003df8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8003dfc:	2b00      	cmp	r3, #0
 8003dfe:	d01a      	beq.n	8003e36 <HAL_RCC_OscConfig+0x8ba>
      {
        /* Reset LSESYSEN once LSE is disabled */
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8003e00:	4b6b      	ldr	r3, [pc, #428]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003e02:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003e06:	4a6a      	ldr	r2, [pc, #424]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003e08:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8003e0c:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0

        /* Wait till LSESYSRDY is cleared */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8003e10:	e00a      	b.n	8003e28 <HAL_RCC_OscConfig+0x8ac>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003e12:	f7fd f901 	bl	8001018 <HAL_GetTick>
 8003e16:	4602      	mov	r2, r0
 8003e18:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003e1a:	1ad3      	subs	r3, r2, r3
 8003e1c:	f241 3288 	movw	r2, #5000	; 0x1388
 8003e20:	4293      	cmp	r3, r2
 8003e22:	d901      	bls.n	8003e28 <HAL_RCC_OscConfig+0x8ac>
          {
            return HAL_TIMEOUT;
 8003e24:	2303      	movs	r3, #3
 8003e26:	e27e      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8003e28:	4b61      	ldr	r3, [pc, #388]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003e2a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003e2e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8003e32:	2b00      	cmp	r3, #0
 8003e34:	d1ed      	bne.n	8003e12 <HAL_RCC_OscConfig+0x896>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 8003e36:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
 8003e3a:	2b01      	cmp	r3, #1
 8003e3c:	d107      	bne.n	8003e4e <HAL_RCC_OscConfig+0x8d2>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8003e3e:	4b5c      	ldr	r3, [pc, #368]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003e40:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003e44:	4a5a      	ldr	r2, [pc, #360]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003e46:	f023 0304 	bic.w	r3, r3, #4
 8003e4a:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    }
  }
  /*------------------------------ HSI48 Configuration -----------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8003e4e:	687b      	ldr	r3, [r7, #4]
 8003e50:	681b      	ldr	r3, [r3, #0]
 8003e52:	f003 0320 	and.w	r3, r3, #32
 8003e56:	2b00      	cmp	r3, #0
 8003e58:	d036      	beq.n	8003ec8 <HAL_RCC_OscConfig+0x94c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(pRCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if (pRCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8003e5a:	687b      	ldr	r3, [r7, #4]
 8003e5c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003e5e:	2b00      	cmp	r3, #0
 8003e60:	d019      	beq.n	8003e96 <HAL_RCC_OscConfig+0x91a>
    {
      /* Enable the Internal High Speed oscillator (HSI48) */
      __HAL_RCC_HSI48_ENABLE();
 8003e62:	4b53      	ldr	r3, [pc, #332]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003e64:	681b      	ldr	r3, [r3, #0]
 8003e66:	4a52      	ldr	r2, [pc, #328]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003e68:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8003e6c:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 8003e6e:	f7fd f8d3 	bl	8001018 <HAL_GetTick>
 8003e72:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till HSI48 is ready */
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) == 0U)
 8003e74:	e008      	b.n	8003e88 <HAL_RCC_OscConfig+0x90c>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8003e76:	f7fd f8cf 	bl	8001018 <HAL_GetTick>
 8003e7a:	4602      	mov	r2, r0
 8003e7c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003e7e:	1ad3      	subs	r3, r2, r3
 8003e80:	2b02      	cmp	r3, #2
 8003e82:	d901      	bls.n	8003e88 <HAL_RCC_OscConfig+0x90c>
        {
          return HAL_TIMEOUT;
 8003e84:	2303      	movs	r3, #3
 8003e86:	e24e      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) == 0U)
 8003e88:	4b49      	ldr	r3, [pc, #292]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003e8a:	681b      	ldr	r3, [r3, #0]
 8003e8c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8003e90:	2b00      	cmp	r3, #0
 8003e92:	d0f0      	beq.n	8003e76 <HAL_RCC_OscConfig+0x8fa>
 8003e94:	e018      	b.n	8003ec8 <HAL_RCC_OscConfig+0x94c>
      }
    }
    else
    {
      /* Disable the Internal High Speed oscillator (HSI48) */
      __HAL_RCC_HSI48_DISABLE();
 8003e96:	4b46      	ldr	r3, [pc, #280]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003e98:	681b      	ldr	r3, [r3, #0]
 8003e9a:	4a45      	ldr	r2, [pc, #276]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003e9c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8003ea0:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 8003ea2:	f7fd f8b9 	bl	8001018 <HAL_GetTick>
 8003ea6:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till HSI48 is disabled */
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) != 0U)
 8003ea8:	e008      	b.n	8003ebc <HAL_RCC_OscConfig+0x940>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8003eaa:	f7fd f8b5 	bl	8001018 <HAL_GetTick>
 8003eae:	4602      	mov	r2, r0
 8003eb0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003eb2:	1ad3      	subs	r3, r2, r3
 8003eb4:	2b02      	cmp	r3, #2
 8003eb6:	d901      	bls.n	8003ebc <HAL_RCC_OscConfig+0x940>
        {
          return HAL_TIMEOUT;
 8003eb8:	2303      	movs	r3, #3
 8003eba:	e234      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) != 0U)
 8003ebc:	4b3c      	ldr	r3, [pc, #240]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003ebe:	681b      	ldr	r3, [r3, #0]
 8003ec0:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8003ec4:	2b00      	cmp	r3, #0
 8003ec6:	d1f0      	bne.n	8003eaa <HAL_RCC_OscConfig+0x92e>
      }
    }
  }

  /*------------------------------ SHSI Configuration -----------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_SHSI) == RCC_OSCILLATORTYPE_SHSI)
 8003ec8:	687b      	ldr	r3, [r7, #4]
 8003eca:	681b      	ldr	r3, [r3, #0]
 8003ecc:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8003ed0:	2b00      	cmp	r3, #0
 8003ed2:	d036      	beq.n	8003f42 <HAL_RCC_OscConfig+0x9c6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SHSI(pRCC_OscInitStruct->SHSIState));

    /* Check the SHSI State */
    if (pRCC_OscInitStruct->SHSIState != RCC_SHSI_OFF)
 8003ed4:	687b      	ldr	r3, [r7, #4]
 8003ed6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003ed8:	2b00      	cmp	r3, #0
 8003eda:	d019      	beq.n	8003f10 <HAL_RCC_OscConfig+0x994>
    {
      /* Enable the Secure Internal High Speed oscillator (SHSI) */
      __HAL_RCC_SHSI_ENABLE();
 8003edc:	4b34      	ldr	r3, [pc, #208]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003ede:	681b      	ldr	r3, [r3, #0]
 8003ee0:	4a33      	ldr	r2, [pc, #204]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003ee2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003ee6:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 8003ee8:	f7fd f896 	bl	8001018 <HAL_GetTick>
 8003eec:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till SHSI is ready */
      while (READ_BIT(RCC->CR, RCC_CR_SHSIRDY) == 0U)
 8003eee:	e008      	b.n	8003f02 <HAL_RCC_OscConfig+0x986>
      {
        if ((HAL_GetTick() - tickstart) > SHSI_TIMEOUT_VALUE)
 8003ef0:	f7fd f892 	bl	8001018 <HAL_GetTick>
 8003ef4:	4602      	mov	r2, r0
 8003ef6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003ef8:	1ad3      	subs	r3, r2, r3
 8003efa:	2b02      	cmp	r3, #2
 8003efc:	d901      	bls.n	8003f02 <HAL_RCC_OscConfig+0x986>
        {
          return HAL_TIMEOUT;
 8003efe:	2303      	movs	r3, #3
 8003f00:	e211      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_SHSIRDY) == 0U)
 8003f02:	4b2b      	ldr	r3, [pc, #172]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003f04:	681b      	ldr	r3, [r3, #0]
 8003f06:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8003f0a:	2b00      	cmp	r3, #0
 8003f0c:	d0f0      	beq.n	8003ef0 <HAL_RCC_OscConfig+0x974>
 8003f0e:	e018      	b.n	8003f42 <HAL_RCC_OscConfig+0x9c6>
      }
    }
    else
    {
      /* Disable the Secure Internal High Speed oscillator (SHSI) */
      __HAL_RCC_SHSI_DISABLE();
 8003f10:	4b27      	ldr	r3, [pc, #156]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003f12:	681b      	ldr	r3, [r3, #0]
 8003f14:	4a26      	ldr	r2, [pc, #152]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003f16:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003f1a:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 8003f1c:	f7fd f87c 	bl	8001018 <HAL_GetTick>
 8003f20:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till SHSI is disabled */
      while (READ_BIT(RCC->CR, RCC_CR_SHSIRDY) != 0U)
 8003f22:	e008      	b.n	8003f36 <HAL_RCC_OscConfig+0x9ba>
      {
        if ((HAL_GetTick() - tickstart) > SHSI_TIMEOUT_VALUE)
 8003f24:	f7fd f878 	bl	8001018 <HAL_GetTick>
 8003f28:	4602      	mov	r2, r0
 8003f2a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003f2c:	1ad3      	subs	r3, r2, r3
 8003f2e:	2b02      	cmp	r3, #2
 8003f30:	d901      	bls.n	8003f36 <HAL_RCC_OscConfig+0x9ba>
        {
          return HAL_TIMEOUT;
 8003f32:	2303      	movs	r3, #3
 8003f34:	e1f7      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_SHSIRDY) != 0U)
 8003f36:	4b1e      	ldr	r3, [pc, #120]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003f38:	681b      	ldr	r3, [r3, #0]
 8003f3a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8003f3e:	2b00      	cmp	r3, #0
 8003f40:	d1f0      	bne.n	8003f24 <HAL_RCC_OscConfig+0x9a8>
        }
      }
    }
  }
  /*------------------------------ MSIK Configuration -----------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSIK) == RCC_OSCILLATORTYPE_MSIK)
 8003f42:	687b      	ldr	r3, [r7, #4]
 8003f44:	681b      	ldr	r3, [r3, #0]
 8003f46:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8003f4a:	2b00      	cmp	r3, #0
 8003f4c:	d07f      	beq.n	800404e <HAL_RCC_OscConfig+0xad2>
    assert_param(IS_RCC_MSIK(pRCC_OscInitStruct->MSIKState));
    assert_param(IS_RCC_MSIK_CLOCK_RANGE(pRCC_OscInitStruct->MSIKClockRange));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

    /* Check the MSIK State */
    if (pRCC_OscInitStruct->MSIKState != RCC_MSIK_OFF)
 8003f4e:	687b      	ldr	r3, [r7, #4]
 8003f50:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003f52:	2b00      	cmp	r3, #0
 8003f54:	d062      	beq.n	800401c <HAL_RCC_OscConfig+0xaa0>
    {

      /* Selects the Multiple Speed of kernel high speed oscillator (MSIK) clock range .*/
      __HAL_RCC_MSIK_RANGE_CONFIG(pRCC_OscInitStruct->MSIKClockRange);
 8003f56:	4b16      	ldr	r3, [pc, #88]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003f58:	689b      	ldr	r3, [r3, #8]
 8003f5a:	4a15      	ldr	r2, [pc, #84]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003f5c:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8003f60:	6093      	str	r3, [r2, #8]
 8003f62:	4b13      	ldr	r3, [pc, #76]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003f64:	689b      	ldr	r3, [r3, #8]
 8003f66:	f023 6270 	bic.w	r2, r3, #251658240	; 0xf000000
 8003f6a:	687b      	ldr	r3, [r7, #4]
 8003f6c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003f6e:	4910      	ldr	r1, [pc, #64]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003f70:	4313      	orrs	r3, r2
 8003f72:	608b      	str	r3, [r1, #8]
      /* Adjusts the Multiple Speed of kernel high speed oscillator (MSIK) calibration value.*/
      __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST((pRCC_OscInitStruct->MSICalibrationValue), \
 8003f74:	687b      	ldr	r3, [r7, #4]
 8003f76:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003f78:	f1b3 4f40 	cmp.w	r3, #3221225472	; 0xc0000000
 8003f7c:	d309      	bcc.n	8003f92 <HAL_RCC_OscConfig+0xa16>
 8003f7e:	4b0c      	ldr	r3, [pc, #48]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003f80:	68db      	ldr	r3, [r3, #12]
 8003f82:	f023 021f 	bic.w	r2, r3, #31
 8003f86:	687b      	ldr	r3, [r7, #4]
 8003f88:	6a1b      	ldr	r3, [r3, #32]
 8003f8a:	4909      	ldr	r1, [pc, #36]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003f8c:	4313      	orrs	r3, r2
 8003f8e:	60cb      	str	r3, [r1, #12]
 8003f90:	e02a      	b.n	8003fe8 <HAL_RCC_OscConfig+0xa6c>
 8003f92:	687b      	ldr	r3, [r7, #4]
 8003f94:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003f96:	2b00      	cmp	r3, #0
 8003f98:	da0c      	bge.n	8003fb4 <HAL_RCC_OscConfig+0xa38>
 8003f9a:	4b05      	ldr	r3, [pc, #20]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003f9c:	68db      	ldr	r3, [r3, #12]
 8003f9e:	f423 7278 	bic.w	r2, r3, #992	; 0x3e0
 8003fa2:	687b      	ldr	r3, [r7, #4]
 8003fa4:	6a1b      	ldr	r3, [r3, #32]
 8003fa6:	015b      	lsls	r3, r3, #5
 8003fa8:	4901      	ldr	r1, [pc, #4]	; (8003fb0 <HAL_RCC_OscConfig+0xa34>)
 8003faa:	4313      	orrs	r3, r2
 8003fac:	60cb      	str	r3, [r1, #12]
 8003fae:	e01b      	b.n	8003fe8 <HAL_RCC_OscConfig+0xa6c>
 8003fb0:	46020c00 	.word	0x46020c00
 8003fb4:	687b      	ldr	r3, [r7, #4]
 8003fb6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003fb8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8003fbc:	d30a      	bcc.n	8003fd4 <HAL_RCC_OscConfig+0xa58>
 8003fbe:	4ba1      	ldr	r3, [pc, #644]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8003fc0:	68db      	ldr	r3, [r3, #12]
 8003fc2:	f423 42f8 	bic.w	r2, r3, #31744	; 0x7c00
 8003fc6:	687b      	ldr	r3, [r7, #4]
 8003fc8:	6a1b      	ldr	r3, [r3, #32]
 8003fca:	029b      	lsls	r3, r3, #10
 8003fcc:	499d      	ldr	r1, [pc, #628]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8003fce:	4313      	orrs	r3, r2
 8003fd0:	60cb      	str	r3, [r1, #12]
 8003fd2:	e009      	b.n	8003fe8 <HAL_RCC_OscConfig+0xa6c>
 8003fd4:	4b9b      	ldr	r3, [pc, #620]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8003fd6:	68db      	ldr	r3, [r3, #12]
 8003fd8:	f423 2278 	bic.w	r2, r3, #1015808	; 0xf8000
 8003fdc:	687b      	ldr	r3, [r7, #4]
 8003fde:	6a1b      	ldr	r3, [r3, #32]
 8003fe0:	03db      	lsls	r3, r3, #15
 8003fe2:	4998      	ldr	r1, [pc, #608]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8003fe4:	4313      	orrs	r3, r2
 8003fe6:	60cb      	str	r3, [r1, #12]
                                            (pRCC_OscInitStruct->MSIClockRange));

      /* Enable the Internal kernel High Speed oscillator (MSIK) */
      __HAL_RCC_MSIK_ENABLE();
 8003fe8:	4b96      	ldr	r3, [pc, #600]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8003fea:	681b      	ldr	r3, [r3, #0]
 8003fec:	4a95      	ldr	r2, [pc, #596]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8003fee:	f043 0310 	orr.w	r3, r3, #16
 8003ff2:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 8003ff4:	f7fd f810 	bl	8001018 <HAL_GetTick>
 8003ff8:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till MSIK is ready */
      while (READ_BIT(RCC->CR, RCC_CR_MSIKRDY) == 0U)
 8003ffa:	e008      	b.n	800400e <HAL_RCC_OscConfig+0xa92>
      {
        if ((HAL_GetTick() - tickstart) > MSIK_TIMEOUT_VALUE)
 8003ffc:	f7fd f80c 	bl	8001018 <HAL_GetTick>
 8004000:	4602      	mov	r2, r0
 8004002:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004004:	1ad3      	subs	r3, r2, r3
 8004006:	2b02      	cmp	r3, #2
 8004008:	d901      	bls.n	800400e <HAL_RCC_OscConfig+0xa92>
        {
          return HAL_TIMEOUT;
 800400a:	2303      	movs	r3, #3
 800400c:	e18b      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_MSIKRDY) == 0U)
 800400e:	4b8d      	ldr	r3, [pc, #564]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004010:	681b      	ldr	r3, [r3, #0]
 8004012:	f003 0320 	and.w	r3, r3, #32
 8004016:	2b00      	cmp	r3, #0
 8004018:	d0f0      	beq.n	8003ffc <HAL_RCC_OscConfig+0xa80>
 800401a:	e018      	b.n	800404e <HAL_RCC_OscConfig+0xad2>
      }
    }
    else
    {
      /* Disable the Internal High Speed Kernel oscillator (MSIK) */
      __HAL_RCC_MSIK_DISABLE();
 800401c:	4b89      	ldr	r3, [pc, #548]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 800401e:	681b      	ldr	r3, [r3, #0]
 8004020:	4a88      	ldr	r2, [pc, #544]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004022:	f023 0310 	bic.w	r3, r3, #16
 8004026:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 8004028:	f7fc fff6 	bl	8001018 <HAL_GetTick>
 800402c:	62b8      	str	r0, [r7, #40]	; 0x28

      /* Wait till MSIK is disabled */
      while (READ_BIT(RCC->CR, RCC_CR_MSIKRDY) != 0U)
 800402e:	e008      	b.n	8004042 <HAL_RCC_OscConfig+0xac6>
      {
        if ((HAL_GetTick() - tickstart) > MSIK_TIMEOUT_VALUE)
 8004030:	f7fc fff2 	bl	8001018 <HAL_GetTick>
 8004034:	4602      	mov	r2, r0
 8004036:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004038:	1ad3      	subs	r3, r2, r3
 800403a:	2b02      	cmp	r3, #2
 800403c:	d901      	bls.n	8004042 <HAL_RCC_OscConfig+0xac6>
        {
          return HAL_TIMEOUT;
 800403e:	2303      	movs	r3, #3
 8004040:	e171      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_MSIKRDY) != 0U)
 8004042:	4b80      	ldr	r3, [pc, #512]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004044:	681b      	ldr	r3, [r3, #0]
 8004046:	f003 0320 	and.w	r3, r3, #32
 800404a:	2b00      	cmp	r3, #0
 800404c:	d1f0      	bne.n	8004030 <HAL_RCC_OscConfig+0xab4>
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL.PLLState));

  if ((pRCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800404e:	687b      	ldr	r3, [r7, #4]
 8004050:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004052:	2b00      	cmp	r3, #0
 8004054:	f000 8166 	beq.w	8004324 <HAL_RCC_OscConfig+0xda8>
  {
    FlagStatus  pwrclkchanged = RESET;
 8004058:	2300      	movs	r3, #0
 800405a:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34

    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800405e:	4b79      	ldr	r3, [pc, #484]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004060:	69db      	ldr	r3, [r3, #28]
 8004062:	f003 030c 	and.w	r3, r3, #12
 8004066:	2b0c      	cmp	r3, #12
 8004068:	f000 80f2 	beq.w	8004250 <HAL_RCC_OscConfig+0xcd4>
    {
      if ((pRCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800406c:	687b      	ldr	r3, [r7, #4]
 800406e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004070:	2b02      	cmp	r3, #2
 8004072:	f040 80c5 	bne.w	8004200 <HAL_RCC_OscConfig+0xc84>
        assert_param(IS_RCC_PLLP_VALUE(pRCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(pRCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(pRCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL */
        __HAL_RCC_PLL_DISABLE();
 8004076:	4b73      	ldr	r3, [pc, #460]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004078:	681b      	ldr	r3, [r3, #0]
 800407a:	4a72      	ldr	r2, [pc, #456]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 800407c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8004080:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8004082:	f7fc ffc9 	bl	8001018 <HAL_GetTick>
 8004086:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 8004088:	e008      	b.n	800409c <HAL_RCC_OscConfig+0xb20>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800408a:	f7fc ffc5 	bl	8001018 <HAL_GetTick>
 800408e:	4602      	mov	r2, r0
 8004090:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004092:	1ad3      	subs	r3, r2, r3
 8004094:	2b02      	cmp	r3, #2
 8004096:	d901      	bls.n	800409c <HAL_RCC_OscConfig+0xb20>
          {
            return HAL_TIMEOUT;
 8004098:	2303      	movs	r3, #3
 800409a:	e144      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 800409c:	4b69      	ldr	r3, [pc, #420]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 800409e:	681b      	ldr	r3, [r3, #0]
 80040a0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80040a4:	2b00      	cmp	r3, #0
 80040a6:	d1f0      	bne.n	800408a <HAL_RCC_OscConfig+0xb0e>
          }
        }

        /* Requires to enable write access to Backup Domain of necessary */
        if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 80040a8:	4b66      	ldr	r3, [pc, #408]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 80040aa:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80040ae:	f003 0304 	and.w	r3, r3, #4
 80040b2:	2b00      	cmp	r3, #0
 80040b4:	d111      	bne.n	80040da <HAL_RCC_OscConfig+0xb5e>
        {
          __HAL_RCC_PWR_CLK_ENABLE();
 80040b6:	4b63      	ldr	r3, [pc, #396]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 80040b8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80040bc:	4a61      	ldr	r2, [pc, #388]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 80040be:	f043 0304 	orr.w	r3, r3, #4
 80040c2:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 80040c6:	4b5f      	ldr	r3, [pc, #380]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 80040c8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80040cc:	f003 0304 	and.w	r3, r3, #4
 80040d0:	60fb      	str	r3, [r7, #12]
 80040d2:	68fb      	ldr	r3, [r7, #12]
          pwrclkchanged = SET;
 80040d4:	2301      	movs	r3, #1
 80040d6:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
        }

        /*Disable EPOD to configure PLL1MBOOST*/
        if (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN) == PWR_VOSR_BOOSTEN)
 80040da:	4b5b      	ldr	r3, [pc, #364]	; (8004248 <HAL_RCC_OscConfig+0xccc>)
 80040dc:	68db      	ldr	r3, [r3, #12]
 80040de:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80040e2:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 80040e6:	d102      	bne.n	80040ee <HAL_RCC_OscConfig+0xb72>
        {
          pwrboosten = SET;
 80040e8:	2301      	movs	r3, #1
 80040ea:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        }
        CLEAR_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN);
 80040ee:	4b56      	ldr	r3, [pc, #344]	; (8004248 <HAL_RCC_OscConfig+0xccc>)
 80040f0:	68db      	ldr	r3, [r3, #12]
 80040f2:	4a55      	ldr	r2, [pc, #340]	; (8004248 <HAL_RCC_OscConfig+0xccc>)
 80040f4:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80040f8:	60d3      	str	r3, [r2, #12]

        /* Configure the main PLL clock source, multiplication and division factors */
        __HAL_RCC_PLL_CONFIG(pRCC_OscInitStruct->PLL.PLLSource,
 80040fa:	4b52      	ldr	r3, [pc, #328]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 80040fc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80040fe:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8004102:	f023 0303 	bic.w	r3, r3, #3
 8004106:	687a      	ldr	r2, [r7, #4]
 8004108:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
 800410a:	687a      	ldr	r2, [r7, #4]
 800410c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800410e:	3a01      	subs	r2, #1
 8004110:	0212      	lsls	r2, r2, #8
 8004112:	4311      	orrs	r1, r2
 8004114:	687a      	ldr	r2, [r7, #4]
 8004116:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8004118:	430a      	orrs	r2, r1
 800411a:	494a      	ldr	r1, [pc, #296]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 800411c:	4313      	orrs	r3, r2
 800411e:	628b      	str	r3, [r1, #40]	; 0x28
 8004120:	4b48      	ldr	r3, [pc, #288]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004122:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004124:	4b49      	ldr	r3, [pc, #292]	; (800424c <HAL_RCC_OscConfig+0xcd0>)
 8004126:	4013      	ands	r3, r2
 8004128:	687a      	ldr	r2, [r7, #4]
 800412a:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800412c:	3a01      	subs	r2, #1
 800412e:	f3c2 0108 	ubfx	r1, r2, #0, #9
 8004132:	687a      	ldr	r2, [r7, #4]
 8004134:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8004136:	3a01      	subs	r2, #1
 8004138:	0252      	lsls	r2, r2, #9
 800413a:	b292      	uxth	r2, r2
 800413c:	4311      	orrs	r1, r2
 800413e:	687a      	ldr	r2, [r7, #4]
 8004140:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8004142:	3a01      	subs	r2, #1
 8004144:	0412      	lsls	r2, r2, #16
 8004146:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
 800414a:	4311      	orrs	r1, r2
 800414c:	687a      	ldr	r2, [r7, #4]
 800414e:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8004150:	3a01      	subs	r2, #1
 8004152:	0612      	lsls	r2, r2, #24
 8004154:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
 8004158:	430a      	orrs	r2, r1
 800415a:	493a      	ldr	r1, [pc, #232]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 800415c:	4313      	orrs	r3, r2
 800415e:	634b      	str	r3, [r1, #52]	; 0x34
                             pRCC_OscInitStruct->PLL.PLLR);

        assert_param(IS_RCC_PLL_FRACN_VALUE(pRCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable PLL1FRACN  */
        __HAL_RCC_PLL_FRACN_DISABLE();
 8004160:	4b38      	ldr	r3, [pc, #224]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004162:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004164:	4a37      	ldr	r2, [pc, #220]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004166:	f023 0310 	bic.w	r3, r3, #16
 800416a:	6293      	str	r3, [r2, #40]	; 0x28

        /* Configure PLL  PLL1FRACN */
        __HAL_RCC_PLL_FRACN_CONFIG(pRCC_OscInitStruct->PLL.PLLFRACN);
 800416c:	687b      	ldr	r3, [r7, #4]
 800416e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004170:	4a34      	ldr	r2, [pc, #208]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004172:	00db      	lsls	r3, r3, #3
 8004174:	6393      	str	r3, [r2, #56]	; 0x38

        /* Enable PLL1FRACN  */
        __HAL_RCC_PLL_FRACN_ENABLE();
 8004176:	4b33      	ldr	r3, [pc, #204]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004178:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800417a:	4a32      	ldr	r2, [pc, #200]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 800417c:	f043 0310 	orr.w	r3, r3, #16
 8004180:	6293      	str	r3, [r2, #40]	; 0x28

        assert_param(IS_RCC_PLLRGE_VALUE(pRCC_OscInitStruct->PLL.PLLRGE));

        /* Select PLL1 input reference frequency range: VCI */
        __HAL_RCC_PLL_VCIRANGE(pRCC_OscInitStruct->PLL.PLLRGE);
 8004182:	4b30      	ldr	r3, [pc, #192]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004184:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004186:	f023 020c 	bic.w	r2, r3, #12
 800418a:	687b      	ldr	r3, [r7, #4]
 800418c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800418e:	492d      	ldr	r1, [pc, #180]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004190:	4313      	orrs	r3, r2
 8004192:	628b      	str	r3, [r1, #40]	; 0x28

        if (pwrboosten == SET)
 8004194:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8004198:	2b01      	cmp	r3, #1
 800419a:	d105      	bne.n	80041a8 <HAL_RCC_OscConfig+0xc2c>
        {
          /* Enable the EPOD to reach max frequency */
          SET_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN);
 800419c:	4b2a      	ldr	r3, [pc, #168]	; (8004248 <HAL_RCC_OscConfig+0xccc>)
 800419e:	68db      	ldr	r3, [r3, #12]
 80041a0:	4a29      	ldr	r2, [pc, #164]	; (8004248 <HAL_RCC_OscConfig+0xccc>)
 80041a2:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80041a6:	60d3      	str	r3, [r2, #12]
        }

        /* Restore clock configuration if changed */
        if (pwrclkchanged == SET)
 80041a8:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 80041ac:	2b01      	cmp	r3, #1
 80041ae:	d107      	bne.n	80041c0 <HAL_RCC_OscConfig+0xc44>
        {
          __HAL_RCC_PWR_CLK_DISABLE();
 80041b0:	4b24      	ldr	r3, [pc, #144]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 80041b2:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80041b6:	4a23      	ldr	r2, [pc, #140]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 80041b8:	f023 0304 	bic.w	r3, r3, #4
 80041bc:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
        }

        /* Enable PLL System Clock output */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
 80041c0:	4b20      	ldr	r3, [pc, #128]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 80041c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80041c4:	4a1f      	ldr	r2, [pc, #124]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 80041c6:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80041ca:	6293      	str	r3, [r2, #40]	; 0x28

        /* Enable the main PLL */
        __HAL_RCC_PLL_ENABLE();
 80041cc:	4b1d      	ldr	r3, [pc, #116]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 80041ce:	681b      	ldr	r3, [r3, #0]
 80041d0:	4a1c      	ldr	r2, [pc, #112]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 80041d2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80041d6:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 80041d8:	f7fc ff1e 	bl	8001018 <HAL_GetTick>
 80041dc:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till PLL is ready */
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
 80041de:	e008      	b.n	80041f2 <HAL_RCC_OscConfig+0xc76>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80041e0:	f7fc ff1a 	bl	8001018 <HAL_GetTick>
 80041e4:	4602      	mov	r2, r0
 80041e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80041e8:	1ad3      	subs	r3, r2, r3
 80041ea:	2b02      	cmp	r3, #2
 80041ec:	d901      	bls.n	80041f2 <HAL_RCC_OscConfig+0xc76>
          {
            return HAL_TIMEOUT;
 80041ee:	2303      	movs	r3, #3
 80041f0:	e099      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
 80041f2:	4b14      	ldr	r3, [pc, #80]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 80041f4:	681b      	ldr	r3, [r3, #0]
 80041f6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80041fa:	2b00      	cmp	r3, #0
 80041fc:	d0f0      	beq.n	80041e0 <HAL_RCC_OscConfig+0xc64>
 80041fe:	e091      	b.n	8004324 <HAL_RCC_OscConfig+0xda8>
        }
      }
      else
      {
        /* Disable the main PLL */
        __HAL_RCC_PLL_DISABLE();
 8004200:	4b10      	ldr	r3, [pc, #64]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004202:	681b      	ldr	r3, [r3, #0]
 8004204:	4a0f      	ldr	r2, [pc, #60]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004206:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800420a:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 800420c:	f7fc ff04 	bl	8001018 <HAL_GetTick>
 8004210:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 8004212:	e008      	b.n	8004226 <HAL_RCC_OscConfig+0xcaa>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8004214:	f7fc ff00 	bl	8001018 <HAL_GetTick>
 8004218:	4602      	mov	r2, r0
 800421a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800421c:	1ad3      	subs	r3, r2, r3
 800421e:	2b02      	cmp	r3, #2
 8004220:	d901      	bls.n	8004226 <HAL_RCC_OscConfig+0xcaa>
          {
            return HAL_TIMEOUT;
 8004222:	2303      	movs	r3, #3
 8004224:	e07f      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 8004226:	4b07      	ldr	r3, [pc, #28]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004228:	681b      	ldr	r3, [r3, #0]
 800422a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800422e:	2b00      	cmp	r3, #0
 8004230:	d1f0      	bne.n	8004214 <HAL_RCC_OscConfig+0xc98>
          }
        }

        /* Unselect main PLL clock source and disable main PLL outputs to save power */
        RCC->PLL1CFGR &= ~(RCC_PLL1CFGR_PLL1SRC | RCC_PLL1CFGR_PLL1PEN | RCC_PLL1CFGR_PLL1QEN | RCC_PLL1CFGR_PLL1REN);
 8004232:	4b04      	ldr	r3, [pc, #16]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004234:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004236:	4a03      	ldr	r2, [pc, #12]	; (8004244 <HAL_RCC_OscConfig+0xcc8>)
 8004238:	f423 23e0 	bic.w	r3, r3, #458752	; 0x70000
 800423c:	f023 0303 	bic.w	r3, r3, #3
 8004240:	6293      	str	r3, [r2, #40]	; 0x28
 8004242:	e06f      	b.n	8004324 <HAL_RCC_OscConfig+0xda8>
 8004244:	46020c00 	.word	0x46020c00
 8004248:	46020800 	.word	0x46020800
 800424c:	80800000 	.word	0x80800000
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp1_pllckcfg = RCC->PLL1CFGR;
 8004250:	4b37      	ldr	r3, [pc, #220]	; (8004330 <HAL_RCC_OscConfig+0xdb4>)
 8004252:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004254:	61fb      	str	r3, [r7, #28]
      temp2_pllckcfg = RCC->PLL1DIVR;
 8004256:	4b36      	ldr	r3, [pc, #216]	; (8004330 <HAL_RCC_OscConfig+0xdb4>)
 8004258:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800425a:	61bb      	str	r3, [r7, #24]
      if (((pRCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800425c:	687b      	ldr	r3, [r7, #4]
 800425e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004260:	2b01      	cmp	r3, #1
 8004262:	d039      	beq.n	80042d8 <HAL_RCC_OscConfig+0xd5c>
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1SRC) != pRCC_OscInitStruct->PLL.PLLSource) ||
 8004264:	69fb      	ldr	r3, [r7, #28]
 8004266:	f003 0203 	and.w	r2, r3, #3
 800426a:	687b      	ldr	r3, [r7, #4]
 800426c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
      if (((pRCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800426e:	429a      	cmp	r2, r3
 8004270:	d132      	bne.n	80042d8 <HAL_RCC_OscConfig+0xd5c>
          ((READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1M) >> \
 8004272:	69fb      	ldr	r3, [r7, #28]
 8004274:	0a1b      	lsrs	r3, r3, #8
 8004276:	f003 020f 	and.w	r2, r3, #15
            RCC_PLL1CFGR_PLL1M_Pos) != (pRCC_OscInitStruct->PLL.PLLM - 1U)) ||
 800427a:	687b      	ldr	r3, [r7, #4]
 800427c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800427e:	3b01      	subs	r3, #1
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1SRC) != pRCC_OscInitStruct->PLL.PLLSource) ||
 8004280:	429a      	cmp	r2, r3
 8004282:	d129      	bne.n	80042d8 <HAL_RCC_OscConfig+0xd5c>
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1MBOOST) != pRCC_OscInitStruct->PLL.PLLMBOOST) ||
 8004284:	69fb      	ldr	r3, [r7, #28]
 8004286:	f403 4270 	and.w	r2, r3, #61440	; 0xf000
 800428a:	687b      	ldr	r3, [r7, #4]
 800428c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
            RCC_PLL1CFGR_PLL1M_Pos) != (pRCC_OscInitStruct->PLL.PLLM - 1U)) ||
 800428e:	429a      	cmp	r2, r3
 8004290:	d122      	bne.n	80042d8 <HAL_RCC_OscConfig+0xd5c>
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1N) != (pRCC_OscInitStruct->PLL.PLLN - 1U)) ||
 8004292:	69bb      	ldr	r3, [r7, #24]
 8004294:	f3c3 0208 	ubfx	r2, r3, #0, #9
 8004298:	687b      	ldr	r3, [r7, #4]
 800429a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800429c:	3b01      	subs	r3, #1
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1MBOOST) != pRCC_OscInitStruct->PLL.PLLMBOOST) ||
 800429e:	429a      	cmp	r2, r3
 80042a0:	d11a      	bne.n	80042d8 <HAL_RCC_OscConfig+0xd5c>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1P) >> \
 80042a2:	69bb      	ldr	r3, [r7, #24]
 80042a4:	0a5b      	lsrs	r3, r3, #9
 80042a6:	f003 027f 	and.w	r2, r3, #127	; 0x7f
            RCC_PLL1DIVR_PLL1P_Pos) != (pRCC_OscInitStruct->PLL.PLLP - 1U)) ||
 80042aa:	687b      	ldr	r3, [r7, #4]
 80042ac:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80042ae:	3b01      	subs	r3, #1
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1N) != (pRCC_OscInitStruct->PLL.PLLN - 1U)) ||
 80042b0:	429a      	cmp	r2, r3
 80042b2:	d111      	bne.n	80042d8 <HAL_RCC_OscConfig+0xd5c>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1Q) >> \
 80042b4:	69bb      	ldr	r3, [r7, #24]
 80042b6:	0c1b      	lsrs	r3, r3, #16
 80042b8:	f003 027f 	and.w	r2, r3, #127	; 0x7f
            RCC_PLL1DIVR_PLL1Q_Pos) != (pRCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 80042bc:	687b      	ldr	r3, [r7, #4]
 80042be:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80042c0:	3b01      	subs	r3, #1
            RCC_PLL1DIVR_PLL1P_Pos) != (pRCC_OscInitStruct->PLL.PLLP - 1U)) ||
 80042c2:	429a      	cmp	r2, r3
 80042c4:	d108      	bne.n	80042d8 <HAL_RCC_OscConfig+0xd5c>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1R) >> \
 80042c6:	69bb      	ldr	r3, [r7, #24]
 80042c8:	0e1b      	lsrs	r3, r3, #24
 80042ca:	f003 027f 	and.w	r2, r3, #127	; 0x7f
            RCC_PLL1DIVR_PLL1R_Pos) != (pRCC_OscInitStruct->PLL.PLLR - 1U)))
 80042ce:	687b      	ldr	r3, [r7, #4]
 80042d0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80042d2:	3b01      	subs	r3, #1
            RCC_PLL1DIVR_PLL1Q_Pos) != (pRCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 80042d4:	429a      	cmp	r2, r3
 80042d6:	d001      	beq.n	80042dc <HAL_RCC_OscConfig+0xd60>
      {
        return HAL_ERROR;
 80042d8:	2301      	movs	r3, #1
 80042da:	e024      	b.n	8004326 <HAL_RCC_OscConfig+0xdaa>
      }

      /* FRACN1 on-the-fly value update */
      if ((READ_BIT(RCC->PLL1FRACR, RCC_PLL1FRACR_PLL1FRACN) >> \
 80042dc:	4b14      	ldr	r3, [pc, #80]	; (8004330 <HAL_RCC_OscConfig+0xdb4>)
 80042de:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80042e0:	08db      	lsrs	r3, r3, #3
 80042e2:	f3c3 020c 	ubfx	r2, r3, #0, #13
           RCC_PLL1FRACR_PLL1FRACN_Pos) != (pRCC_OscInitStruct->PLL.PLLFRACN))
 80042e6:	687b      	ldr	r3, [r7, #4]
 80042e8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
      if ((READ_BIT(RCC->PLL1FRACR, RCC_PLL1FRACR_PLL1FRACN) >> \
 80042ea:	429a      	cmp	r2, r3
 80042ec:	d01a      	beq.n	8004324 <HAL_RCC_OscConfig+0xda8>
      {
        assert_param(IS_RCC_PLL_FRACN_VALUE(pRCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable PLL1FRACN. */
        __HAL_RCC_PLL_FRACN_DISABLE();
 80042ee:	4b10      	ldr	r3, [pc, #64]	; (8004330 <HAL_RCC_OscConfig+0xdb4>)
 80042f0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80042f2:	4a0f      	ldr	r2, [pc, #60]	; (8004330 <HAL_RCC_OscConfig+0xdb4>)
 80042f4:	f023 0310 	bic.w	r3, r3, #16
 80042f8:	6293      	str	r3, [r2, #40]	; 0x28

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80042fa:	f7fc fe8d 	bl	8001018 <HAL_GetTick>
 80042fe:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Wait at least 2 CK_REF (PLL1 input source divided by M) period to make sure next latched value
           will be taken into account. */
        while ((HAL_GetTick() - tickstart) < PLL_FRAC_WAIT_VALUE)
 8004300:	bf00      	nop
 8004302:	f7fc fe89 	bl	8001018 <HAL_GetTick>
 8004306:	4602      	mov	r2, r0
 8004308:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800430a:	4293      	cmp	r3, r2
 800430c:	d0f9      	beq.n	8004302 <HAL_RCC_OscConfig+0xd86>
        {
        }

        /* Configure PLL PLL1FRACN */
        __HAL_RCC_PLL_FRACN_CONFIG(pRCC_OscInitStruct->PLL.PLLFRACN);
 800430e:	687b      	ldr	r3, [r7, #4]
 8004310:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004312:	4a07      	ldr	r2, [pc, #28]	; (8004330 <HAL_RCC_OscConfig+0xdb4>)
 8004314:	00db      	lsls	r3, r3, #3
 8004316:	6393      	str	r3, [r2, #56]	; 0x38

        /* Enable PLL1FRACN to latch the new value. */
        __HAL_RCC_PLL_FRACN_ENABLE();
 8004318:	4b05      	ldr	r3, [pc, #20]	; (8004330 <HAL_RCC_OscConfig+0xdb4>)
 800431a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800431c:	4a04      	ldr	r2, [pc, #16]	; (8004330 <HAL_RCC_OscConfig+0xdb4>)
 800431e:	f043 0310 	orr.w	r3, r3, #16
 8004322:	6293      	str	r3, [r2, #40]	; 0x28
      }
    }
  }
  return HAL_OK;
 8004324:	2300      	movs	r3, #0
}
 8004326:	4618      	mov	r0, r3
 8004328:	3738      	adds	r7, #56	; 0x38
 800432a:	46bd      	mov	sp, r7
 800432c:	bd80      	pop	{r7, pc}
 800432e:	bf00      	nop
 8004330:	46020c00 	.word	0x46020c00

08004334 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(const RCC_ClkInitTypeDef   *const pRCC_ClkInitStruct, uint32_t FLatency)
{
 8004334:	b580      	push	{r7, lr}
 8004336:	b086      	sub	sp, #24
 8004338:	af00      	add	r7, sp, #0
 800433a:	6078      	str	r0, [r7, #4]
 800433c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart;

  /* Check Null pointer */
  if (pRCC_ClkInitStruct == NULL)
 800433e:	687b      	ldr	r3, [r7, #4]
 8004340:	2b00      	cmp	r3, #0
 8004342:	d101      	bne.n	8004348 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8004344:	2301      	movs	r3, #1
 8004346:	e1d9      	b.n	80046fc <HAL_RCC_ClockConfig+0x3c8>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
   must be correctly programmed according to the frequency of the CPU clock
   (HCLK) and the supply voltage of the device */

  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8004348:	4b9b      	ldr	r3, [pc, #620]	; (80045b8 <HAL_RCC_ClockConfig+0x284>)
 800434a:	681b      	ldr	r3, [r3, #0]
 800434c:	f003 030f 	and.w	r3, r3, #15
 8004350:	683a      	ldr	r2, [r7, #0]
 8004352:	429a      	cmp	r2, r3
 8004354:	d910      	bls.n	8004378 <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004356:	4b98      	ldr	r3, [pc, #608]	; (80045b8 <HAL_RCC_ClockConfig+0x284>)
 8004358:	681b      	ldr	r3, [r3, #0]
 800435a:	f023 020f 	bic.w	r2, r3, #15
 800435e:	4996      	ldr	r1, [pc, #600]	; (80045b8 <HAL_RCC_ClockConfig+0x284>)
 8004360:	683b      	ldr	r3, [r7, #0]
 8004362:	4313      	orrs	r3, r2
 8004364:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8004366:	4b94      	ldr	r3, [pc, #592]	; (80045b8 <HAL_RCC_ClockConfig+0x284>)
 8004368:	681b      	ldr	r3, [r3, #0]
 800436a:	f003 030f 	and.w	r3, r3, #15
 800436e:	683a      	ldr	r2, [r7, #0]
 8004370:	429a      	cmp	r2, r3
 8004372:	d001      	beq.n	8004378 <HAL_RCC_ClockConfig+0x44>
    {
      return HAL_ERROR;
 8004374:	2301      	movs	r3, #1
 8004376:	e1c1      	b.n	80046fc <HAL_RCC_ClockConfig+0x3c8>
    }
  }

  /* Increasing the BUS frequency divider */
  /*-------------------------- PCLK3 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK3) == RCC_CLOCKTYPE_PCLK3)
 8004378:	687b      	ldr	r3, [r7, #4]
 800437a:	681b      	ldr	r3, [r3, #0]
 800437c:	f003 0310 	and.w	r3, r3, #16
 8004380:	2b00      	cmp	r3, #0
 8004382:	d010      	beq.n	80043a6 <HAL_RCC_ClockConfig+0x72>
  {
    if ((pRCC_ClkInitStruct->APB3CLKDivider) > (RCC->CFGR3 & RCC_CFGR3_PPRE3))
 8004384:	687b      	ldr	r3, [r7, #4]
 8004386:	695a      	ldr	r2, [r3, #20]
 8004388:	4b8c      	ldr	r3, [pc, #560]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 800438a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800438c:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8004390:	429a      	cmp	r2, r3
 8004392:	d908      	bls.n	80043a6 <HAL_RCC_ClockConfig+0x72>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->CFGR3, RCC_CFGR3_PPRE3, pRCC_ClkInitStruct->APB3CLKDivider);
 8004394:	4b89      	ldr	r3, [pc, #548]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 8004396:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004398:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 800439c:	687b      	ldr	r3, [r7, #4]
 800439e:	695b      	ldr	r3, [r3, #20]
 80043a0:	4986      	ldr	r1, [pc, #536]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 80043a2:	4313      	orrs	r3, r2
 80043a4:	624b      	str	r3, [r1, #36]	; 0x24
    }
  }
  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80043a6:	687b      	ldr	r3, [r7, #4]
 80043a8:	681b      	ldr	r3, [r3, #0]
 80043aa:	f003 0308 	and.w	r3, r3, #8
 80043ae:	2b00      	cmp	r3, #0
 80043b0:	d012      	beq.n	80043d8 <HAL_RCC_ClockConfig+0xa4>
  {
    if ((pRCC_ClkInitStruct->APB2CLKDivider) > ((RCC->CFGR2 & RCC_CFGR2_PPRE2) >> 4))
 80043b2:	687b      	ldr	r3, [r7, #4]
 80043b4:	691a      	ldr	r2, [r3, #16]
 80043b6:	4b81      	ldr	r3, [pc, #516]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 80043b8:	6a1b      	ldr	r3, [r3, #32]
 80043ba:	091b      	lsrs	r3, r3, #4
 80043bc:	f003 0370 	and.w	r3, r3, #112	; 0x70
 80043c0:	429a      	cmp	r2, r3
 80043c2:	d909      	bls.n	80043d8 <HAL_RCC_ClockConfig+0xa4>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, ((pRCC_ClkInitStruct->APB2CLKDivider) << 4));
 80043c4:	4b7d      	ldr	r3, [pc, #500]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 80043c6:	6a1b      	ldr	r3, [r3, #32]
 80043c8:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 80043cc:	687b      	ldr	r3, [r7, #4]
 80043ce:	691b      	ldr	r3, [r3, #16]
 80043d0:	011b      	lsls	r3, r3, #4
 80043d2:	497a      	ldr	r1, [pc, #488]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 80043d4:	4313      	orrs	r3, r2
 80043d6:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80043d8:	687b      	ldr	r3, [r7, #4]
 80043da:	681b      	ldr	r3, [r3, #0]
 80043dc:	f003 0304 	and.w	r3, r3, #4
 80043e0:	2b00      	cmp	r3, #0
 80043e2:	d010      	beq.n	8004406 <HAL_RCC_ClockConfig+0xd2>
  {
    if ((pRCC_ClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
 80043e4:	687b      	ldr	r3, [r7, #4]
 80043e6:	68da      	ldr	r2, [r3, #12]
 80043e8:	4b74      	ldr	r3, [pc, #464]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 80043ea:	6a1b      	ldr	r3, [r3, #32]
 80043ec:	f003 0370 	and.w	r3, r3, #112	; 0x70
 80043f0:	429a      	cmp	r2, r3
 80043f2:	d908      	bls.n	8004406 <HAL_RCC_ClockConfig+0xd2>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, pRCC_ClkInitStruct->APB1CLKDivider);
 80043f4:	4b71      	ldr	r3, [pc, #452]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 80043f6:	6a1b      	ldr	r3, [r3, #32]
 80043f8:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 80043fc:	687b      	ldr	r3, [r7, #4]
 80043fe:	68db      	ldr	r3, [r3, #12]
 8004400:	496e      	ldr	r1, [pc, #440]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 8004402:	4313      	orrs	r3, r2
 8004404:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8004406:	687b      	ldr	r3, [r7, #4]
 8004408:	681b      	ldr	r3, [r3, #0]
 800440a:	f003 0302 	and.w	r3, r3, #2
 800440e:	2b00      	cmp	r3, #0
 8004410:	d010      	beq.n	8004434 <HAL_RCC_ClockConfig+0x100>
  {
    if ((pRCC_ClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
 8004412:	687b      	ldr	r3, [r7, #4]
 8004414:	689a      	ldr	r2, [r3, #8]
 8004416:	4b69      	ldr	r3, [pc, #420]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 8004418:	6a1b      	ldr	r3, [r3, #32]
 800441a:	f003 030f 	and.w	r3, r3, #15
 800441e:	429a      	cmp	r2, r3
 8004420:	d908      	bls.n	8004434 <HAL_RCC_ClockConfig+0x100>
    {
      assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
 8004422:	4b66      	ldr	r3, [pc, #408]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 8004424:	6a1b      	ldr	r3, [r3, #32]
 8004426:	f023 020f 	bic.w	r2, r3, #15
 800442a:	687b      	ldr	r3, [r7, #4]
 800442c:	689b      	ldr	r3, [r3, #8]
 800442e:	4963      	ldr	r1, [pc, #396]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 8004430:	4313      	orrs	r3, r2
 8004432:	620b      	str	r3, [r1, #32]
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8004434:	687b      	ldr	r3, [r7, #4]
 8004436:	681b      	ldr	r3, [r3, #0]
 8004438:	f003 0301 	and.w	r3, r3, #1
 800443c:	2b00      	cmp	r3, #0
 800443e:	f000 80d2 	beq.w	80045e6 <HAL_RCC_ClockConfig+0x2b2>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(pRCC_ClkInitStruct->SYSCLKSource));
    FlagStatus  pwrclkchanged = RESET;
 8004442:	2300      	movs	r3, #0
 8004444:	75fb      	strb	r3, [r7, #23]

    /* PLL is selected as System Clock Source */
    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8004446:	687b      	ldr	r3, [r7, #4]
 8004448:	685b      	ldr	r3, [r3, #4]
 800444a:	2b03      	cmp	r3, #3
 800444c:	d143      	bne.n	80044d6 <HAL_RCC_ClockConfig+0x1a2>
    {
      if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 800444e:	4b5b      	ldr	r3, [pc, #364]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 8004450:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8004454:	f003 0304 	and.w	r3, r3, #4
 8004458:	2b00      	cmp	r3, #0
 800445a:	d110      	bne.n	800447e <HAL_RCC_ClockConfig+0x14a>
      {
        __HAL_RCC_PWR_CLK_ENABLE();
 800445c:	4b57      	ldr	r3, [pc, #348]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 800445e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8004462:	4a56      	ldr	r2, [pc, #344]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 8004464:	f043 0304 	orr.w	r3, r3, #4
 8004468:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 800446c:	4b53      	ldr	r3, [pc, #332]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 800446e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8004472:	f003 0304 	and.w	r3, r3, #4
 8004476:	60bb      	str	r3, [r7, #8]
 8004478:	68bb      	ldr	r3, [r7, #8]
        pwrclkchanged = SET;
 800447a:	2301      	movs	r3, #1
 800447c:	75fb      	strb	r3, [r7, #23]
      }
      tickstart = HAL_GetTick();
 800447e:	f7fc fdcb 	bl	8001018 <HAL_GetTick>
 8004482:	6138      	str	r0, [r7, #16]
      /* Check if EPOD is enabled */
      if (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN) != 0U)
 8004484:	4b4e      	ldr	r3, [pc, #312]	; (80045c0 <HAL_RCC_ClockConfig+0x28c>)
 8004486:	68db      	ldr	r3, [r3, #12]
 8004488:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800448c:	2b00      	cmp	r3, #0
 800448e:	d00f      	beq.n	80044b0 <HAL_RCC_ClockConfig+0x17c>
      {
        /* Wait till BOOST is ready */
        while (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTRDY) == 0U)
 8004490:	e008      	b.n	80044a4 <HAL_RCC_ClockConfig+0x170>
        {
          if ((HAL_GetTick() - tickstart) > EPOD_TIMEOUT_VALUE)
 8004492:	f7fc fdc1 	bl	8001018 <HAL_GetTick>
 8004496:	4602      	mov	r2, r0
 8004498:	693b      	ldr	r3, [r7, #16]
 800449a:	1ad3      	subs	r3, r2, r3
 800449c:	2b02      	cmp	r3, #2
 800449e:	d901      	bls.n	80044a4 <HAL_RCC_ClockConfig+0x170>
          {
            return HAL_TIMEOUT;
 80044a0:	2303      	movs	r3, #3
 80044a2:	e12b      	b.n	80046fc <HAL_RCC_ClockConfig+0x3c8>
        while (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTRDY) == 0U)
 80044a4:	4b46      	ldr	r3, [pc, #280]	; (80045c0 <HAL_RCC_ClockConfig+0x28c>)
 80044a6:	68db      	ldr	r3, [r3, #12]
 80044a8:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80044ac:	2b00      	cmp	r3, #0
 80044ae:	d0f0      	beq.n	8004492 <HAL_RCC_ClockConfig+0x15e>
          }
        }
      }

      /* Restore clock configuration if changed */
      if (pwrclkchanged == SET)
 80044b0:	7dfb      	ldrb	r3, [r7, #23]
 80044b2:	2b01      	cmp	r3, #1
 80044b4:	d107      	bne.n	80044c6 <HAL_RCC_ClockConfig+0x192>
      {
        __HAL_RCC_PWR_CLK_DISABLE();
 80044b6:	4b41      	ldr	r3, [pc, #260]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 80044b8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80044bc:	4a3f      	ldr	r2, [pc, #252]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 80044be:	f023 0304 	bic.w	r3, r3, #4
 80044c2:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
      }

      /* Check the PLL ready flag */
      if (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
 80044c6:	4b3d      	ldr	r3, [pc, #244]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 80044c8:	681b      	ldr	r3, [r3, #0]
 80044ca:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80044ce:	2b00      	cmp	r3, #0
 80044d0:	d121      	bne.n	8004516 <HAL_RCC_ClockConfig+0x1e2>
      {
        return HAL_ERROR;
 80044d2:	2301      	movs	r3, #1
 80044d4:	e112      	b.n	80046fc <HAL_RCC_ClockConfig+0x3c8>
      }
    }
    else
    {
      /* HSE is selected as System Clock Source */
      if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80044d6:	687b      	ldr	r3, [r7, #4]
 80044d8:	685b      	ldr	r3, [r3, #4]
 80044da:	2b02      	cmp	r3, #2
 80044dc:	d107      	bne.n	80044ee <HAL_RCC_ClockConfig+0x1ba>
      {
        /* Check the HSE ready flag */
        if (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 80044de:	4b37      	ldr	r3, [pc, #220]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 80044e0:	681b      	ldr	r3, [r3, #0]
 80044e2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80044e6:	2b00      	cmp	r3, #0
 80044e8:	d115      	bne.n	8004516 <HAL_RCC_ClockConfig+0x1e2>
        {
          return HAL_ERROR;
 80044ea:	2301      	movs	r3, #1
 80044ec:	e106      	b.n	80046fc <HAL_RCC_ClockConfig+0x3c8>
        }
      }
      /* MSI is selected as System Clock Source */
      else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 80044ee:	687b      	ldr	r3, [r7, #4]
 80044f0:	685b      	ldr	r3, [r3, #4]
 80044f2:	2b00      	cmp	r3, #0
 80044f4:	d107      	bne.n	8004506 <HAL_RCC_ClockConfig+0x1d2>
      {
        /* Check the MSI ready flag */
        if (READ_BIT(RCC->CR, RCC_CR_MSISRDY) == 0U)
 80044f6:	4b31      	ldr	r3, [pc, #196]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 80044f8:	681b      	ldr	r3, [r3, #0]
 80044fa:	f003 0304 	and.w	r3, r3, #4
 80044fe:	2b00      	cmp	r3, #0
 8004500:	d109      	bne.n	8004516 <HAL_RCC_ClockConfig+0x1e2>
        {
          return HAL_ERROR;
 8004502:	2301      	movs	r3, #1
 8004504:	e0fa      	b.n	80046fc <HAL_RCC_ClockConfig+0x3c8>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8004506:	4b2d      	ldr	r3, [pc, #180]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 8004508:	681b      	ldr	r3, [r3, #0]
 800450a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800450e:	2b00      	cmp	r3, #0
 8004510:	d101      	bne.n	8004516 <HAL_RCC_ClockConfig+0x1e2>
        {
          return HAL_ERROR;
 8004512:	2301      	movs	r3, #1
 8004514:	e0f2      	b.n	80046fc <HAL_RCC_ClockConfig+0x3c8>
        }
      }
    }

    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SW, pRCC_ClkInitStruct->SYSCLKSource);
 8004516:	4b29      	ldr	r3, [pc, #164]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 8004518:	69db      	ldr	r3, [r3, #28]
 800451a:	f023 0203 	bic.w	r2, r3, #3
 800451e:	687b      	ldr	r3, [r7, #4]
 8004520:	685b      	ldr	r3, [r3, #4]
 8004522:	4926      	ldr	r1, [pc, #152]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 8004524:	4313      	orrs	r3, r2
 8004526:	61cb      	str	r3, [r1, #28]

    tickstart = HAL_GetTick();
 8004528:	f7fc fd76 	bl	8001018 <HAL_GetTick>
 800452c:	6138      	str	r0, [r7, #16]

    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800452e:	687b      	ldr	r3, [r7, #4]
 8004530:	685b      	ldr	r3, [r3, #4]
 8004532:	2b03      	cmp	r3, #3
 8004534:	d112      	bne.n	800455c <HAL_RCC_ClockConfig+0x228>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8004536:	e00a      	b.n	800454e <HAL_RCC_ClockConfig+0x21a>
      {
        if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004538:	f7fc fd6e 	bl	8001018 <HAL_GetTick>
 800453c:	4602      	mov	r2, r0
 800453e:	693b      	ldr	r3, [r7, #16]
 8004540:	1ad3      	subs	r3, r2, r3
 8004542:	f241 3288 	movw	r2, #5000	; 0x1388
 8004546:	4293      	cmp	r3, r2
 8004548:	d901      	bls.n	800454e <HAL_RCC_ClockConfig+0x21a>
        {
          return HAL_TIMEOUT;
 800454a:	2303      	movs	r3, #3
 800454c:	e0d6      	b.n	80046fc <HAL_RCC_ClockConfig+0x3c8>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800454e:	4b1b      	ldr	r3, [pc, #108]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 8004550:	69db      	ldr	r3, [r3, #28]
 8004552:	f003 030c 	and.w	r3, r3, #12
 8004556:	2b0c      	cmp	r3, #12
 8004558:	d1ee      	bne.n	8004538 <HAL_RCC_ClockConfig+0x204>
 800455a:	e044      	b.n	80045e6 <HAL_RCC_ClockConfig+0x2b2>
        }
      }
    }
    else
    {
      if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800455c:	687b      	ldr	r3, [r7, #4]
 800455e:	685b      	ldr	r3, [r3, #4]
 8004560:	2b02      	cmp	r3, #2
 8004562:	d112      	bne.n	800458a <HAL_RCC_ClockConfig+0x256>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8004564:	e00a      	b.n	800457c <HAL_RCC_ClockConfig+0x248>
        {
          if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004566:	f7fc fd57 	bl	8001018 <HAL_GetTick>
 800456a:	4602      	mov	r2, r0
 800456c:	693b      	ldr	r3, [r7, #16]
 800456e:	1ad3      	subs	r3, r2, r3
 8004570:	f241 3288 	movw	r2, #5000	; 0x1388
 8004574:	4293      	cmp	r3, r2
 8004576:	d901      	bls.n	800457c <HAL_RCC_ClockConfig+0x248>
          {
            return HAL_TIMEOUT;
 8004578:	2303      	movs	r3, #3
 800457a:	e0bf      	b.n	80046fc <HAL_RCC_ClockConfig+0x3c8>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800457c:	4b0f      	ldr	r3, [pc, #60]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 800457e:	69db      	ldr	r3, [r3, #28]
 8004580:	f003 030c 	and.w	r3, r3, #12
 8004584:	2b08      	cmp	r3, #8
 8004586:	d1ee      	bne.n	8004566 <HAL_RCC_ClockConfig+0x232>
 8004588:	e02d      	b.n	80045e6 <HAL_RCC_ClockConfig+0x2b2>
          }
        }
      }
      else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 800458a:	687b      	ldr	r3, [r7, #4]
 800458c:	685b      	ldr	r3, [r3, #4]
 800458e:	2b00      	cmp	r3, #0
 8004590:	d123      	bne.n	80045da <HAL_RCC_ClockConfig+0x2a6>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 8004592:	e00a      	b.n	80045aa <HAL_RCC_ClockConfig+0x276>
        {
          if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004594:	f7fc fd40 	bl	8001018 <HAL_GetTick>
 8004598:	4602      	mov	r2, r0
 800459a:	693b      	ldr	r3, [r7, #16]
 800459c:	1ad3      	subs	r3, r2, r3
 800459e:	f241 3288 	movw	r2, #5000	; 0x1388
 80045a2:	4293      	cmp	r3, r2
 80045a4:	d901      	bls.n	80045aa <HAL_RCC_ClockConfig+0x276>
          {
            return HAL_TIMEOUT;
 80045a6:	2303      	movs	r3, #3
 80045a8:	e0a8      	b.n	80046fc <HAL_RCC_ClockConfig+0x3c8>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 80045aa:	4b04      	ldr	r3, [pc, #16]	; (80045bc <HAL_RCC_ClockConfig+0x288>)
 80045ac:	69db      	ldr	r3, [r3, #28]
 80045ae:	f003 030c 	and.w	r3, r3, #12
 80045b2:	2b00      	cmp	r3, #0
 80045b4:	d1ee      	bne.n	8004594 <HAL_RCC_ClockConfig+0x260>
 80045b6:	e016      	b.n	80045e6 <HAL_RCC_ClockConfig+0x2b2>
 80045b8:	40022000 	.word	0x40022000
 80045bc:	46020c00 	.word	0x46020c00
 80045c0:	46020800 	.word	0x46020800
      }
      else
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
        {
          if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80045c4:	f7fc fd28 	bl	8001018 <HAL_GetTick>
 80045c8:	4602      	mov	r2, r0
 80045ca:	693b      	ldr	r3, [r7, #16]
 80045cc:	1ad3      	subs	r3, r2, r3
 80045ce:	f241 3288 	movw	r2, #5000	; 0x1388
 80045d2:	4293      	cmp	r3, r2
 80045d4:	d901      	bls.n	80045da <HAL_RCC_ClockConfig+0x2a6>
          {
            return HAL_TIMEOUT;
 80045d6:	2303      	movs	r3, #3
 80045d8:	e090      	b.n	80046fc <HAL_RCC_ClockConfig+0x3c8>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 80045da:	4b4a      	ldr	r3, [pc, #296]	; (8004704 <HAL_RCC_ClockConfig+0x3d0>)
 80045dc:	69db      	ldr	r3, [r3, #28]
 80045de:	f003 030c 	and.w	r3, r3, #12
 80045e2:	2b04      	cmp	r3, #4
 80045e4:	d1ee      	bne.n	80045c4 <HAL_RCC_ClockConfig+0x290>
    }
  }

  /* Decreasing the BUS frequency divider */
  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80045e6:	687b      	ldr	r3, [r7, #4]
 80045e8:	681b      	ldr	r3, [r3, #0]
 80045ea:	f003 0302 	and.w	r3, r3, #2
 80045ee:	2b00      	cmp	r3, #0
 80045f0:	d010      	beq.n	8004614 <HAL_RCC_ClockConfig+0x2e0>
  {
    if ((pRCC_ClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
 80045f2:	687b      	ldr	r3, [r7, #4]
 80045f4:	689a      	ldr	r2, [r3, #8]
 80045f6:	4b43      	ldr	r3, [pc, #268]	; (8004704 <HAL_RCC_ClockConfig+0x3d0>)
 80045f8:	6a1b      	ldr	r3, [r3, #32]
 80045fa:	f003 030f 	and.w	r3, r3, #15
 80045fe:	429a      	cmp	r2, r3
 8004600:	d208      	bcs.n	8004614 <HAL_RCC_ClockConfig+0x2e0>
    {
      assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
 8004602:	4b40      	ldr	r3, [pc, #256]	; (8004704 <HAL_RCC_ClockConfig+0x3d0>)
 8004604:	6a1b      	ldr	r3, [r3, #32]
 8004606:	f023 020f 	bic.w	r2, r3, #15
 800460a:	687b      	ldr	r3, [r7, #4]
 800460c:	689b      	ldr	r3, [r3, #8]
 800460e:	493d      	ldr	r1, [pc, #244]	; (8004704 <HAL_RCC_ClockConfig+0x3d0>)
 8004610:	4313      	orrs	r3, r2
 8004612:	620b      	str	r3, [r1, #32]
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8004614:	4b3c      	ldr	r3, [pc, #240]	; (8004708 <HAL_RCC_ClockConfig+0x3d4>)
 8004616:	681b      	ldr	r3, [r3, #0]
 8004618:	f003 030f 	and.w	r3, r3, #15
 800461c:	683a      	ldr	r2, [r7, #0]
 800461e:	429a      	cmp	r2, r3
 8004620:	d210      	bcs.n	8004644 <HAL_RCC_ClockConfig+0x310>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004622:	4b39      	ldr	r3, [pc, #228]	; (8004708 <HAL_RCC_ClockConfig+0x3d4>)
 8004624:	681b      	ldr	r3, [r3, #0]
 8004626:	f023 020f 	bic.w	r2, r3, #15
 800462a:	4937      	ldr	r1, [pc, #220]	; (8004708 <HAL_RCC_ClockConfig+0x3d4>)
 800462c:	683b      	ldr	r3, [r7, #0]
 800462e:	4313      	orrs	r3, r2
 8004630:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8004632:	4b35      	ldr	r3, [pc, #212]	; (8004708 <HAL_RCC_ClockConfig+0x3d4>)
 8004634:	681b      	ldr	r3, [r3, #0]
 8004636:	f003 030f 	and.w	r3, r3, #15
 800463a:	683a      	ldr	r2, [r7, #0]
 800463c:	429a      	cmp	r2, r3
 800463e:	d001      	beq.n	8004644 <HAL_RCC_ClockConfig+0x310>
    {
      return HAL_ERROR;
 8004640:	2301      	movs	r3, #1
 8004642:	e05b      	b.n	80046fc <HAL_RCC_ClockConfig+0x3c8>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8004644:	687b      	ldr	r3, [r7, #4]
 8004646:	681b      	ldr	r3, [r3, #0]
 8004648:	f003 0304 	and.w	r3, r3, #4
 800464c:	2b00      	cmp	r3, #0
 800464e:	d010      	beq.n	8004672 <HAL_RCC_ClockConfig+0x33e>
  {
    if ((pRCC_ClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
 8004650:	687b      	ldr	r3, [r7, #4]
 8004652:	68da      	ldr	r2, [r3, #12]
 8004654:	4b2b      	ldr	r3, [pc, #172]	; (8004704 <HAL_RCC_ClockConfig+0x3d0>)
 8004656:	6a1b      	ldr	r3, [r3, #32]
 8004658:	f003 0370 	and.w	r3, r3, #112	; 0x70
 800465c:	429a      	cmp	r2, r3
 800465e:	d208      	bcs.n	8004672 <HAL_RCC_ClockConfig+0x33e>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, pRCC_ClkInitStruct->APB1CLKDivider);
 8004660:	4b28      	ldr	r3, [pc, #160]	; (8004704 <HAL_RCC_ClockConfig+0x3d0>)
 8004662:	6a1b      	ldr	r3, [r3, #32]
 8004664:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8004668:	687b      	ldr	r3, [r7, #4]
 800466a:	68db      	ldr	r3, [r3, #12]
 800466c:	4925      	ldr	r1, [pc, #148]	; (8004704 <HAL_RCC_ClockConfig+0x3d0>)
 800466e:	4313      	orrs	r3, r2
 8004670:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8004672:	687b      	ldr	r3, [r7, #4]
 8004674:	681b      	ldr	r3, [r3, #0]
 8004676:	f003 0308 	and.w	r3, r3, #8
 800467a:	2b00      	cmp	r3, #0
 800467c:	d012      	beq.n	80046a4 <HAL_RCC_ClockConfig+0x370>
  {
    if ((pRCC_ClkInitStruct->APB2CLKDivider) < ((RCC->CFGR2 & RCC_CFGR2_PPRE2) >> 4))
 800467e:	687b      	ldr	r3, [r7, #4]
 8004680:	691a      	ldr	r2, [r3, #16]
 8004682:	4b20      	ldr	r3, [pc, #128]	; (8004704 <HAL_RCC_ClockConfig+0x3d0>)
 8004684:	6a1b      	ldr	r3, [r3, #32]
 8004686:	091b      	lsrs	r3, r3, #4
 8004688:	f003 0370 	and.w	r3, r3, #112	; 0x70
 800468c:	429a      	cmp	r2, r3
 800468e:	d209      	bcs.n	80046a4 <HAL_RCC_ClockConfig+0x370>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, ((pRCC_ClkInitStruct->APB2CLKDivider) << 4));
 8004690:	4b1c      	ldr	r3, [pc, #112]	; (8004704 <HAL_RCC_ClockConfig+0x3d0>)
 8004692:	6a1b      	ldr	r3, [r3, #32]
 8004694:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8004698:	687b      	ldr	r3, [r7, #4]
 800469a:	691b      	ldr	r3, [r3, #16]
 800469c:	011b      	lsls	r3, r3, #4
 800469e:	4919      	ldr	r1, [pc, #100]	; (8004704 <HAL_RCC_ClockConfig+0x3d0>)
 80046a0:	4313      	orrs	r3, r2
 80046a2:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- PCLK3 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK3) == RCC_CLOCKTYPE_PCLK3)
 80046a4:	687b      	ldr	r3, [r7, #4]
 80046a6:	681b      	ldr	r3, [r3, #0]
 80046a8:	f003 0310 	and.w	r3, r3, #16
 80046ac:	2b00      	cmp	r3, #0
 80046ae:	d010      	beq.n	80046d2 <HAL_RCC_ClockConfig+0x39e>
  {
    if ((pRCC_ClkInitStruct->APB3CLKDivider) < (RCC->CFGR3 & RCC_CFGR3_PPRE3))
 80046b0:	687b      	ldr	r3, [r7, #4]
 80046b2:	695a      	ldr	r2, [r3, #20]
 80046b4:	4b13      	ldr	r3, [pc, #76]	; (8004704 <HAL_RCC_ClockConfig+0x3d0>)
 80046b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80046b8:	f003 0370 	and.w	r3, r3, #112	; 0x70
 80046bc:	429a      	cmp	r2, r3
 80046be:	d208      	bcs.n	80046d2 <HAL_RCC_ClockConfig+0x39e>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->CFGR3, RCC_CFGR3_PPRE3, (pRCC_ClkInitStruct->APB3CLKDivider));
 80046c0:	4b10      	ldr	r3, [pc, #64]	; (8004704 <HAL_RCC_ClockConfig+0x3d0>)
 80046c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80046c4:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 80046c8:	687b      	ldr	r3, [r7, #4]
 80046ca:	695b      	ldr	r3, [r3, #20]
 80046cc:	490d      	ldr	r1, [pc, #52]	; (8004704 <HAL_RCC_ClockConfig+0x3d0>)
 80046ce:	4313      	orrs	r3, r2
 80046d0:	624b      	str	r3, [r1, #36]	; 0x24
    }
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 80046d2:	f000 f821 	bl	8004718 <HAL_RCC_GetSysClockFreq>
 80046d6:	4602      	mov	r2, r0
 80046d8:	4b0a      	ldr	r3, [pc, #40]	; (8004704 <HAL_RCC_ClockConfig+0x3d0>)
 80046da:	6a1b      	ldr	r3, [r3, #32]
 80046dc:	f003 030f 	and.w	r3, r3, #15
 80046e0:	490a      	ldr	r1, [pc, #40]	; (800470c <HAL_RCC_ClockConfig+0x3d8>)
 80046e2:	5ccb      	ldrb	r3, [r1, r3]
 80046e4:	fa22 f303 	lsr.w	r3, r2, r3
 80046e8:	4a09      	ldr	r2, [pc, #36]	; (8004710 <HAL_RCC_ClockConfig+0x3dc>)
 80046ea:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);
 80046ec:	4b09      	ldr	r3, [pc, #36]	; (8004714 <HAL_RCC_ClockConfig+0x3e0>)
 80046ee:	681b      	ldr	r3, [r3, #0]
 80046f0:	4618      	mov	r0, r3
 80046f2:	f7fc fc47 	bl	8000f84 <HAL_InitTick>
 80046f6:	4603      	mov	r3, r0
 80046f8:	73fb      	strb	r3, [r7, #15]

  return status;
 80046fa:	7bfb      	ldrb	r3, [r7, #15]
}
 80046fc:	4618      	mov	r0, r3
 80046fe:	3718      	adds	r7, #24
 8004700:	46bd      	mov	sp, r7
 8004702:	bd80      	pop	{r7, pc}
 8004704:	46020c00 	.word	0x46020c00
 8004708:	40022000 	.word	0x40022000
 800470c:	08006e1c 	.word	0x08006e1c
 8004710:	20000008 	.word	0x20000008
 8004714:	2000000c 	.word	0x2000000c

08004718 <HAL_RCC_GetSysClockFreq>:
  * @note   Each time SYSCLK changes, this function must be called to update the
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8004718:	b480      	push	{r7}
 800471a:	b08b      	sub	sp, #44	; 0x2c
 800471c:	af00      	add	r7, sp, #0
  uint32_t msirange = 0U;
 800471e:	2300      	movs	r3, #0
 8004720:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t pllsource;
  uint32_t pllr;
  uint32_t pllm;
  uint32_t pllfracen;
  uint32_t sysclockfreq = 0U;
 8004722:	2300      	movs	r3, #0
 8004724:	623b      	str	r3, [r7, #32]
  uint32_t sysclk_source;
  uint32_t pll_oscsource;
  float_t fracn1;
  float_t pllvco;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8004726:	4b78      	ldr	r3, [pc, #480]	; (8004908 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8004728:	69db      	ldr	r3, [r3, #28]
 800472a:	f003 030c 	and.w	r3, r3, #12
 800472e:	61bb      	str	r3, [r7, #24]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8004730:	4b75      	ldr	r3, [pc, #468]	; (8004908 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8004732:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004734:	f003 0303 	and.w	r3, r3, #3
 8004738:	617b      	str	r3, [r7, #20]

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 800473a:	69bb      	ldr	r3, [r7, #24]
 800473c:	2b00      	cmp	r3, #0
 800473e:	d005      	beq.n	800474c <HAL_RCC_GetSysClockFreq+0x34>
 8004740:	69bb      	ldr	r3, [r7, #24]
 8004742:	2b0c      	cmp	r3, #12
 8004744:	d121      	bne.n	800478a <HAL_RCC_GetSysClockFreq+0x72>
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 8004746:	697b      	ldr	r3, [r7, #20]
 8004748:	2b01      	cmp	r3, #1
 800474a:	d11e      	bne.n	800478a <HAL_RCC_GetSysClockFreq+0x72>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if (READ_BIT(RCC->ICSCR1, RCC_ICSCR1_MSIRGSEL) == 0U)
 800474c:	4b6e      	ldr	r3, [pc, #440]	; (8004908 <HAL_RCC_GetSysClockFreq+0x1f0>)
 800474e:	689b      	ldr	r3, [r3, #8]
 8004750:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8004754:	2b00      	cmp	r3, #0
 8004756:	d107      	bne.n	8004768 <HAL_RCC_GetSysClockFreq+0x50>
    {
      /* MSISRANGE from RCC_CSR applies */
      msirange = (RCC->CSR & RCC_CSR_MSISSRANGE) >> RCC_CSR_MSISSRANGE_Pos;
 8004758:	4b6b      	ldr	r3, [pc, #428]	; (8004908 <HAL_RCC_GetSysClockFreq+0x1f0>)
 800475a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 800475e:	0b1b      	lsrs	r3, r3, #12
 8004760:	f003 030f 	and.w	r3, r3, #15
 8004764:	627b      	str	r3, [r7, #36]	; 0x24
 8004766:	e005      	b.n	8004774 <HAL_RCC_GetSysClockFreq+0x5c>
    }
    else
    {
      /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->ICSCR1 & RCC_ICSCR1_MSISRANGE) >> RCC_ICSCR1_MSISRANGE_Pos;
 8004768:	4b67      	ldr	r3, [pc, #412]	; (8004908 <HAL_RCC_GetSysClockFreq+0x1f0>)
 800476a:	689b      	ldr	r3, [r3, #8]
 800476c:	0f1b      	lsrs	r3, r3, #28
 800476e:	f003 030f 	and.w	r3, r3, #15
 8004772:	627b      	str	r3, [r7, #36]	; 0x24
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8004774:	4a65      	ldr	r2, [pc, #404]	; (800490c <HAL_RCC_GetSysClockFreq+0x1f4>)
 8004776:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004778:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800477c:	627b      	str	r3, [r7, #36]	; 0x24

    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 800477e:	69bb      	ldr	r3, [r7, #24]
 8004780:	2b00      	cmp	r3, #0
 8004782:	d110      	bne.n	80047a6 <HAL_RCC_GetSysClockFreq+0x8e>
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
 8004784:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004786:	623b      	str	r3, [r7, #32]
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8004788:	e00d      	b.n	80047a6 <HAL_RCC_GetSysClockFreq+0x8e>
    }
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 800478a:	4b5f      	ldr	r3, [pc, #380]	; (8004908 <HAL_RCC_GetSysClockFreq+0x1f0>)
 800478c:	69db      	ldr	r3, [r3, #28]
 800478e:	f003 030c 	and.w	r3, r3, #12
 8004792:	2b04      	cmp	r3, #4
 8004794:	d102      	bne.n	800479c <HAL_RCC_GetSysClockFreq+0x84>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 8004796:	4b5e      	ldr	r3, [pc, #376]	; (8004910 <HAL_RCC_GetSysClockFreq+0x1f8>)
 8004798:	623b      	str	r3, [r7, #32]
 800479a:	e004      	b.n	80047a6 <HAL_RCC_GetSysClockFreq+0x8e>
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 800479c:	69bb      	ldr	r3, [r7, #24]
 800479e:	2b08      	cmp	r3, #8
 80047a0:	d101      	bne.n	80047a6 <HAL_RCC_GetSysClockFreq+0x8e>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
 80047a2:	4b5b      	ldr	r3, [pc, #364]	; (8004910 <HAL_RCC_GetSysClockFreq+0x1f8>)
 80047a4:	623b      	str	r3, [r7, #32]
  else
  {
    /* Nothing to do */
  }

  if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80047a6:	69bb      	ldr	r3, [r7, #24]
 80047a8:	2b0c      	cmp	r3, #12
 80047aa:	f040 80a5 	bne.w	80048f8 <HAL_RCC_GetSysClockFreq+0x1e0>
  {
    /* PLL used as system clock  source
       PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
       SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 80047ae:	4b56      	ldr	r3, [pc, #344]	; (8004908 <HAL_RCC_GetSysClockFreq+0x1f0>)
 80047b0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80047b2:	f003 0303 	and.w	r3, r3, #3
 80047b6:	613b      	str	r3, [r7, #16]
    pllm = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 80047b8:	4b53      	ldr	r3, [pc, #332]	; (8004908 <HAL_RCC_GetSysClockFreq+0x1f0>)
 80047ba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80047bc:	0a1b      	lsrs	r3, r3, #8
 80047be:	f003 030f 	and.w	r3, r3, #15
 80047c2:	3301      	adds	r3, #1
 80047c4:	60fb      	str	r3, [r7, #12]
    pllfracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 80047c6:	4b50      	ldr	r3, [pc, #320]	; (8004908 <HAL_RCC_GetSysClockFreq+0x1f0>)
 80047c8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80047ca:	091b      	lsrs	r3, r3, #4
 80047cc:	f003 0301 	and.w	r3, r3, #1
 80047d0:	60bb      	str	r3, [r7, #8]
    fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 80047d2:	4b4d      	ldr	r3, [pc, #308]	; (8004908 <HAL_RCC_GetSysClockFreq+0x1f0>)
 80047d4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80047d6:	08db      	lsrs	r3, r3, #3
 80047d8:	f3c3 030c 	ubfx	r3, r3, #0, #13
 80047dc:	68ba      	ldr	r2, [r7, #8]
 80047de:	fb02 f303 	mul.w	r3, r2, r3
 80047e2:	ee07 3a90 	vmov	s15, r3
 80047e6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80047ea:	edc7 7a01 	vstr	s15, [r7, #4]
                                              RCC_PLL1FRACR_PLL1FRACN_Pos));

    switch (pllsource)
 80047ee:	693b      	ldr	r3, [r7, #16]
 80047f0:	2b02      	cmp	r3, #2
 80047f2:	d003      	beq.n	80047fc <HAL_RCC_GetSysClockFreq+0xe4>
 80047f4:	693b      	ldr	r3, [r7, #16]
 80047f6:	2b03      	cmp	r3, #3
 80047f8:	d022      	beq.n	8004840 <HAL_RCC_GetSysClockFreq+0x128>
 80047fa:	e043      	b.n	8004884 <HAL_RCC_GetSysClockFreq+0x16c>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
        pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 80047fc:	68fb      	ldr	r3, [r7, #12]
 80047fe:	ee07 3a90 	vmov	s15, r3
 8004802:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004806:	eddf 6a43 	vldr	s13, [pc, #268]	; 8004914 <HAL_RCC_GetSysClockFreq+0x1fc>
 800480a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800480e:	4b3e      	ldr	r3, [pc, #248]	; (8004908 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8004810:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004812:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004816:	ee07 3a90 	vmov	s15, r3
 800481a:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 800481e:	ed97 6a01 	vldr	s12, [r7, #4]
 8004822:	eddf 5a3d 	vldr	s11, [pc, #244]	; 8004918 <HAL_RCC_GetSysClockFreq+0x200>
 8004826:	eec6 7a25 	vdiv.f32	s15, s12, s11
        pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800482a:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 800482e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8004832:	ee77 7aa6 	vadd.f32	s15, s15, s13
        pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8004836:	ee67 7a27 	vmul.f32	s15, s14, s15
 800483a:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800483e:	e046      	b.n	80048ce <HAL_RCC_GetSysClockFreq+0x1b6>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8004840:	68fb      	ldr	r3, [r7, #12]
 8004842:	ee07 3a90 	vmov	s15, r3
 8004846:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800484a:	eddf 6a32 	vldr	s13, [pc, #200]	; 8004914 <HAL_RCC_GetSysClockFreq+0x1fc>
 800484e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8004852:	4b2d      	ldr	r3, [pc, #180]	; (8004908 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8004854:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004856:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800485a:	ee07 3a90 	vmov	s15, r3
 800485e:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 8004862:	ed97 6a01 	vldr	s12, [r7, #4]
 8004866:	eddf 5a2c 	vldr	s11, [pc, #176]	; 8004918 <HAL_RCC_GetSysClockFreq+0x200>
 800486a:	eec6 7a25 	vdiv.f32	s15, s12, s11
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800486e:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 8004872:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8004876:	ee77 7aa6 	vadd.f32	s15, s15, s13
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800487a:	ee67 7a27 	vmul.f32	s15, s14, s15
 800487e:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8004882:	e024      	b.n	80048ce <HAL_RCC_GetSysClockFreq+0x1b6>

      case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      default:
        pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8004884:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004886:	ee07 3a90 	vmov	s15, r3
 800488a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800488e:	68fb      	ldr	r3, [r7, #12]
 8004890:	ee07 3a90 	vmov	s15, r3
 8004894:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004898:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800489c:	4b1a      	ldr	r3, [pc, #104]	; (8004908 <HAL_RCC_GetSysClockFreq+0x1f0>)
 800489e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80048a0:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80048a4:	ee07 3a90 	vmov	s15, r3
 80048a8:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 80048ac:	ed97 6a01 	vldr	s12, [r7, #4]
 80048b0:	eddf 5a19 	vldr	s11, [pc, #100]	; 8004918 <HAL_RCC_GetSysClockFreq+0x200>
 80048b4:	eec6 7a25 	vdiv.f32	s15, s12, s11
        pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 80048b8:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 80048bc:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 80048c0:	ee77 7aa6 	vadd.f32	s15, s15, s13
        pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 80048c4:	ee67 7a27 	vmul.f32	s15, s14, s15
 80048c8:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 80048cc:	bf00      	nop
    }

    pllr = (((RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1R) >> RCC_PLL1DIVR_PLL1R_Pos) + 1U);
 80048ce:	4b0e      	ldr	r3, [pc, #56]	; (8004908 <HAL_RCC_GetSysClockFreq+0x1f0>)
 80048d0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80048d2:	0e1b      	lsrs	r3, r3, #24
 80048d4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80048d8:	3301      	adds	r3, #1
 80048da:	603b      	str	r3, [r7, #0]
    sysclockfreq = (uint32_t)(float_t)((float_t)pllvco / (float_t)pllr);
 80048dc:	683b      	ldr	r3, [r7, #0]
 80048de:	ee07 3a90 	vmov	s15, r3
 80048e2:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 80048e6:	edd7 6a07 	vldr	s13, [r7, #28]
 80048ea:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80048ee:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80048f2:	ee17 3a90 	vmov	r3, s15
 80048f6:	623b      	str	r3, [r7, #32]
  }

  return sysclockfreq;
 80048f8:	6a3b      	ldr	r3, [r7, #32]
}
 80048fa:	4618      	mov	r0, r3
 80048fc:	372c      	adds	r7, #44	; 0x2c
 80048fe:	46bd      	mov	sp, r7
 8004900:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004904:	4770      	bx	lr
 8004906:	bf00      	nop
 8004908:	46020c00 	.word	0x46020c00
 800490c:	08006e2c 	.word	0x08006e2c
 8004910:	00f42400 	.word	0x00f42400
 8004914:	4b742400 	.word	0x4b742400
 8004918:	46000000 	.word	0x46000000

0800491c <HAL_RCC_GetHCLKFreq>:
  *
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800491c:	b580      	push	{r7, lr}
 800491e:	af00      	add	r7, sp, #0
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 8004920:	f7ff fefa 	bl	8004718 <HAL_RCC_GetSysClockFreq>
 8004924:	4602      	mov	r2, r0
 8004926:	4b07      	ldr	r3, [pc, #28]	; (8004944 <HAL_RCC_GetHCLKFreq+0x28>)
 8004928:	6a1b      	ldr	r3, [r3, #32]
 800492a:	f003 030f 	and.w	r3, r3, #15
 800492e:	4906      	ldr	r1, [pc, #24]	; (8004948 <HAL_RCC_GetHCLKFreq+0x2c>)
 8004930:	5ccb      	ldrb	r3, [r1, r3]
 8004932:	fa22 f303 	lsr.w	r3, r2, r3
 8004936:	4a05      	ldr	r2, [pc, #20]	; (800494c <HAL_RCC_GetHCLKFreq+0x30>)
 8004938:	6013      	str	r3, [r2, #0]
  return SystemCoreClock;
 800493a:	4b04      	ldr	r3, [pc, #16]	; (800494c <HAL_RCC_GetHCLKFreq+0x30>)
 800493c:	681b      	ldr	r3, [r3, #0]
}
 800493e:	4618      	mov	r0, r3
 8004940:	bd80      	pop	{r7, pc}
 8004942:	bf00      	nop
 8004944:	46020c00 	.word	0x46020c00
 8004948:	08006e1c 	.word	0x08006e1c
 800494c:	20000008 	.word	0x20000008

08004950 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_15
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8004950:	b580      	push	{r7, lr}
 8004952:	b086      	sub	sp, #24
 8004954:	af00      	add	r7, sp, #0
 8004956:	6078      	str	r0, [r7, #4]
  uint32_t vos;
  uint32_t latency;  /* default value 0WS */

  if (__HAL_RCC_PWR_IS_CLK_ENABLED())
 8004958:	4b3e      	ldr	r3, [pc, #248]	; (8004a54 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 800495a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800495e:	f003 0304 	and.w	r3, r3, #4
 8004962:	2b00      	cmp	r3, #0
 8004964:	d003      	beq.n	800496e <RCC_SetFlashLatencyFromMSIRange+0x1e>
  {
    vos = HAL_PWREx_GetVoltageRange();
 8004966:	f7fe fd9b 	bl	80034a0 <HAL_PWREx_GetVoltageRange>
 800496a:	6178      	str	r0, [r7, #20]
 800496c:	e019      	b.n	80049a2 <RCC_SetFlashLatencyFromMSIRange+0x52>
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 800496e:	4b39      	ldr	r3, [pc, #228]	; (8004a54 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8004970:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8004974:	4a37      	ldr	r2, [pc, #220]	; (8004a54 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8004976:	f043 0304 	orr.w	r3, r3, #4
 800497a:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 800497e:	4b35      	ldr	r3, [pc, #212]	; (8004a54 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8004980:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8004984:	f003 0304 	and.w	r3, r3, #4
 8004988:	60fb      	str	r3, [r7, #12]
 800498a:	68fb      	ldr	r3, [r7, #12]
    vos = HAL_PWREx_GetVoltageRange();
 800498c:	f7fe fd88 	bl	80034a0 <HAL_PWREx_GetVoltageRange>
 8004990:	6178      	str	r0, [r7, #20]
    __HAL_RCC_PWR_CLK_DISABLE();
 8004992:	4b30      	ldr	r3, [pc, #192]	; (8004a54 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8004994:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8004998:	4a2e      	ldr	r2, [pc, #184]	; (8004a54 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 800499a:	f023 0304 	bic.w	r3, r3, #4
 800499e:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  }

  if ((vos == PWR_REGULATOR_VOLTAGE_SCALE1) || (vos == PWR_REGULATOR_VOLTAGE_SCALE2))
 80049a2:	697b      	ldr	r3, [r7, #20]
 80049a4:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 80049a8:	d003      	beq.n	80049b2 <RCC_SetFlashLatencyFromMSIRange+0x62>
 80049aa:	697b      	ldr	r3, [r7, #20]
 80049ac:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 80049b0:	d109      	bne.n	80049c6 <RCC_SetFlashLatencyFromMSIRange+0x76>
  {

    if (msirange < RCC_MSIRANGE_1)
 80049b2:	687b      	ldr	r3, [r7, #4]
 80049b4:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 80049b8:	d202      	bcs.n	80049c0 <RCC_SetFlashLatencyFromMSIRange+0x70>
    {
      /* MSI = 48Mhz */
      latency = FLASH_LATENCY_1; /* 1WS */
 80049ba:	2301      	movs	r3, #1
 80049bc:	613b      	str	r3, [r7, #16]
    if (msirange < RCC_MSIRANGE_1)
 80049be:	e033      	b.n	8004a28 <RCC_SetFlashLatencyFromMSIRange+0xd8>
    }
    else
    {
      /*  MSI < 48Mhz */
      latency = FLASH_LATENCY_0; /* 0WS */
 80049c0:	2300      	movs	r3, #0
 80049c2:	613b      	str	r3, [r7, #16]
    if (msirange < RCC_MSIRANGE_1)
 80049c4:	e030      	b.n	8004a28 <RCC_SetFlashLatencyFromMSIRange+0xd8>
    }
  }
  else
  {
    if (msirange < RCC_MSIRANGE_1)
 80049c6:	687b      	ldr	r3, [r7, #4]
 80049c8:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 80049cc:	d208      	bcs.n	80049e0 <RCC_SetFlashLatencyFromMSIRange+0x90>
    {
      /* MSI = 48Mhz */
      if (vos == PWR_REGULATOR_VOLTAGE_SCALE3)
 80049ce:	697b      	ldr	r3, [r7, #20]
 80049d0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80049d4:	d102      	bne.n	80049dc <RCC_SetFlashLatencyFromMSIRange+0x8c>
      {
        latency = FLASH_LATENCY_3; /* 3WS */
 80049d6:	2303      	movs	r3, #3
 80049d8:	613b      	str	r3, [r7, #16]
 80049da:	e025      	b.n	8004a28 <RCC_SetFlashLatencyFromMSIRange+0xd8>
      }
      else
      {
        return HAL_ERROR;
 80049dc:	2301      	movs	r3, #1
 80049de:	e035      	b.n	8004a4c <RCC_SetFlashLatencyFromMSIRange+0xfc>
      }
    }
    else
    {
      if (msirange > RCC_MSIRANGE_2)
 80049e0:	687b      	ldr	r3, [r7, #4]
 80049e2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80049e6:	d90f      	bls.n	8004a08 <RCC_SetFlashLatencyFromMSIRange+0xb8>
      {
        if (vos == PWR_REGULATOR_VOLTAGE_SCALE4)
 80049e8:	697b      	ldr	r3, [r7, #20]
 80049ea:	2b00      	cmp	r3, #0
 80049ec:	d109      	bne.n	8004a02 <RCC_SetFlashLatencyFromMSIRange+0xb2>
        {
          if (msirange > RCC_MSIRANGE_3)
 80049ee:	687b      	ldr	r3, [r7, #4]
 80049f0:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 80049f4:	d902      	bls.n	80049fc <RCC_SetFlashLatencyFromMSIRange+0xac>
          {
            latency = FLASH_LATENCY_0; /* 1WS */
 80049f6:	2300      	movs	r3, #0
 80049f8:	613b      	str	r3, [r7, #16]
 80049fa:	e015      	b.n	8004a28 <RCC_SetFlashLatencyFromMSIRange+0xd8>
          }
          else
          {
            latency = FLASH_LATENCY_1; /* 0WS */
 80049fc:	2301      	movs	r3, #1
 80049fe:	613b      	str	r3, [r7, #16]
 8004a00:	e012      	b.n	8004a28 <RCC_SetFlashLatencyFromMSIRange+0xd8>
          }
        }
        else
        {
          latency = FLASH_LATENCY_0; /* 0WS */
 8004a02:	2300      	movs	r3, #0
 8004a04:	613b      	str	r3, [r7, #16]
 8004a06:	e00f      	b.n	8004a28 <RCC_SetFlashLatencyFromMSIRange+0xd8>
        }
      }
      else
      {
        if (msirange == RCC_MSIRANGE_1)
 8004a08:	687b      	ldr	r3, [r7, #4]
 8004a0a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8004a0e:	d109      	bne.n	8004a24 <RCC_SetFlashLatencyFromMSIRange+0xd4>
        {
          if (vos == PWR_REGULATOR_VOLTAGE_SCALE3)
 8004a10:	697b      	ldr	r3, [r7, #20]
 8004a12:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8004a16:	d102      	bne.n	8004a1e <RCC_SetFlashLatencyFromMSIRange+0xce>
          {
            latency = FLASH_LATENCY_1; /* 1WS */
 8004a18:	2301      	movs	r3, #1
 8004a1a:	613b      	str	r3, [r7, #16]
 8004a1c:	e004      	b.n	8004a28 <RCC_SetFlashLatencyFromMSIRange+0xd8>
          }
          else
          {
            latency = FLASH_LATENCY_2; /* 2WS */
 8004a1e:	2302      	movs	r3, #2
 8004a20:	613b      	str	r3, [r7, #16]
 8004a22:	e001      	b.n	8004a28 <RCC_SetFlashLatencyFromMSIRange+0xd8>
          }
        }
        else
        {
          latency = FLASH_LATENCY_1; /* 1WS */
 8004a24:	2301      	movs	r3, #1
 8004a26:	613b      	str	r3, [r7, #16]
        }
      }
    }
  }

  __HAL_FLASH_SET_LATENCY(latency);
 8004a28:	4b0b      	ldr	r3, [pc, #44]	; (8004a58 <RCC_SetFlashLatencyFromMSIRange+0x108>)
 8004a2a:	681b      	ldr	r3, [r3, #0]
 8004a2c:	f023 020f 	bic.w	r2, r3, #15
 8004a30:	4909      	ldr	r1, [pc, #36]	; (8004a58 <RCC_SetFlashLatencyFromMSIRange+0x108>)
 8004a32:	693b      	ldr	r3, [r7, #16]
 8004a34:	4313      	orrs	r3, r2
 8004a36:	600b      	str	r3, [r1, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
  memory by reading the FLASH_ACR register */
  if ((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
 8004a38:	4b07      	ldr	r3, [pc, #28]	; (8004a58 <RCC_SetFlashLatencyFromMSIRange+0x108>)
 8004a3a:	681b      	ldr	r3, [r3, #0]
 8004a3c:	f003 030f 	and.w	r3, r3, #15
 8004a40:	693a      	ldr	r2, [r7, #16]
 8004a42:	429a      	cmp	r2, r3
 8004a44:	d001      	beq.n	8004a4a <RCC_SetFlashLatencyFromMSIRange+0xfa>
  {
    return HAL_ERROR;
 8004a46:	2301      	movs	r3, #1
 8004a48:	e000      	b.n	8004a4c <RCC_SetFlashLatencyFromMSIRange+0xfc>
  }

  return HAL_OK;
 8004a4a:	2300      	movs	r3, #0
}
 8004a4c:	4618      	mov	r0, r3
 8004a4e:	3718      	adds	r7, #24
 8004a50:	46bd      	mov	sp, r7
 8004a52:	bd80      	pop	{r7, pc}
 8004a54:	46020c00 	.word	0x46020c00
 8004a58:	40022000 	.word	0x40022000

08004a5c <HAL_RCCEx_PeriphCLKConfig>:
  * @retval HAL status
  *
  *         (*) value not defined in all devices.
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *pPeriphClkInit)
{
 8004a5c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8004a60:	b0ba      	sub	sp, #232	; 0xe8
 8004a62:	af00      	add	r7, sp, #0
 8004a64:	f8c7 00d4 	str.w	r0, [r7, #212]	; 0xd4
  uint32_t tmpregister;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 8004a68:	2300      	movs	r3, #0
 8004a6a:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8004a6e:	2300      	movs	r3, #0
 8004a70:	f887 30e2 	strb.w	r3, [r7, #226]	; 0xe2

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(pPeriphClkInit->PeriphClockSelection));

  /*-------------------------- USART1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8004a74:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004a78:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004a7c:	f002 0401 	and.w	r4, r2, #1
 8004a80:	2500      	movs	r5, #0
 8004a82:	ea54 0305 	orrs.w	r3, r4, r5
 8004a86:	d00b      	beq.n	8004aa0 <HAL_RCCEx_PeriphCLKConfig+0x44>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(pPeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(pPeriphClkInit->Usart1ClockSelection);
 8004a88:	4bcb      	ldr	r3, [pc, #812]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004a8a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004a8e:	f023 0103 	bic.w	r1, r3, #3
 8004a92:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004a96:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004a98:	4ac7      	ldr	r2, [pc, #796]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004a9a:	430b      	orrs	r3, r1
 8004a9c:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
  }

#if defined(USART2)
  /*-------------------------- USART2 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8004aa0:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004aa4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004aa8:	f002 0802 	and.w	r8, r2, #2
 8004aac:	f04f 0900 	mov.w	r9, #0
 8004ab0:	ea58 0309 	orrs.w	r3, r8, r9
 8004ab4:	d00b      	beq.n	8004ace <HAL_RCCEx_PeriphCLKConfig+0x72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(pPeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(pPeriphClkInit->Usart2ClockSelection);
 8004ab6:	4bc0      	ldr	r3, [pc, #768]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004ab8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004abc:	f023 010c 	bic.w	r1, r3, #12
 8004ac0:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004ac4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004ac6:	4abc      	ldr	r2, [pc, #752]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004ac8:	430b      	orrs	r3, r1
 8004aca:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
  }
#endif /* USART2 */

  /*-------------------------- USART3 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8004ace:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004ad2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004ad6:	f002 0a04 	and.w	sl, r2, #4
 8004ada:	f04f 0b00 	mov.w	fp, #0
 8004ade:	ea5a 030b 	orrs.w	r3, sl, fp
 8004ae2:	d00b      	beq.n	8004afc <HAL_RCCEx_PeriphCLKConfig+0xa0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(pPeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(pPeriphClkInit->Usart3ClockSelection);
 8004ae4:	4bb4      	ldr	r3, [pc, #720]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004ae6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004aea:	f023 0130 	bic.w	r1, r3, #48	; 0x30
 8004aee:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004af2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8004af4:	4ab0      	ldr	r2, [pc, #704]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004af6:	430b      	orrs	r3, r1
 8004af8:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
  }

  /*-------------------------- UART4 clock source configuration --------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8004afc:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004b00:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004b04:	f002 0308 	and.w	r3, r2, #8
 8004b08:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 8004b0c:	2300      	movs	r3, #0
 8004b0e:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
 8004b12:	e9d7 1232 	ldrd	r1, r2, [r7, #200]	; 0xc8
 8004b16:	460b      	mov	r3, r1
 8004b18:	4313      	orrs	r3, r2
 8004b1a:	d00b      	beq.n	8004b34 <HAL_RCCEx_PeriphCLKConfig+0xd8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(pPeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(pPeriphClkInit->Uart4ClockSelection);
 8004b1c:	4ba6      	ldr	r3, [pc, #664]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004b1e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004b22:	f023 01c0 	bic.w	r1, r3, #192	; 0xc0
 8004b26:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004b2a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004b2c:	4aa2      	ldr	r2, [pc, #648]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004b2e:	430b      	orrs	r3, r1
 8004b30:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
  }

  /*-------------------------- UART5 clock source configuration --------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8004b34:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004b38:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004b3c:	f002 0310 	and.w	r3, r2, #16
 8004b40:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 8004b44:	2300      	movs	r3, #0
 8004b46:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 8004b4a:	e9d7 1230 	ldrd	r1, r2, [r7, #192]	; 0xc0
 8004b4e:	460b      	mov	r3, r1
 8004b50:	4313      	orrs	r3, r2
 8004b52:	d00b      	beq.n	8004b6c <HAL_RCCEx_PeriphCLKConfig+0x110>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(pPeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(pPeriphClkInit->Uart5ClockSelection);
 8004b54:	4b98      	ldr	r3, [pc, #608]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004b56:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004b5a:	f423 7140 	bic.w	r1, r3, #768	; 0x300
 8004b5e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004b62:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004b64:	4a94      	ldr	r2, [pc, #592]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004b66:	430b      	orrs	r3, r1
 8004b68:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
    __HAL_RCC_USART6_CONFIG(pPeriphClkInit->Usart6ClockSelection);
  }
#endif /* USART6 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8004b6c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004b70:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004b74:	f002 0320 	and.w	r3, r2, #32
 8004b78:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 8004b7c:	2300      	movs	r3, #0
 8004b7e:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8004b82:	e9d7 122e 	ldrd	r1, r2, [r7, #184]	; 0xb8
 8004b86:	460b      	mov	r3, r1
 8004b88:	4313      	orrs	r3, r2
 8004b8a:	d00b      	beq.n	8004ba4 <HAL_RCCEx_PeriphCLKConfig+0x148>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(pPeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUART1 clock source */
    __HAL_RCC_LPUART1_CONFIG(pPeriphClkInit->Lpuart1ClockSelection);
 8004b8c:	4b8a      	ldr	r3, [pc, #552]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004b8e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8004b92:	f023 0107 	bic.w	r1, r3, #7
 8004b96:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004b9a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004b9c:	4a86      	ldr	r2, [pc, #536]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004b9e:	430b      	orrs	r3, r1
 8004ba0:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8004ba4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004ba8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004bac:	f002 0340 	and.w	r3, r2, #64	; 0x40
 8004bb0:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 8004bb4:	2300      	movs	r3, #0
 8004bb6:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8004bba:	e9d7 122c 	ldrd	r1, r2, [r7, #176]	; 0xb0
 8004bbe:	460b      	mov	r3, r1
 8004bc0:	4313      	orrs	r3, r2
 8004bc2:	d00b      	beq.n	8004bdc <HAL_RCCEx_PeriphCLKConfig+0x180>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(pPeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(pPeriphClkInit->I2c1ClockSelection);
 8004bc4:	4b7c      	ldr	r3, [pc, #496]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004bc6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004bca:	f423 6140 	bic.w	r1, r3, #3072	; 0xc00
 8004bce:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004bd2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8004bd4:	4a78      	ldr	r2, [pc, #480]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004bd6:	430b      	orrs	r3, r1
 8004bd8:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
  }

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8004bdc:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004be0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004be4:	f002 0380 	and.w	r3, r2, #128	; 0x80
 8004be8:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 8004bec:	2300      	movs	r3, #0
 8004bee:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8004bf2:	e9d7 122a 	ldrd	r1, r2, [r7, #168]	; 0xa8
 8004bf6:	460b      	mov	r3, r1
 8004bf8:	4313      	orrs	r3, r2
 8004bfa:	d00b      	beq.n	8004c14 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(pPeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(pPeriphClkInit->I2c2ClockSelection);
 8004bfc:	4b6e      	ldr	r3, [pc, #440]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004bfe:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004c02:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 8004c06:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004c0a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8004c0c:	4a6a      	ldr	r2, [pc, #424]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004c0e:	430b      	orrs	r3, r1
 8004c10:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
  }

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8004c14:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004c18:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004c1c:	f402 7380 	and.w	r3, r2, #256	; 0x100
 8004c20:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8004c24:	2300      	movs	r3, #0
 8004c26:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 8004c2a:	e9d7 1228 	ldrd	r1, r2, [r7, #160]	; 0xa0
 8004c2e:	460b      	mov	r3, r1
 8004c30:	4313      	orrs	r3, r2
 8004c32:	d00b      	beq.n	8004c4c <HAL_RCCEx_PeriphCLKConfig+0x1f0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(pPeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(pPeriphClkInit->I2c3ClockSelection);
 8004c34:	4b60      	ldr	r3, [pc, #384]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004c36:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8004c3a:	f023 01c0 	bic.w	r1, r3, #192	; 0xc0
 8004c3e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004c42:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004c44:	4a5c      	ldr	r2, [pc, #368]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004c46:	430b      	orrs	r3, r1
 8004c48:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
  }

  /*-------------------------- I2C4 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8004c4c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004c50:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004c54:	f402 0380 	and.w	r3, r2, #4194304	; 0x400000
 8004c58:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 8004c5c:	2300      	movs	r3, #0
 8004c5e:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 8004c62:	e9d7 1226 	ldrd	r1, r2, [r7, #152]	; 0x98
 8004c66:	460b      	mov	r3, r1
 8004c68:	4313      	orrs	r3, r2
 8004c6a:	d00b      	beq.n	8004c84 <HAL_RCCEx_PeriphCLKConfig+0x228>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(pPeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(pPeriphClkInit->I2c4ClockSelection);
 8004c6c:	4b52      	ldr	r3, [pc, #328]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004c6e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004c72:	f423 4140 	bic.w	r1, r3, #49152	; 0xc000
 8004c76:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004c7a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8004c7c:	4a4e      	ldr	r2, [pc, #312]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004c7e:	430b      	orrs	r3, r1
 8004c80:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
    __HAL_RCC_I2C6_CONFIG(pPeriphClkInit->I2c6ClockSelection);
  }
#endif /* I2C6 */

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8004c84:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004c88:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004c8c:	f402 7300 	and.w	r3, r2, #512	; 0x200
 8004c90:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8004c94:	2300      	movs	r3, #0
 8004c96:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 8004c9a:	e9d7 1224 	ldrd	r1, r2, [r7, #144]	; 0x90
 8004c9e:	460b      	mov	r3, r1
 8004ca0:	4313      	orrs	r3, r2
 8004ca2:	d00b      	beq.n	8004cbc <HAL_RCCEx_PeriphCLKConfig+0x260>
  {
    assert_param(IS_RCC_LPTIM1CLK(pPeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(pPeriphClkInit->Lptim1ClockSelection);
 8004ca4:	4b44      	ldr	r3, [pc, #272]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004ca6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8004caa:	f423 6140 	bic.w	r1, r3, #3072	; 0xc00
 8004cae:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004cb2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8004cb4:	4a40      	ldr	r2, [pc, #256]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004cb6:	430b      	orrs	r3, r1
 8004cb8:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8004cbc:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004cc0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004cc4:	f402 6380 	and.w	r3, r2, #1024	; 0x400
 8004cc8:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8004ccc:	2300      	movs	r3, #0
 8004cce:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 8004cd2:	e9d7 1222 	ldrd	r1, r2, [r7, #136]	; 0x88
 8004cd6:	460b      	mov	r3, r1
 8004cd8:	4313      	orrs	r3, r2
 8004cda:	d00b      	beq.n	8004cf4 <HAL_RCCEx_PeriphCLKConfig+0x298>
  {
    assert_param(IS_RCC_LPTIM2CLK(pPeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(pPeriphClkInit->Lptim2ClockSelection);
 8004cdc:	4b36      	ldr	r3, [pc, #216]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004cde:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004ce2:	f423 2140 	bic.w	r1, r3, #786432	; 0xc0000
 8004ce6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004cea:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8004cec:	4a32      	ldr	r2, [pc, #200]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004cee:	430b      	orrs	r3, r1
 8004cf0:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
  }

  /*-------------------------- LPTIM34 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM34) == (RCC_PERIPHCLK_LPTIM34))
 8004cf4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004cf8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004cfc:	f402 6300 	and.w	r3, r2, #2048	; 0x800
 8004d00:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 8004d04:	2300      	movs	r3, #0
 8004d06:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 8004d0a:	e9d7 1220 	ldrd	r1, r2, [r7, #128]	; 0x80
 8004d0e:	460b      	mov	r3, r1
 8004d10:	4313      	orrs	r3, r2
 8004d12:	d00c      	beq.n	8004d2e <HAL_RCCEx_PeriphCLKConfig+0x2d2>
  {
    assert_param(IS_RCC_LPTIM34CLK(pPeriphClkInit->Lptim34ClockSelection));
    __HAL_RCC_LPTIM34_CONFIG(pPeriphClkInit->Lptim34ClockSelection);
 8004d14:	4b28      	ldr	r3, [pc, #160]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004d16:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8004d1a:	f423 7140 	bic.w	r1, r3, #768	; 0x300
 8004d1e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004d22:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8004d26:	4a24      	ldr	r2, [pc, #144]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004d28:	430b      	orrs	r3, r1
 8004d2a:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
  }

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if ((((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8004d2e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004d32:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004d36:	f402 5300 	and.w	r3, r2, #8192	; 0x2000
 8004d3a:	67bb      	str	r3, [r7, #120]	; 0x78
 8004d3c:	2300      	movs	r3, #0
 8004d3e:	67fb      	str	r3, [r7, #124]	; 0x7c
 8004d40:	e9d7 121e 	ldrd	r1, r2, [r7, #120]	; 0x78
 8004d44:	460b      	mov	r3, r1
 8004d46:	4313      	orrs	r3, r2
 8004d48:	d04f      	beq.n	8004dea <HAL_RCCEx_PeriphCLKConfig+0x38e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(pPeriphClkInit->Sai1ClockSelection));

    switch (pPeriphClkInit->Sai1ClockSelection)
 8004d4a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004d4e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004d52:	2b80      	cmp	r3, #128	; 0x80
 8004d54:	d02d      	beq.n	8004db2 <HAL_RCCEx_PeriphCLKConfig+0x356>
 8004d56:	2b80      	cmp	r3, #128	; 0x80
 8004d58:	d827      	bhi.n	8004daa <HAL_RCCEx_PeriphCLKConfig+0x34e>
 8004d5a:	2b60      	cmp	r3, #96	; 0x60
 8004d5c:	d02e      	beq.n	8004dbc <HAL_RCCEx_PeriphCLKConfig+0x360>
 8004d5e:	2b60      	cmp	r3, #96	; 0x60
 8004d60:	d823      	bhi.n	8004daa <HAL_RCCEx_PeriphCLKConfig+0x34e>
 8004d62:	2b40      	cmp	r3, #64	; 0x40
 8004d64:	d006      	beq.n	8004d74 <HAL_RCCEx_PeriphCLKConfig+0x318>
 8004d66:	2b40      	cmp	r3, #64	; 0x40
 8004d68:	d81f      	bhi.n	8004daa <HAL_RCCEx_PeriphCLKConfig+0x34e>
 8004d6a:	2b00      	cmp	r3, #0
 8004d6c:	d009      	beq.n	8004d82 <HAL_RCCEx_PeriphCLKConfig+0x326>
 8004d6e:	2b20      	cmp	r3, #32
 8004d70:	d011      	beq.n	8004d96 <HAL_RCCEx_PeriphCLKConfig+0x33a>
 8004d72:	e01a      	b.n	8004daa <HAL_RCCEx_PeriphCLKConfig+0x34e>
    {
      case RCC_SAI1CLKSOURCE_PLL1:      /* PLL is used as clock source for SAI1*/
        /* Enable SAI Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 8004d74:	4b10      	ldr	r3, [pc, #64]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004d76:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004d78:	4a0f      	ldr	r2, [pc, #60]	; (8004db8 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8004d7a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004d7e:	6293      	str	r3, [r2, #40]	; 0x28
        /* SAI1 clock source config set later after clock selection check */
        break;
 8004d80:	e01d      	b.n	8004dbe <HAL_RCCEx_PeriphCLKConfig+0x362>

      case RCC_SAI1CLKSOURCE_PLL2:  /* PLL2 is used as clock source for SAI1*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8004d82:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004d86:	3308      	adds	r3, #8
 8004d88:	4618      	mov	r0, r3
 8004d8a:	f000 fc27 	bl	80055dc <RCCEx_PLL2_Config>
 8004d8e:	4603      	mov	r3, r0
 8004d90:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        /* SAI1 clock source config set later after clock selection check */
        break;
 8004d94:	e013      	b.n	8004dbe <HAL_RCCEx_PeriphCLKConfig+0x362>

      case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
        /* PLL3 P input clock, parameters M, N & P configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8004d96:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004d9a:	332c      	adds	r3, #44	; 0x2c
 8004d9c:	4618      	mov	r0, r3
 8004d9e:	f000 fcb5 	bl	800570c <RCCEx_PLL3_Config>
 8004da2:	4603      	mov	r3, r0
 8004da4:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        /* SAI1 clock source config set later after clock selection check */
        break;
 8004da8:	e009      	b.n	8004dbe <HAL_RCCEx_PeriphCLKConfig+0x362>
      case RCC_SAI1CLKSOURCE_HSI:      /* HSI is used as source of SAI1 clock*/
        /* SAI1 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8004daa:	2301      	movs	r3, #1
 8004dac:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        break;
 8004db0:	e005      	b.n	8004dbe <HAL_RCCEx_PeriphCLKConfig+0x362>
        break;
 8004db2:	bf00      	nop
 8004db4:	e003      	b.n	8004dbe <HAL_RCCEx_PeriphCLKConfig+0x362>
 8004db6:	bf00      	nop
 8004db8:	46020c00 	.word	0x46020c00
        break;
 8004dbc:	bf00      	nop
    }

    if (ret == HAL_OK)
 8004dbe:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 8004dc2:	2b00      	cmp	r3, #0
 8004dc4:	d10d      	bne.n	8004de2 <HAL_RCCEx_PeriphCLKConfig+0x386>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(pPeriphClkInit->Sai1ClockSelection);
 8004dc6:	4bb6      	ldr	r3, [pc, #728]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8004dc8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8004dcc:	f023 01e0 	bic.w	r1, r3, #224	; 0xe0
 8004dd0:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004dd4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004dd8:	4ab1      	ldr	r2, [pc, #708]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8004dda:	430b      	orrs	r3, r1
 8004ddc:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
 8004de0:	e003      	b.n	8004dea <HAL_RCCEx_PeriphCLKConfig+0x38e>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8004de2:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 8004de6:	f887 30e2 	strb.w	r3, [r7, #226]	; 0xe2
    }
  }

#if defined(SAI2)
  /*-------------------------- SAI2 clock source configuration ---------------------*/
  if ((((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 8004dea:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004dee:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004df2:	f402 4380 	and.w	r3, r2, #16384	; 0x4000
 8004df6:	673b      	str	r3, [r7, #112]	; 0x70
 8004df8:	2300      	movs	r3, #0
 8004dfa:	677b      	str	r3, [r7, #116]	; 0x74
 8004dfc:	e9d7 121c 	ldrd	r1, r2, [r7, #112]	; 0x70
 8004e00:	460b      	mov	r3, r1
 8004e02:	4313      	orrs	r3, r2
 8004e04:	d053      	beq.n	8004eae <HAL_RCCEx_PeriphCLKConfig+0x452>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLK(pPeriphClkInit->Sai2ClockSelection));

    switch (pPeriphClkInit->Sai2ClockSelection)
 8004e06:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004e0a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8004e0e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8004e12:	d033      	beq.n	8004e7c <HAL_RCCEx_PeriphCLKConfig+0x420>
 8004e14:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8004e18:	d82c      	bhi.n	8004e74 <HAL_RCCEx_PeriphCLKConfig+0x418>
 8004e1a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8004e1e:	d02f      	beq.n	8004e80 <HAL_RCCEx_PeriphCLKConfig+0x424>
 8004e20:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8004e24:	d826      	bhi.n	8004e74 <HAL_RCCEx_PeriphCLKConfig+0x418>
 8004e26:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8004e2a:	d008      	beq.n	8004e3e <HAL_RCCEx_PeriphCLKConfig+0x3e2>
 8004e2c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8004e30:	d820      	bhi.n	8004e74 <HAL_RCCEx_PeriphCLKConfig+0x418>
 8004e32:	2b00      	cmp	r3, #0
 8004e34:	d00a      	beq.n	8004e4c <HAL_RCCEx_PeriphCLKConfig+0x3f0>
 8004e36:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8004e3a:	d011      	beq.n	8004e60 <HAL_RCCEx_PeriphCLKConfig+0x404>
 8004e3c:	e01a      	b.n	8004e74 <HAL_RCCEx_PeriphCLKConfig+0x418>
    {
      case RCC_SAI2CLKSOURCE_PLL1:      /* PLL is used as clock source for SAI2*/
        /* Enable SAI Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 8004e3e:	4b98      	ldr	r3, [pc, #608]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8004e40:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004e42:	4a97      	ldr	r2, [pc, #604]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8004e44:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004e48:	6293      	str	r3, [r2, #40]	; 0x28
        /* SAI2 clock source config set later after clock selection check */
        break;
 8004e4a:	e01a      	b.n	8004e82 <HAL_RCCEx_PeriphCLKConfig+0x426>

      case RCC_SAI2CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8004e4c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004e50:	3308      	adds	r3, #8
 8004e52:	4618      	mov	r0, r3
 8004e54:	f000 fbc2 	bl	80055dc <RCCEx_PLL2_Config>
 8004e58:	4603      	mov	r3, r0
 8004e5a:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        /* SAI2 clock source config set later after clock selection check */
        break;
 8004e5e:	e010      	b.n	8004e82 <HAL_RCCEx_PeriphCLKConfig+0x426>

      case RCC_SAI2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
        /* PLL3 P input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8004e60:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004e64:	332c      	adds	r3, #44	; 0x2c
 8004e66:	4618      	mov	r0, r3
 8004e68:	f000 fc50 	bl	800570c <RCCEx_PLL3_Config>
 8004e6c:	4603      	mov	r3, r0
 8004e6e:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        /* SAI2 clock source config set later after clock selection check */
        break;
 8004e72:	e006      	b.n	8004e82 <HAL_RCCEx_PeriphCLKConfig+0x426>
      case RCC_SAI2CLKSOURCE_HSI:      /* HSI is used as source of SAI2 clock*/
        /* SAI2 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8004e74:	2301      	movs	r3, #1
 8004e76:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        break;
 8004e7a:	e002      	b.n	8004e82 <HAL_RCCEx_PeriphCLKConfig+0x426>
        break;
 8004e7c:	bf00      	nop
 8004e7e:	e000      	b.n	8004e82 <HAL_RCCEx_PeriphCLKConfig+0x426>
        break;
 8004e80:	bf00      	nop
    }

    if (ret == HAL_OK)
 8004e82:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 8004e86:	2b00      	cmp	r3, #0
 8004e88:	d10d      	bne.n	8004ea6 <HAL_RCCEx_PeriphCLKConfig+0x44a>
    {
      /* Set the source of SAI2 clock*/
      __HAL_RCC_SAI2_CONFIG(pPeriphClkInit->Sai2ClockSelection);
 8004e8a:	4b85      	ldr	r3, [pc, #532]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8004e8c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8004e90:	f423 61e0 	bic.w	r1, r3, #1792	; 0x700
 8004e94:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004e98:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8004e9c:	4a80      	ldr	r2, [pc, #512]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8004e9e:	430b      	orrs	r3, r1
 8004ea0:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
 8004ea4:	e003      	b.n	8004eae <HAL_RCCEx_PeriphCLKConfig+0x452>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8004ea6:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 8004eaa:	f887 30e2 	strb.w	r3, [r7, #226]	; 0xe2
    }
  }
#endif /* SAI2 */

  /*-------------------------- ADCDAC clock source configuration ----------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADCDAC) == RCC_PERIPHCLK_ADCDAC)
 8004eae:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004eb2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004eb6:	f402 4300 	and.w	r3, r2, #32768	; 0x8000
 8004eba:	66bb      	str	r3, [r7, #104]	; 0x68
 8004ebc:	2300      	movs	r3, #0
 8004ebe:	66fb      	str	r3, [r7, #108]	; 0x6c
 8004ec0:	e9d7 121a 	ldrd	r1, r2, [r7, #104]	; 0x68
 8004ec4:	460b      	mov	r3, r1
 8004ec6:	4313      	orrs	r3, r2
 8004ec8:	d046      	beq.n	8004f58 <HAL_RCCEx_PeriphCLKConfig+0x4fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCDACCLKSOURCE(pPeriphClkInit->AdcDacClockSelection));

    switch (pPeriphClkInit->AdcDacClockSelection)
 8004eca:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004ece:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8004ed2:	f5b3 4fa0 	cmp.w	r3, #20480	; 0x5000
 8004ed6:	d028      	beq.n	8004f2a <HAL_RCCEx_PeriphCLKConfig+0x4ce>
 8004ed8:	f5b3 4fa0 	cmp.w	r3, #20480	; 0x5000
 8004edc:	d821      	bhi.n	8004f22 <HAL_RCCEx_PeriphCLKConfig+0x4c6>
 8004ede:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8004ee2:	d022      	beq.n	8004f2a <HAL_RCCEx_PeriphCLKConfig+0x4ce>
 8004ee4:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8004ee8:	d81b      	bhi.n	8004f22 <HAL_RCCEx_PeriphCLKConfig+0x4c6>
 8004eea:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 8004eee:	d01c      	beq.n	8004f2a <HAL_RCCEx_PeriphCLKConfig+0x4ce>
 8004ef0:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 8004ef4:	d815      	bhi.n	8004f22 <HAL_RCCEx_PeriphCLKConfig+0x4c6>
 8004ef6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8004efa:	d008      	beq.n	8004f0e <HAL_RCCEx_PeriphCLKConfig+0x4b2>
 8004efc:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8004f00:	d80f      	bhi.n	8004f22 <HAL_RCCEx_PeriphCLKConfig+0x4c6>
 8004f02:	2b00      	cmp	r3, #0
 8004f04:	d011      	beq.n	8004f2a <HAL_RCCEx_PeriphCLKConfig+0x4ce>
 8004f06:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8004f0a:	d00e      	beq.n	8004f2a <HAL_RCCEx_PeriphCLKConfig+0x4ce>
 8004f0c:	e009      	b.n	8004f22 <HAL_RCCEx_PeriphCLKConfig+0x4c6>
    {
      case RCC_ADCDACCLKSOURCE_PLL2:
        /* PLL2 input clock, parameters M, N,P, & R configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8004f0e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004f12:	3308      	adds	r3, #8
 8004f14:	4618      	mov	r0, r3
 8004f16:	f000 fb61 	bl	80055dc <RCCEx_PLL2_Config>
 8004f1a:	4603      	mov	r3, r0
 8004f1c:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        break;
 8004f20:	e004      	b.n	8004f2c <HAL_RCCEx_PeriphCLKConfig+0x4d0>
      case RCC_ADCDACCLKSOURCE_HSE:
      case RCC_ADCDACCLKSOURCE_HSI:
      case RCC_ADCDACCLKSOURCE_MSIK:
        break;
      default:
        ret = HAL_ERROR;
 8004f22:	2301      	movs	r3, #1
 8004f24:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        break;
 8004f28:	e000      	b.n	8004f2c <HAL_RCCEx_PeriphCLKConfig+0x4d0>
        break;
 8004f2a:	bf00      	nop
    }

    if (ret == HAL_OK)
 8004f2c:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 8004f30:	2b00      	cmp	r3, #0
 8004f32:	d10d      	bne.n	8004f50 <HAL_RCCEx_PeriphCLKConfig+0x4f4>
    {
      /* Configure the ADC1 interface clock source */
      __HAL_RCC_ADCDAC_CONFIG(pPeriphClkInit->AdcDacClockSelection);
 8004f34:	4b5a      	ldr	r3, [pc, #360]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8004f36:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8004f3a:	f423 41e0 	bic.w	r1, r3, #28672	; 0x7000
 8004f3e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004f42:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8004f46:	4a56      	ldr	r2, [pc, #344]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8004f48:	430b      	orrs	r3, r1
 8004f4a:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 8004f4e:	e003      	b.n	8004f58 <HAL_RCCEx_PeriphCLKConfig+0x4fc>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8004f50:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 8004f54:	f887 30e2 	strb.w	r3, [r7, #226]	; 0xe2
    }
  }

  /*-------------------------- MDF1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
 8004f58:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004f5c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004f60:	f402 3380 	and.w	r3, r2, #65536	; 0x10000
 8004f64:	663b      	str	r3, [r7, #96]	; 0x60
 8004f66:	2300      	movs	r3, #0
 8004f68:	667b      	str	r3, [r7, #100]	; 0x64
 8004f6a:	e9d7 1218 	ldrd	r1, r2, [r7, #96]	; 0x60
 8004f6e:	460b      	mov	r3, r1
 8004f70:	4313      	orrs	r3, r2
 8004f72:	d03f      	beq.n	8004ff4 <HAL_RCCEx_PeriphCLKConfig+0x598>
  {
    /* Check the parameters */
    assert_param(IS_RCC_MDF1CLKSOURCE(pPeriphClkInit->Mdf1ClockSelection));

    switch (pPeriphClkInit->Mdf1ClockSelection)
 8004f74:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004f78:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004f7c:	2b04      	cmp	r3, #4
 8004f7e:	d81e      	bhi.n	8004fbe <HAL_RCCEx_PeriphCLKConfig+0x562>
 8004f80:	a201      	add	r2, pc, #4	; (adr r2, 8004f88 <HAL_RCCEx_PeriphCLKConfig+0x52c>)
 8004f82:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004f86:	bf00      	nop
 8004f88:	08004fc7 	.word	0x08004fc7
 8004f8c:	08004f9d 	.word	0x08004f9d
 8004f90:	08004fab 	.word	0x08004fab
 8004f94:	08004fc7 	.word	0x08004fc7
 8004f98:	08004fc7 	.word	0x08004fc7
    {
      case RCC_MDF1CLKSOURCE_PLL1:
        /* Enable PLL1 Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 8004f9c:	4b40      	ldr	r3, [pc, #256]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8004f9e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004fa0:	4a3f      	ldr	r2, [pc, #252]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8004fa2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004fa6:	6293      	str	r3, [r2, #40]	; 0x28
        break;
 8004fa8:	e00e      	b.n	8004fc8 <HAL_RCCEx_PeriphCLKConfig+0x56c>
      case RCC_MDF1CLKSOURCE_PLL3:
        /* PLL3 Q input clock, parameters M, N & Q configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8004faa:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004fae:	332c      	adds	r3, #44	; 0x2c
 8004fb0:	4618      	mov	r0, r3
 8004fb2:	f000 fbab 	bl	800570c <RCCEx_PLL3_Config>
 8004fb6:	4603      	mov	r3, r0
 8004fb8:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        break;
 8004fbc:	e004      	b.n	8004fc8 <HAL_RCCEx_PeriphCLKConfig+0x56c>
      case RCC_MDF1CLKSOURCE_PIN:
        break;
      case RCC_MDF1CLKSOURCE_MSIK:
        break;
      default:
        ret = HAL_ERROR;
 8004fbe:	2301      	movs	r3, #1
 8004fc0:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        break;
 8004fc4:	e000      	b.n	8004fc8 <HAL_RCCEx_PeriphCLKConfig+0x56c>
        break;
 8004fc6:	bf00      	nop
    }
    if (ret == HAL_OK)
 8004fc8:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 8004fcc:	2b00      	cmp	r3, #0
 8004fce:	d10d      	bne.n	8004fec <HAL_RCCEx_PeriphCLKConfig+0x590>
    {
      /* Configure the MDF1 interface clock source */
      __HAL_RCC_MDF1_CONFIG(pPeriphClkInit->Mdf1ClockSelection);
 8004fd0:	4b33      	ldr	r3, [pc, #204]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8004fd2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8004fd6:	f023 0107 	bic.w	r1, r3, #7
 8004fda:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004fde:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004fe2:	4a2f      	ldr	r2, [pc, #188]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8004fe4:	430b      	orrs	r3, r1
 8004fe6:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
 8004fea:	e003      	b.n	8004ff4 <HAL_RCCEx_PeriphCLKConfig+0x598>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8004fec:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 8004ff0:	f887 30e2 	strb.w	r3, [r7, #226]	; 0xe2
    }
  }

  /*-------------------------- ADF1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
 8004ff4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8004ff8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004ffc:	f402 3300 	and.w	r3, r2, #131072	; 0x20000
 8005000:	65bb      	str	r3, [r7, #88]	; 0x58
 8005002:	2300      	movs	r3, #0
 8005004:	65fb      	str	r3, [r7, #92]	; 0x5c
 8005006:	e9d7 1216 	ldrd	r1, r2, [r7, #88]	; 0x58
 800500a:	460b      	mov	r3, r1
 800500c:	4313      	orrs	r3, r2
 800500e:	d04d      	beq.n	80050ac <HAL_RCCEx_PeriphCLKConfig+0x650>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADF1CLKSOURCE(pPeriphClkInit->Adf1ClockSelection));
    switch (pPeriphClkInit->Adf1ClockSelection)
 8005010:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8005014:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8005018:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800501c:	d028      	beq.n	8005070 <HAL_RCCEx_PeriphCLKConfig+0x614>
 800501e:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8005022:	d821      	bhi.n	8005068 <HAL_RCCEx_PeriphCLKConfig+0x60c>
 8005024:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 8005028:	d024      	beq.n	8005074 <HAL_RCCEx_PeriphCLKConfig+0x618>
 800502a:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 800502e:	d81b      	bhi.n	8005068 <HAL_RCCEx_PeriphCLKConfig+0x60c>
 8005030:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8005034:	d00e      	beq.n	8005054 <HAL_RCCEx_PeriphCLKConfig+0x5f8>
 8005036:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800503a:	d815      	bhi.n	8005068 <HAL_RCCEx_PeriphCLKConfig+0x60c>
 800503c:	2b00      	cmp	r3, #0
 800503e:	d01b      	beq.n	8005078 <HAL_RCCEx_PeriphCLKConfig+0x61c>
 8005040:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8005044:	d110      	bne.n	8005068 <HAL_RCCEx_PeriphCLKConfig+0x60c>
    {
      case RCC_ADF1CLKSOURCE_PLL1:
        /* Enable PLL1 Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 8005046:	4b16      	ldr	r3, [pc, #88]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8005048:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800504a:	4a15      	ldr	r2, [pc, #84]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 800504c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8005050:	6293      	str	r3, [r2, #40]	; 0x28
        break;
 8005052:	e012      	b.n	800507a <HAL_RCCEx_PeriphCLKConfig+0x61e>
      case RCC_ADF1CLKSOURCE_PLL3:
        /* PLL3 Q input clock, parameters M, N & Q configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8005054:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8005058:	332c      	adds	r3, #44	; 0x2c
 800505a:	4618      	mov	r0, r3
 800505c:	f000 fb56 	bl	800570c <RCCEx_PLL3_Config>
 8005060:	4603      	mov	r3, r0
 8005062:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        break;
 8005066:	e008      	b.n	800507a <HAL_RCCEx_PeriphCLKConfig+0x61e>
      case RCC_ADF1CLKSOURCE_PIN:
        break;
      case RCC_ADF1CLKSOURCE_MSIK:
        break;
      default:
        ret = HAL_ERROR;
 8005068:	2301      	movs	r3, #1
 800506a:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        break;
 800506e:	e004      	b.n	800507a <HAL_RCCEx_PeriphCLKConfig+0x61e>
        break;
 8005070:	bf00      	nop
 8005072:	e002      	b.n	800507a <HAL_RCCEx_PeriphCLKConfig+0x61e>
        break;
 8005074:	bf00      	nop
 8005076:	e000      	b.n	800507a <HAL_RCCEx_PeriphCLKConfig+0x61e>
        break;
 8005078:	bf00      	nop
    }
    if (ret == HAL_OK)
 800507a:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 800507e:	2b00      	cmp	r3, #0
 8005080:	d110      	bne.n	80050a4 <HAL_RCCEx_PeriphCLKConfig+0x648>
    {
      /* Configure the ADF1 interface clock source */
      __HAL_RCC_ADF1_CONFIG(pPeriphClkInit->Adf1ClockSelection);
 8005082:	4b07      	ldr	r3, [pc, #28]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8005084:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8005088:	f423 21e0 	bic.w	r1, r3, #458752	; 0x70000
 800508c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8005090:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8005094:	4a02      	ldr	r2, [pc, #8]	; (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8005096:	430b      	orrs	r3, r1
 8005098:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 800509c:	e006      	b.n	80050ac <HAL_RCCEx_PeriphCLKConfig+0x650>
 800509e:	bf00      	nop
 80050a0:	46020c00 	.word	0x46020c00
    }
    else
    {
      /* set overall return value */
      status = ret;
 80050a4:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 80050a8:	f887 30e2 	strb.w	r3, [r7, #226]	; 0xe2
    }
  }

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((pPeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 80050ac:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80050b0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80050b4:	f402 2380 	and.w	r3, r2, #262144	; 0x40000
 80050b8:	653b      	str	r3, [r7, #80]	; 0x50
 80050ba:	2300      	movs	r3, #0
 80050bc:	657b      	str	r3, [r7, #84]	; 0x54
 80050be:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	; 0x50
 80050c2:	460b      	mov	r3, r1
 80050c4:	4313      	orrs	r3, r2
 80050c6:	f000 80b5 	beq.w	8005234 <HAL_RCCEx_PeriphCLKConfig+0x7d8>
  {
    FlagStatus       pwrclkchanged = RESET;
 80050ca:	2300      	movs	r3, #0
 80050cc:	f887 30e1 	strb.w	r3, [r7, #225]	; 0xe1
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(pPeriphClkInit->RTCClockSelection));
    /* Enable Power Clock */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 80050d0:	4b9d      	ldr	r3, [pc, #628]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80050d2:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80050d6:	f003 0304 	and.w	r3, r3, #4
 80050da:	2b00      	cmp	r3, #0
 80050dc:	d113      	bne.n	8005106 <HAL_RCCEx_PeriphCLKConfig+0x6aa>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80050de:	4b9a      	ldr	r3, [pc, #616]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80050e0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80050e4:	4a98      	ldr	r2, [pc, #608]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80050e6:	f043 0304 	orr.w	r3, r3, #4
 80050ea:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 80050ee:	4b96      	ldr	r3, [pc, #600]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80050f0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80050f4:	f003 0304 	and.w	r3, r3, #4
 80050f8:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 80050fc:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
      pwrclkchanged = SET;
 8005100:	2301      	movs	r3, #1
 8005102:	f887 30e1 	strb.w	r3, [r7, #225]	; 0xe1
    }
    /* Enable write access to Backup domain */
    SET_BIT(PWR->DBPR, PWR_DBPR_DBP);
 8005106:	4b91      	ldr	r3, [pc, #580]	; (800534c <HAL_RCCEx_PeriphCLKConfig+0x8f0>)
 8005108:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800510a:	4a90      	ldr	r2, [pc, #576]	; (800534c <HAL_RCCEx_PeriphCLKConfig+0x8f0>)
 800510c:	f043 0301 	orr.w	r3, r3, #1
 8005110:	6293      	str	r3, [r2, #40]	; 0x28

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8005112:	f7fb ff81 	bl	8001018 <HAL_GetTick>
 8005116:	f8c7 00dc 	str.w	r0, [r7, #220]	; 0xdc

    while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 800511a:	e00b      	b.n	8005134 <HAL_RCCEx_PeriphCLKConfig+0x6d8>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800511c:	f7fb ff7c 	bl	8001018 <HAL_GetTick>
 8005120:	4602      	mov	r2, r0
 8005122:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8005126:	1ad3      	subs	r3, r2, r3
 8005128:	2b02      	cmp	r3, #2
 800512a:	d903      	bls.n	8005134 <HAL_RCCEx_PeriphCLKConfig+0x6d8>
      {
        ret = HAL_TIMEOUT;
 800512c:	2303      	movs	r3, #3
 800512e:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        break;
 8005132:	e005      	b.n	8005140 <HAL_RCCEx_PeriphCLKConfig+0x6e4>
    while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8005134:	4b85      	ldr	r3, [pc, #532]	; (800534c <HAL_RCCEx_PeriphCLKConfig+0x8f0>)
 8005136:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005138:	f003 0301 	and.w	r3, r3, #1
 800513c:	2b00      	cmp	r3, #0
 800513e:	d0ed      	beq.n	800511c <HAL_RCCEx_PeriphCLKConfig+0x6c0>
      }
    }

    if (ret == HAL_OK)
 8005140:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 8005144:	2b00      	cmp	r3, #0
 8005146:	d165      	bne.n	8005214 <HAL_RCCEx_PeriphCLKConfig+0x7b8>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8005148:	4b7f      	ldr	r3, [pc, #508]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 800514a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 800514e:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8005152:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4

      if ((tmpregister != RCC_RTCCLKSOURCE_NO_CLK) && (tmpregister != pPeriphClkInit->RTCClockSelection))
 8005156:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800515a:	2b00      	cmp	r3, #0
 800515c:	d023      	beq.n	80051a6 <HAL_RCCEx_PeriphCLKConfig+0x74a>
 800515e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8005162:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 8005166:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800516a:	4293      	cmp	r3, r2
 800516c:	d01b      	beq.n	80051a6 <HAL_RCCEx_PeriphCLKConfig+0x74a>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 800516e:	4b76      	ldr	r3, [pc, #472]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8005170:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8005174:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8005178:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 800517c:	4b72      	ldr	r3, [pc, #456]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 800517e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8005182:	4a71      	ldr	r2, [pc, #452]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8005184:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8005188:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
        __HAL_RCC_BACKUPRESET_RELEASE();
 800518c:	4b6e      	ldr	r3, [pc, #440]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 800518e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8005192:	4a6d      	ldr	r2, [pc, #436]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8005194:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8005198:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 800519c:	4a6a      	ldr	r2, [pc, #424]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 800519e:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 80051a2:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 80051a6:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 80051aa:	f003 0301 	and.w	r3, r3, #1
 80051ae:	2b00      	cmp	r3, #0
 80051b0:	d019      	beq.n	80051e6 <HAL_RCCEx_PeriphCLKConfig+0x78a>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80051b2:	f7fb ff31 	bl	8001018 <HAL_GetTick>
 80051b6:	f8c7 00dc 	str.w	r0, [r7, #220]	; 0xdc

        /* Wait till LSE is ready */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80051ba:	e00d      	b.n	80051d8 <HAL_RCCEx_PeriphCLKConfig+0x77c>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80051bc:	f7fb ff2c 	bl	8001018 <HAL_GetTick>
 80051c0:	4602      	mov	r2, r0
 80051c2:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80051c6:	1ad2      	subs	r2, r2, r3
 80051c8:	f241 3388 	movw	r3, #5000	; 0x1388
 80051cc:	429a      	cmp	r2, r3
 80051ce:	d903      	bls.n	80051d8 <HAL_RCCEx_PeriphCLKConfig+0x77c>
          {
            ret = HAL_TIMEOUT;
 80051d0:	2303      	movs	r3, #3
 80051d2:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
            break;
 80051d6:	e006      	b.n	80051e6 <HAL_RCCEx_PeriphCLKConfig+0x78a>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80051d8:	4b5b      	ldr	r3, [pc, #364]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80051da:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80051de:	f003 0302 	and.w	r3, r3, #2
 80051e2:	2b00      	cmp	r3, #0
 80051e4:	d0ea      	beq.n	80051bc <HAL_RCCEx_PeriphCLKConfig+0x760>
          }
        }
      }

      if (ret == HAL_OK)
 80051e6:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 80051ea:	2b00      	cmp	r3, #0
 80051ec:	d10d      	bne.n	800520a <HAL_RCCEx_PeriphCLKConfig+0x7ae>
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(pPeriphClkInit->RTCClockSelection);
 80051ee:	4b56      	ldr	r3, [pc, #344]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80051f0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80051f4:	f423 7140 	bic.w	r1, r3, #768	; 0x300
 80051f8:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80051fc:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8005200:	4a51      	ldr	r2, [pc, #324]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8005202:	430b      	orrs	r3, r1
 8005204:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
 8005208:	e008      	b.n	800521c <HAL_RCCEx_PeriphCLKConfig+0x7c0>
      }
      else
      {
        /* set overall return value */
        status = ret;
 800520a:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 800520e:	f887 30e2 	strb.w	r3, [r7, #226]	; 0xe2
 8005212:	e003      	b.n	800521c <HAL_RCCEx_PeriphCLKConfig+0x7c0>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 8005214:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 8005218:	f887 30e2 	strb.w	r3, [r7, #226]	; 0xe2
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 800521c:	f897 30e1 	ldrb.w	r3, [r7, #225]	; 0xe1
 8005220:	2b01      	cmp	r3, #1
 8005222:	d107      	bne.n	8005234 <HAL_RCCEx_PeriphCLKConfig+0x7d8>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8005224:	4b48      	ldr	r3, [pc, #288]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8005226:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800522a:	4a47      	ldr	r2, [pc, #284]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 800522c:	f023 0304 	bic.w	r3, r3, #4
 8005230:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    }
  }

  /*-------------------------------------- ICLK Configuration -----------------------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ICLK) == RCC_PERIPHCLK_ICLK)
 8005234:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8005238:	e9d3 2300 	ldrd	r2, r3, [r3]
 800523c:	f402 1380 	and.w	r3, r2, #1048576	; 0x100000
 8005240:	64bb      	str	r3, [r7, #72]	; 0x48
 8005242:	2300      	movs	r3, #0
 8005244:	64fb      	str	r3, [r7, #76]	; 0x4c
 8005246:	e9d7 1212 	ldrd	r1, r2, [r7, #72]	; 0x48
 800524a:	460b      	mov	r3, r1
 800524c:	4313      	orrs	r3, r2
 800524e:	d042      	beq.n	80052d6 <HAL_RCCEx_PeriphCLKConfig+0x87a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ICLKCLKSOURCE(pPeriphClkInit->IclkClockSelection));

    switch (pPeriphClkInit->IclkClockSelection)
 8005250:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8005254:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8005258:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
 800525c:	d022      	beq.n	80052a4 <HAL_RCCEx_PeriphCLKConfig+0x848>
 800525e:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
 8005262:	d81b      	bhi.n	800529c <HAL_RCCEx_PeriphCLKConfig+0x840>
 8005264:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8005268:	d011      	beq.n	800528e <HAL_RCCEx_PeriphCLKConfig+0x832>
 800526a:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800526e:	d815      	bhi.n	800529c <HAL_RCCEx_PeriphCLKConfig+0x840>
 8005270:	2b00      	cmp	r3, #0
 8005272:	d019      	beq.n	80052a8 <HAL_RCCEx_PeriphCLKConfig+0x84c>
 8005274:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8005278:	d110      	bne.n	800529c <HAL_RCCEx_PeriphCLKConfig+0x840>
    {
      case RCC_ICLK_CLKSOURCE_PLL2:
        /* PLL2 input clock, parameters M, N,P,Q & R configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 800527a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800527e:	3308      	adds	r3, #8
 8005280:	4618      	mov	r0, r3
 8005282:	f000 f9ab 	bl	80055dc <RCCEx_PLL2_Config>
 8005286:	4603      	mov	r3, r0
 8005288:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        break;
 800528c:	e00d      	b.n	80052aa <HAL_RCCEx_PeriphCLKConfig+0x84e>
      case RCC_ICLK_CLKSOURCE_PLL1:
        /* Enable ICLK Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800528e:	4b2e      	ldr	r3, [pc, #184]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8005290:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005292:	4a2d      	ldr	r2, [pc, #180]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8005294:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8005298:	6293      	str	r3, [r2, #40]	; 0x28
        break;
 800529a:	e006      	b.n	80052aa <HAL_RCCEx_PeriphCLKConfig+0x84e>
      case RCC_ICLK_CLKSOURCE_HSI48:
        break;
      case RCC_ICLK_CLKSOURCE_MSIK:
        break;
      default:
        ret = HAL_ERROR;
 800529c:	2301      	movs	r3, #1
 800529e:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        break;
 80052a2:	e002      	b.n	80052aa <HAL_RCCEx_PeriphCLKConfig+0x84e>
        break;
 80052a4:	bf00      	nop
 80052a6:	e000      	b.n	80052aa <HAL_RCCEx_PeriphCLKConfig+0x84e>
        break;
 80052a8:	bf00      	nop
    }
    if (ret == HAL_OK)
 80052aa:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 80052ae:	2b00      	cmp	r3, #0
 80052b0:	d10d      	bne.n	80052ce <HAL_RCCEx_PeriphCLKConfig+0x872>
    {
      /* Configure the CLK48 source */
      __HAL_RCC_CLK48_CONFIG(pPeriphClkInit->IclkClockSelection);
 80052b2:	4b25      	ldr	r3, [pc, #148]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80052b4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80052b8:	f023 6140 	bic.w	r1, r3, #201326592	; 0xc000000
 80052bc:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80052c0:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 80052c4:	4a20      	ldr	r2, [pc, #128]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80052c6:	430b      	orrs	r3, r1
 80052c8:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 80052cc:	e003      	b.n	80052d6 <HAL_RCCEx_PeriphCLKConfig+0x87a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80052ce:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 80052d2:	f887 30e2 	strb.w	r3, [r7, #226]	; 0xe2
    }
  }

  /*------------------------------ RNG Configuration -------------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 80052d6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80052da:	e9d3 2300 	ldrd	r2, r3, [r3]
 80052de:	f402 2300 	and.w	r3, r2, #524288	; 0x80000
 80052e2:	643b      	str	r3, [r7, #64]	; 0x40
 80052e4:	2300      	movs	r3, #0
 80052e6:	647b      	str	r3, [r7, #68]	; 0x44
 80052e8:	e9d7 1210 	ldrd	r1, r2, [r7, #64]	; 0x40
 80052ec:	460b      	mov	r3, r1
 80052ee:	4313      	orrs	r3, r2
 80052f0:	d032      	beq.n	8005358 <HAL_RCCEx_PeriphCLKConfig+0x8fc>
  {

    /* Check the parameters */
    assert_param(IS_RCC_RNGCLKSOURCE(pPeriphClkInit->RngClockSelection));

    switch (pPeriphClkInit->RngClockSelection)
 80052f2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80052f6:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 80052fa:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80052fe:	d00b      	beq.n	8005318 <HAL_RCCEx_PeriphCLKConfig+0x8bc>
 8005300:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8005304:	d804      	bhi.n	8005310 <HAL_RCCEx_PeriphCLKConfig+0x8b4>
 8005306:	2b00      	cmp	r3, #0
 8005308:	d008      	beq.n	800531c <HAL_RCCEx_PeriphCLKConfig+0x8c0>
 800530a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800530e:	d007      	beq.n	8005320 <HAL_RCCEx_PeriphCLKConfig+0x8c4>
      case RCC_RNGCLKSOURCE_HSI48:
        /* HSI48 oscillator is used as source of RNG clock */
        /* RNG clock source configuration done later after clock selection check */
        break;
      default:
        ret = HAL_ERROR;
 8005310:	2301      	movs	r3, #1
 8005312:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        break;
 8005316:	e004      	b.n	8005322 <HAL_RCCEx_PeriphCLKConfig+0x8c6>
        break;
 8005318:	bf00      	nop
 800531a:	e002      	b.n	8005322 <HAL_RCCEx_PeriphCLKConfig+0x8c6>
        break;
 800531c:	bf00      	nop
 800531e:	e000      	b.n	8005322 <HAL_RCCEx_PeriphCLKConfig+0x8c6>
        break;
 8005320:	bf00      	nop
    }
    if (ret == HAL_OK)
 8005322:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 8005326:	2b00      	cmp	r3, #0
 8005328:	d112      	bne.n	8005350 <HAL_RCCEx_PeriphCLKConfig+0x8f4>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(pPeriphClkInit->RngClockSelection);
 800532a:	4b07      	ldr	r3, [pc, #28]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 800532c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8005330:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 8005334:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8005338:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800533c:	4a02      	ldr	r2, [pc, #8]	; (8005348 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 800533e:	430b      	orrs	r3, r1
 8005340:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
 8005344:	e008      	b.n	8005358 <HAL_RCCEx_PeriphCLKConfig+0x8fc>
 8005346:	bf00      	nop
 8005348:	46020c00 	.word	0x46020c00
 800534c:	46020800 	.word	0x46020800
    }
    else
    {
      /* set overall return value */
      status = ret;
 8005350:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 8005354:	f887 30e2 	strb.w	r3, [r7, #226]	; 0xe2
    }
  }

#if defined(SAES)
  /*-------------------------- SAES clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAES) == RCC_PERIPHCLK_SAES)
 8005358:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800535c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005360:	f402 5380 	and.w	r3, r2, #4096	; 0x1000
 8005364:	63bb      	str	r3, [r7, #56]	; 0x38
 8005366:	2300      	movs	r3, #0
 8005368:	63fb      	str	r3, [r7, #60]	; 0x3c
 800536a:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	; 0x38
 800536e:	460b      	mov	r3, r1
 8005370:	4313      	orrs	r3, r2
 8005372:	d00c      	beq.n	800538e <HAL_RCCEx_PeriphCLKConfig+0x932>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAESCLKSOURCE(pPeriphClkInit->SaesClockSelection));

    /* Configure the SAES clock source */
    __HAL_RCC_SAES_CONFIG(pPeriphClkInit->SaesClockSelection);
 8005374:	4b98      	ldr	r3, [pc, #608]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8005376:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 800537a:	f423 6100 	bic.w	r1, r3, #2048	; 0x800
 800537e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8005382:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8005386:	4a94      	ldr	r2, [pc, #592]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8005388:	430b      	orrs	r3, r1
 800538a:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
  }
#endif /* SAES */

  /*-------------------------- SDMMC1/2 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == (RCC_PERIPHCLK_SDMMC))
 800538e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8005392:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005396:	f402 1300 	and.w	r3, r2, #2097152	; 0x200000
 800539a:	633b      	str	r3, [r7, #48]	; 0x30
 800539c:	2300      	movs	r3, #0
 800539e:	637b      	str	r3, [r7, #52]	; 0x34
 80053a0:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	; 0x30
 80053a4:	460b      	mov	r3, r1
 80053a6:	4313      	orrs	r3, r2
 80053a8:	d019      	beq.n	80053de <HAL_RCCEx_PeriphCLKConfig+0x982>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMCCLKSOURCE(pPeriphClkInit->SdmmcClockSelection));

    if (pPeriphClkInit->SdmmcClockSelection == RCC_SDMMCCLKSOURCE_PLL1)
 80053aa:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80053ae:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 80053b2:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80053b6:	d105      	bne.n	80053c4 <HAL_RCCEx_PeriphCLKConfig+0x968>
    {
      /* Enable PLL1 P CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 80053b8:	4b87      	ldr	r3, [pc, #540]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80053ba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80053bc:	4a86      	ldr	r2, [pc, #536]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80053be:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80053c2:	6293      	str	r3, [r2, #40]	; 0x28
    }

    /* Configure the SDMMC1/2 clock source */
    __HAL_RCC_SDMMC_CONFIG(pPeriphClkInit->SdmmcClockSelection);
 80053c4:	4b84      	ldr	r3, [pc, #528]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80053c6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 80053ca:	f423 4180 	bic.w	r1, r3, #16384	; 0x4000
 80053ce:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80053d2:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 80053d6:	4a80      	ldr	r2, [pc, #512]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80053d8:	430b      	orrs	r3, r1
 80053da:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
  }

  /*-------------------------- SPI1 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
 80053de:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80053e2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80053e6:	f402 0300 	and.w	r3, r2, #8388608	; 0x800000
 80053ea:	62bb      	str	r3, [r7, #40]	; 0x28
 80053ec:	2300      	movs	r3, #0
 80053ee:	62fb      	str	r3, [r7, #44]	; 0x2c
 80053f0:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	; 0x28
 80053f4:	460b      	mov	r3, r1
 80053f6:	4313      	orrs	r3, r2
 80053f8:	d00c      	beq.n	8005414 <HAL_RCCEx_PeriphCLKConfig+0x9b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(pPeriphClkInit->Spi1ClockSelection));

    /* Configure the SPI1 clock source */
    __HAL_RCC_SPI1_CONFIG(pPeriphClkInit->Spi1ClockSelection);
 80053fa:	4b77      	ldr	r3, [pc, #476]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80053fc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8005400:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8005404:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8005408:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 800540c:	4972      	ldr	r1, [pc, #456]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 800540e:	4313      	orrs	r3, r2
 8005410:	f8c1 30e0 	str.w	r3, [r1, #224]	; 0xe0
  }

  /*-------------------------- SPI2 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
 8005414:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8005418:	e9d3 2300 	ldrd	r2, r3, [r3]
 800541c:	f002 7380 	and.w	r3, r2, #16777216	; 0x1000000
 8005420:	623b      	str	r3, [r7, #32]
 8005422:	2300      	movs	r3, #0
 8005424:	627b      	str	r3, [r7, #36]	; 0x24
 8005426:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
 800542a:	460b      	mov	r3, r1
 800542c:	4313      	orrs	r3, r2
 800542e:	d00c      	beq.n	800544a <HAL_RCCEx_PeriphCLKConfig+0x9ee>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI2CLKSOURCE(pPeriphClkInit->Spi2ClockSelection));

    /* Configure the SPI2 clock source */
    __HAL_RCC_SPI2_CONFIG(pPeriphClkInit->Spi2ClockSelection);
 8005430:	4b69      	ldr	r3, [pc, #420]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8005432:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8005436:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 800543a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800543e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8005442:	4965      	ldr	r1, [pc, #404]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8005444:	4313      	orrs	r3, r2
 8005446:	f8c1 30e0 	str.w	r3, [r1, #224]	; 0xe0
  }

  /*-------------------------- SPI3 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
 800544a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800544e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005452:	f002 7300 	and.w	r3, r2, #33554432	; 0x2000000
 8005456:	61bb      	str	r3, [r7, #24]
 8005458:	2300      	movs	r3, #0
 800545a:	61fb      	str	r3, [r7, #28]
 800545c:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 8005460:	460b      	mov	r3, r1
 8005462:	4313      	orrs	r3, r2
 8005464:	d00c      	beq.n	8005480 <HAL_RCCEx_PeriphCLKConfig+0xa24>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI3CLKSOURCE(pPeriphClkInit->Spi3ClockSelection));

    /* Configure the SPI3 clock source */
    __HAL_RCC_SPI3_CONFIG(pPeriphClkInit->Spi3ClockSelection);
 8005466:	4b5c      	ldr	r3, [pc, #368]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8005468:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 800546c:	f023 0218 	bic.w	r2, r3, #24
 8005470:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8005474:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8005478:	4957      	ldr	r1, [pc, #348]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 800547a:	4313      	orrs	r3, r2
 800547c:	f8c1 30e8 	str.w	r3, [r1, #232]	; 0xe8
  }

  /*-------------------------- OctoSPIx clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
 8005480:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8005484:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005488:	f002 6380 	and.w	r3, r2, #67108864	; 0x4000000
 800548c:	613b      	str	r3, [r7, #16]
 800548e:	2300      	movs	r3, #0
 8005490:	617b      	str	r3, [r7, #20]
 8005492:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 8005496:	460b      	mov	r3, r1
 8005498:	4313      	orrs	r3, r2
 800549a:	d032      	beq.n	8005502 <HAL_RCCEx_PeriphCLKConfig+0xaa6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_OSPICLKSOURCE(pPeriphClkInit->OspiClockSelection));

    if (pPeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL1)
 800549c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80054a0:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 80054a4:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 80054a8:	d105      	bne.n	80054b6 <HAL_RCCEx_PeriphCLKConfig+0xa5a>
    {
      /* Enable PLL1 Q CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80054aa:	4b4b      	ldr	r3, [pc, #300]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80054ac:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80054ae:	4a4a      	ldr	r2, [pc, #296]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80054b0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80054b4:	6293      	str	r3, [r2, #40]	; 0x28
    }
    if (pPeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL2)
 80054b6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80054ba:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 80054be:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 80054c2:	d108      	bne.n	80054d6 <HAL_RCCEx_PeriphCLKConfig+0xa7a>
    {
      /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
      ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 80054c4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80054c8:	3308      	adds	r3, #8
 80054ca:	4618      	mov	r0, r3
 80054cc:	f000 f886 	bl	80055dc <RCCEx_PLL2_Config>
 80054d0:	4603      	mov	r3, r0
 80054d2:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
    }
    if (ret == HAL_OK)
 80054d6:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 80054da:	2b00      	cmp	r3, #0
 80054dc:	d10d      	bne.n	80054fa <HAL_RCCEx_PeriphCLKConfig+0xa9e>
    {
      /* Configure the OctoSPI clock source */
      __HAL_RCC_OSPI_CONFIG(pPeriphClkInit->OspiClockSelection);
 80054de:	4b3e      	ldr	r3, [pc, #248]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80054e0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 80054e4:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 80054e8:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80054ec:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 80054f0:	4939      	ldr	r1, [pc, #228]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80054f2:	4313      	orrs	r3, r2
 80054f4:	f8c1 30e4 	str.w	r3, [r1, #228]	; 0xe4
 80054f8:	e003      	b.n	8005502 <HAL_RCCEx_PeriphCLKConfig+0xaa6>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80054fa:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 80054fe:	f887 30e2 	strb.w	r3, [r7, #226]	; 0xe2
    }
  }
#endif /* defined(HSPI1) */

  /*-------------------------- FDCAN1 kernel clock source configuration -------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN1) == (RCC_PERIPHCLK_FDCAN1))
 8005502:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8005506:	e9d3 2300 	ldrd	r2, r3, [r3]
 800550a:	f002 6300 	and.w	r3, r2, #134217728	; 0x8000000
 800550e:	60bb      	str	r3, [r7, #8]
 8005510:	2300      	movs	r3, #0
 8005512:	60fb      	str	r3, [r7, #12]
 8005514:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 8005518:	460b      	mov	r3, r1
 800551a:	4313      	orrs	r3, r2
 800551c:	d03a      	beq.n	8005594 <HAL_RCCEx_PeriphCLKConfig+0xb38>
  {
    assert_param(IS_RCC_FDCAN1CLK(pPeriphClkInit->Fdcan1ClockSelection));

    switch (pPeriphClkInit->Fdcan1ClockSelection)
 800551e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8005522:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8005526:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 800552a:	d00e      	beq.n	800554a <HAL_RCCEx_PeriphCLKConfig+0xaee>
 800552c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8005530:	d815      	bhi.n	800555e <HAL_RCCEx_PeriphCLKConfig+0xb02>
 8005532:	2b00      	cmp	r3, #0
 8005534:	d017      	beq.n	8005566 <HAL_RCCEx_PeriphCLKConfig+0xb0a>
 8005536:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 800553a:	d110      	bne.n	800555e <HAL_RCCEx_PeriphCLKConfig+0xb02>
      case RCC_FDCAN1CLKSOURCE_HSE:      /* HSE is used as source of FDCAN1 kernel clock*/
        /* FDCAN1 kernel clock source config set later after clock selection check */
        break;
      case RCC_FDCAN1CLKSOURCE_PLL1:      /* PLL1 is used as clock source for FDCAN1 kernel clock*/
        /* Enable 48M2 Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800553c:	4b26      	ldr	r3, [pc, #152]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 800553e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005540:	4a25      	ldr	r2, [pc, #148]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8005542:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8005546:	6293      	str	r3, [r2, #40]	; 0x28
        /* FDCAN1 kernel clock source config set later after clock selection check */
        break;
 8005548:	e00e      	b.n	8005568 <HAL_RCCEx_PeriphCLKConfig+0xb0c>
      case RCC_FDCAN1CLKSOURCE_PLL2:  /* PLL2 is used as clock source for FDCAN1 kernel clock*/
        /* PLL2 input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 800554a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800554e:	3308      	adds	r3, #8
 8005550:	4618      	mov	r0, r3
 8005552:	f000 f843 	bl	80055dc <RCCEx_PLL2_Config>
 8005556:	4603      	mov	r3, r0
 8005558:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        /* FDCAN1 kernel clock source config set later after clock selection check */
        break;
 800555c:	e004      	b.n	8005568 <HAL_RCCEx_PeriphCLKConfig+0xb0c>
      default:
        ret = HAL_ERROR;
 800555e:	2301      	movs	r3, #1
 8005560:	f887 30e3 	strb.w	r3, [r7, #227]	; 0xe3
        break;
 8005564:	e000      	b.n	8005568 <HAL_RCCEx_PeriphCLKConfig+0xb0c>
        break;
 8005566:	bf00      	nop
    }
    if (ret == HAL_OK)
 8005568:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 800556c:	2b00      	cmp	r3, #0
 800556e:	d10d      	bne.n	800558c <HAL_RCCEx_PeriphCLKConfig+0xb30>
    {
      /* Set the source of FDCAN1 kernel clock*/
      __HAL_RCC_FDCAN1_CONFIG(pPeriphClkInit->Fdcan1ClockSelection);
 8005570:	4b19      	ldr	r3, [pc, #100]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8005572:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8005576:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
 800557a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800557e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8005582:	4915      	ldr	r1, [pc, #84]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8005584:	4313      	orrs	r3, r2
 8005586:	f8c1 30e0 	str.w	r3, [r1, #224]	; 0xe0
 800558a:	e003      	b.n	8005594 <HAL_RCCEx_PeriphCLKConfig+0xb38>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800558c:	f897 30e3 	ldrb.w	r3, [r7, #227]	; 0xe3
 8005590:	f887 30e2 	strb.w	r3, [r7, #226]	; 0xe2
    }
  }

  /*-------------------------- DAC1 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DAC1) == RCC_PERIPHCLK_DAC1)
 8005594:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8005598:	e9d3 2300 	ldrd	r2, r3, [r3]
 800559c:	f002 5380 	and.w	r3, r2, #268435456	; 0x10000000
 80055a0:	603b      	str	r3, [r7, #0]
 80055a2:	2300      	movs	r3, #0
 80055a4:	607b      	str	r3, [r7, #4]
 80055a6:	e9d7 1200 	ldrd	r1, r2, [r7]
 80055aa:	460b      	mov	r3, r1
 80055ac:	4313      	orrs	r3, r2
 80055ae:	d00c      	beq.n	80055ca <HAL_RCCEx_PeriphCLKConfig+0xb6e>

    /* Check the parameters */
    assert_param(IS_RCC_DAC1CLKSOURCE(pPeriphClkInit->Dac1ClockSelection));

    /* Configure the DAC1 clock source */
    __HAL_RCC_DAC1_CONFIG(pPeriphClkInit->Dac1ClockSelection);
 80055b0:	4b09      	ldr	r3, [pc, #36]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80055b2:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 80055b6:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 80055ba:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80055be:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 80055c2:	4905      	ldr	r1, [pc, #20]	; (80055d8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80055c4:	4313      	orrs	r3, r2
 80055c6:	f8c1 30e8 	str.w	r3, [r1, #232]	; 0xe8
    }
  }

#endif /* defined(USB_OTG_HS) */

  return status;
 80055ca:	f897 30e2 	ldrb.w	r3, [r7, #226]	; 0xe2
}
 80055ce:	4618      	mov	r0, r3
 80055d0:	37e8      	adds	r7, #232	; 0xe8
 80055d2:	46bd      	mov	sp, r7
 80055d4:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 80055d8:	46020c00 	.word	0x46020c00

080055dc <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(const RCC_PLL2InitTypeDef *pll2)
{
 80055dc:	b580      	push	{r7, lr}
 80055de:	b084      	sub	sp, #16
 80055e0:	af00      	add	r7, sp, #0
 80055e2:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_PLLP_VALUE(pll2->PLL2P));
  assert_param(IS_RCC_PLLQ_VALUE(pll2->PLL2Q));
  assert_param(IS_RCC_PLLR_VALUE(pll2->PLL2R));

  /* Disable  PLL2 */
  __HAL_RCC_PLL2_DISABLE();
 80055e4:	4b47      	ldr	r3, [pc, #284]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 80055e6:	681b      	ldr	r3, [r3, #0]
 80055e8:	4a46      	ldr	r2, [pc, #280]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 80055ea:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 80055ee:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 80055f0:	f7fb fd12 	bl	8001018 <HAL_GetTick>
 80055f4:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 80055f6:	e008      	b.n	800560a <RCCEx_PLL2_Config+0x2e>
  {
    if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 80055f8:	f7fb fd0e 	bl	8001018 <HAL_GetTick>
 80055fc:	4602      	mov	r2, r0
 80055fe:	68fb      	ldr	r3, [r7, #12]
 8005600:	1ad3      	subs	r3, r2, r3
 8005602:	2b02      	cmp	r3, #2
 8005604:	d901      	bls.n	800560a <RCCEx_PLL2_Config+0x2e>
    {
      return HAL_TIMEOUT;
 8005606:	2303      	movs	r3, #3
 8005608:	e077      	b.n	80056fa <RCCEx_PLL2_Config+0x11e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 800560a:	4b3e      	ldr	r3, [pc, #248]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 800560c:	681b      	ldr	r3, [r3, #0]
 800560e:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8005612:	2b00      	cmp	r3, #0
 8005614:	d1f0      	bne.n	80055f8 <RCCEx_PLL2_Config+0x1c>
    }
  }

  /* Configure PLL2 multiplication and division factors */
  __HAL_RCC_PLL2_CONFIG(pll2->PLL2Source,
 8005616:	4b3b      	ldr	r3, [pc, #236]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 8005618:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800561a:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 800561e:	f023 0303 	bic.w	r3, r3, #3
 8005622:	687a      	ldr	r2, [r7, #4]
 8005624:	6811      	ldr	r1, [r2, #0]
 8005626:	687a      	ldr	r2, [r7, #4]
 8005628:	6852      	ldr	r2, [r2, #4]
 800562a:	3a01      	subs	r2, #1
 800562c:	0212      	lsls	r2, r2, #8
 800562e:	430a      	orrs	r2, r1
 8005630:	4934      	ldr	r1, [pc, #208]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 8005632:	4313      	orrs	r3, r2
 8005634:	62cb      	str	r3, [r1, #44]	; 0x2c
 8005636:	4b33      	ldr	r3, [pc, #204]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 8005638:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800563a:	4b33      	ldr	r3, [pc, #204]	; (8005708 <RCCEx_PLL2_Config+0x12c>)
 800563c:	4013      	ands	r3, r2
 800563e:	687a      	ldr	r2, [r7, #4]
 8005640:	6892      	ldr	r2, [r2, #8]
 8005642:	3a01      	subs	r2, #1
 8005644:	f3c2 0108 	ubfx	r1, r2, #0, #9
 8005648:	687a      	ldr	r2, [r7, #4]
 800564a:	68d2      	ldr	r2, [r2, #12]
 800564c:	3a01      	subs	r2, #1
 800564e:	0252      	lsls	r2, r2, #9
 8005650:	b292      	uxth	r2, r2
 8005652:	4311      	orrs	r1, r2
 8005654:	687a      	ldr	r2, [r7, #4]
 8005656:	6912      	ldr	r2, [r2, #16]
 8005658:	3a01      	subs	r2, #1
 800565a:	0412      	lsls	r2, r2, #16
 800565c:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
 8005660:	4311      	orrs	r1, r2
 8005662:	687a      	ldr	r2, [r7, #4]
 8005664:	6952      	ldr	r2, [r2, #20]
 8005666:	3a01      	subs	r2, #1
 8005668:	0612      	lsls	r2, r2, #24
 800566a:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
 800566e:	430a      	orrs	r2, r1
 8005670:	4924      	ldr	r1, [pc, #144]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 8005672:	4313      	orrs	r3, r2
 8005674:	63cb      	str	r3, [r1, #60]	; 0x3c
                        pll2->PLL2P,
                        pll2->PLL2Q,
                        pll2->PLL2R);

  /* Select PLL2 input reference frequency range: VCI */
  __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE);
 8005676:	4b23      	ldr	r3, [pc, #140]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 8005678:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800567a:	f023 020c 	bic.w	r2, r3, #12
 800567e:	687b      	ldr	r3, [r7, #4]
 8005680:	699b      	ldr	r3, [r3, #24]
 8005682:	4920      	ldr	r1, [pc, #128]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 8005684:	4313      	orrs	r3, r2
 8005686:	62cb      	str	r3, [r1, #44]	; 0x2c

  /* Configure the PLL2 Clock output(s) */
  __HAL_RCC_PLL2CLKOUT_ENABLE(pll2->PLL2ClockOut);
 8005688:	4b1e      	ldr	r3, [pc, #120]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 800568a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800568c:	687b      	ldr	r3, [r7, #4]
 800568e:	6a1b      	ldr	r3, [r3, #32]
 8005690:	491c      	ldr	r1, [pc, #112]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 8005692:	4313      	orrs	r3, r2
 8005694:	62cb      	str	r3, [r1, #44]	; 0x2c

  /* Disable PLL2FRACN  */
  __HAL_RCC_PLL2FRACN_DISABLE();
 8005696:	4b1b      	ldr	r3, [pc, #108]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 8005698:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800569a:	4a1a      	ldr	r2, [pc, #104]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 800569c:	f023 0310 	bic.w	r3, r3, #16
 80056a0:	62d3      	str	r3, [r2, #44]	; 0x2c

  /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
  __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 80056a2:	4b18      	ldr	r3, [pc, #96]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 80056a4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80056a6:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 80056aa:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80056ae:	687a      	ldr	r2, [r7, #4]
 80056b0:	69d2      	ldr	r2, [r2, #28]
 80056b2:	00d2      	lsls	r2, r2, #3
 80056b4:	4913      	ldr	r1, [pc, #76]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 80056b6:	4313      	orrs	r3, r2
 80056b8:	640b      	str	r3, [r1, #64]	; 0x40

  /* Enable PLL2FRACN  */
  __HAL_RCC_PLL2FRACN_ENABLE();
 80056ba:	4b12      	ldr	r3, [pc, #72]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 80056bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80056be:	4a11      	ldr	r2, [pc, #68]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 80056c0:	f043 0310 	orr.w	r3, r3, #16
 80056c4:	62d3      	str	r3, [r2, #44]	; 0x2c

  /* Enable  PLL2 */
  __HAL_RCC_PLL2_ENABLE();
 80056c6:	4b0f      	ldr	r3, [pc, #60]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 80056c8:	681b      	ldr	r3, [r3, #0]
 80056ca:	4a0e      	ldr	r2, [pc, #56]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 80056cc:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 80056d0:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 80056d2:	f7fb fca1 	bl	8001018 <HAL_GetTick>
 80056d6:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL2 is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 80056d8:	e008      	b.n	80056ec <RCCEx_PLL2_Config+0x110>
  {
    if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 80056da:	f7fb fc9d 	bl	8001018 <HAL_GetTick>
 80056de:	4602      	mov	r2, r0
 80056e0:	68fb      	ldr	r3, [r7, #12]
 80056e2:	1ad3      	subs	r3, r2, r3
 80056e4:	2b02      	cmp	r3, #2
 80056e6:	d901      	bls.n	80056ec <RCCEx_PLL2_Config+0x110>
    {
      return HAL_TIMEOUT;
 80056e8:	2303      	movs	r3, #3
 80056ea:	e006      	b.n	80056fa <RCCEx_PLL2_Config+0x11e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 80056ec:	4b05      	ldr	r3, [pc, #20]	; (8005704 <RCCEx_PLL2_Config+0x128>)
 80056ee:	681b      	ldr	r3, [r3, #0]
 80056f0:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80056f4:	2b00      	cmp	r3, #0
 80056f6:	d0f0      	beq.n	80056da <RCCEx_PLL2_Config+0xfe>
    }
  }
  return HAL_OK;
 80056f8:	2300      	movs	r3, #0

}
 80056fa:	4618      	mov	r0, r3
 80056fc:	3710      	adds	r7, #16
 80056fe:	46bd      	mov	sp, r7
 8005700:	bd80      	pop	{r7, pc}
 8005702:	bf00      	nop
 8005704:	46020c00 	.word	0x46020c00
 8005708:	80800000 	.word	0x80800000

0800570c <RCCEx_PLL3_Config>:
  *         contains the configuration parameters as well as VCI clock ranges.
  * @note   PLL3 is temporary disabled to apply new parameters
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(const RCC_PLL3InitTypeDef *pll3)
{
 800570c:	b580      	push	{r7, lr}
 800570e:	b084      	sub	sp, #16
 8005710:	af00      	add	r7, sp, #0
 8005712:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_PLLP_VALUE(pll3->PLL3P));
  assert_param(IS_RCC_PLLQ_VALUE(pll3->PLL3Q));
  assert_param(IS_RCC_PLLR_VALUE(pll3->PLL3R));

  /* Disable  PLL3 */
  __HAL_RCC_PLL3_DISABLE();
 8005714:	4b47      	ldr	r3, [pc, #284]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 8005716:	681b      	ldr	r3, [r3, #0]
 8005718:	4a46      	ldr	r2, [pc, #280]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 800571a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800571e:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8005720:	f7fb fc7a 	bl	8001018 <HAL_GetTick>
 8005724:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 8005726:	e008      	b.n	800573a <RCCEx_PLL3_Config+0x2e>
  {
    if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 8005728:	f7fb fc76 	bl	8001018 <HAL_GetTick>
 800572c:	4602      	mov	r2, r0
 800572e:	68fb      	ldr	r3, [r7, #12]
 8005730:	1ad3      	subs	r3, r2, r3
 8005732:	2b02      	cmp	r3, #2
 8005734:	d901      	bls.n	800573a <RCCEx_PLL3_Config+0x2e>
    {
      return HAL_TIMEOUT;
 8005736:	2303      	movs	r3, #3
 8005738:	e077      	b.n	800582a <RCCEx_PLL3_Config+0x11e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 800573a:	4b3e      	ldr	r3, [pc, #248]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 800573c:	681b      	ldr	r3, [r3, #0]
 800573e:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8005742:	2b00      	cmp	r3, #0
 8005744:	d1f0      	bne.n	8005728 <RCCEx_PLL3_Config+0x1c>
    }
  }

  /* Configure PLL3 multiplication and division factors */
  __HAL_RCC_PLL3_CONFIG(pll3->PLL3Source,
 8005746:	4b3b      	ldr	r3, [pc, #236]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 8005748:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800574a:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 800574e:	f023 0303 	bic.w	r3, r3, #3
 8005752:	687a      	ldr	r2, [r7, #4]
 8005754:	6811      	ldr	r1, [r2, #0]
 8005756:	687a      	ldr	r2, [r7, #4]
 8005758:	6852      	ldr	r2, [r2, #4]
 800575a:	3a01      	subs	r2, #1
 800575c:	0212      	lsls	r2, r2, #8
 800575e:	430a      	orrs	r2, r1
 8005760:	4934      	ldr	r1, [pc, #208]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 8005762:	4313      	orrs	r3, r2
 8005764:	630b      	str	r3, [r1, #48]	; 0x30
 8005766:	4b33      	ldr	r3, [pc, #204]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 8005768:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800576a:	4b33      	ldr	r3, [pc, #204]	; (8005838 <RCCEx_PLL3_Config+0x12c>)
 800576c:	4013      	ands	r3, r2
 800576e:	687a      	ldr	r2, [r7, #4]
 8005770:	6892      	ldr	r2, [r2, #8]
 8005772:	3a01      	subs	r2, #1
 8005774:	f3c2 0108 	ubfx	r1, r2, #0, #9
 8005778:	687a      	ldr	r2, [r7, #4]
 800577a:	68d2      	ldr	r2, [r2, #12]
 800577c:	3a01      	subs	r2, #1
 800577e:	0252      	lsls	r2, r2, #9
 8005780:	b292      	uxth	r2, r2
 8005782:	4311      	orrs	r1, r2
 8005784:	687a      	ldr	r2, [r7, #4]
 8005786:	6912      	ldr	r2, [r2, #16]
 8005788:	3a01      	subs	r2, #1
 800578a:	0412      	lsls	r2, r2, #16
 800578c:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
 8005790:	4311      	orrs	r1, r2
 8005792:	687a      	ldr	r2, [r7, #4]
 8005794:	6952      	ldr	r2, [r2, #20]
 8005796:	3a01      	subs	r2, #1
 8005798:	0612      	lsls	r2, r2, #24
 800579a:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
 800579e:	430a      	orrs	r2, r1
 80057a0:	4924      	ldr	r1, [pc, #144]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 80057a2:	4313      	orrs	r3, r2
 80057a4:	644b      	str	r3, [r1, #68]	; 0x44
                        pll3->PLL3P,
                        pll3->PLL3Q,
                        pll3->PLL3R);

  /* Select PLL3 input reference frequency range: VCI */
  __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE);
 80057a6:	4b23      	ldr	r3, [pc, #140]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 80057a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80057aa:	f023 020c 	bic.w	r2, r3, #12
 80057ae:	687b      	ldr	r3, [r7, #4]
 80057b0:	699b      	ldr	r3, [r3, #24]
 80057b2:	4920      	ldr	r1, [pc, #128]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 80057b4:	4313      	orrs	r3, r2
 80057b6:	630b      	str	r3, [r1, #48]	; 0x30

  /* Configure the PLL3 Clock output(s) */
  __HAL_RCC_PLL3CLKOUT_ENABLE(pll3->PLL3ClockOut);
 80057b8:	4b1e      	ldr	r3, [pc, #120]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 80057ba:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80057bc:	687b      	ldr	r3, [r7, #4]
 80057be:	6a1b      	ldr	r3, [r3, #32]
 80057c0:	491c      	ldr	r1, [pc, #112]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 80057c2:	4313      	orrs	r3, r2
 80057c4:	630b      	str	r3, [r1, #48]	; 0x30

  /* Disable PLL3FRACN  */
  __HAL_RCC_PLL3FRACN_DISABLE();
 80057c6:	4b1b      	ldr	r3, [pc, #108]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 80057c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80057ca:	4a1a      	ldr	r2, [pc, #104]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 80057cc:	f023 0310 	bic.w	r3, r3, #16
 80057d0:	6313      	str	r3, [r2, #48]	; 0x30

  /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
  __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 80057d2:	4b18      	ldr	r3, [pc, #96]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 80057d4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80057d6:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 80057da:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80057de:	687a      	ldr	r2, [r7, #4]
 80057e0:	69d2      	ldr	r2, [r2, #28]
 80057e2:	00d2      	lsls	r2, r2, #3
 80057e4:	4913      	ldr	r1, [pc, #76]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 80057e6:	4313      	orrs	r3, r2
 80057e8:	648b      	str	r3, [r1, #72]	; 0x48

  /* Enable PLL3FRACN  */
  __HAL_RCC_PLL3FRACN_ENABLE();
 80057ea:	4b12      	ldr	r3, [pc, #72]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 80057ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80057ee:	4a11      	ldr	r2, [pc, #68]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 80057f0:	f043 0310 	orr.w	r3, r3, #16
 80057f4:	6313      	str	r3, [r2, #48]	; 0x30

  /* Enable  PLL3 */
  __HAL_RCC_PLL3_ENABLE();
 80057f6:	4b0f      	ldr	r3, [pc, #60]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 80057f8:	681b      	ldr	r3, [r3, #0]
 80057fa:	4a0e      	ldr	r2, [pc, #56]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 80057fc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8005800:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8005802:	f7fb fc09 	bl	8001018 <HAL_GetTick>
 8005806:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL3 is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 8005808:	e008      	b.n	800581c <RCCEx_PLL3_Config+0x110>
  {
    if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 800580a:	f7fb fc05 	bl	8001018 <HAL_GetTick>
 800580e:	4602      	mov	r2, r0
 8005810:	68fb      	ldr	r3, [r7, #12]
 8005812:	1ad3      	subs	r3, r2, r3
 8005814:	2b02      	cmp	r3, #2
 8005816:	d901      	bls.n	800581c <RCCEx_PLL3_Config+0x110>
    {
      return HAL_TIMEOUT;
 8005818:	2303      	movs	r3, #3
 800581a:	e006      	b.n	800582a <RCCEx_PLL3_Config+0x11e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 800581c:	4b05      	ldr	r3, [pc, #20]	; (8005834 <RCCEx_PLL3_Config+0x128>)
 800581e:	681b      	ldr	r3, [r3, #0]
 8005820:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8005824:	2b00      	cmp	r3, #0
 8005826:	d0f0      	beq.n	800580a <RCCEx_PLL3_Config+0xfe>
    }
  }
  return HAL_OK;
 8005828:	2300      	movs	r3, #0
}
 800582a:	4618      	mov	r0, r3
 800582c:	3710      	adds	r7, #16
 800582e:	46bd      	mov	sp, r7
 8005830:	bd80      	pop	{r7, pc}
 8005832:	bf00      	nop
 8005834:	46020c00 	.word	0x46020c00
 8005838:	80800000 	.word	0x80800000

0800583c <LL_DLYB_SetDelay>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: the Delay value is set.
  *          - ERROR: the Delay value is not set.
  */
void LL_DLYB_SetDelay(DLYB_TypeDef *DLYBx, LL_DLYB_CfgTypeDef  *pdlyb_cfg)
{
 800583c:	b480      	push	{r7}
 800583e:	b083      	sub	sp, #12
 8005840:	af00      	add	r7, sp, #0
 8005842:	6078      	str	r0, [r7, #4]
 8005844:	6039      	str	r1, [r7, #0]
  /* Check the DelayBlock instance */
  assert_param(IS_DLYB_ALL_INSTANCE(DLYBx));

  /* Enable the length sampling */
  SET_BIT(DLYBx->CR, DLYB_CR_SEN);
 8005846:	687b      	ldr	r3, [r7, #4]
 8005848:	681b      	ldr	r3, [r3, #0]
 800584a:	f043 0202 	orr.w	r2, r3, #2
 800584e:	687b      	ldr	r3, [r7, #4]
 8005850:	601a      	str	r2, [r3, #0]

  /* Update the UNIT and SEL field */
  DLYBx->CFGR = (pdlyb_cfg->PhaseSel) | ((pdlyb_cfg->Units) << DLYB_CFGR_UNIT_Pos);
 8005852:	683b      	ldr	r3, [r7, #0]
 8005854:	685a      	ldr	r2, [r3, #4]
 8005856:	683b      	ldr	r3, [r7, #0]
 8005858:	681b      	ldr	r3, [r3, #0]
 800585a:	021b      	lsls	r3, r3, #8
 800585c:	431a      	orrs	r2, r3
 800585e:	687b      	ldr	r3, [r7, #4]
 8005860:	605a      	str	r2, [r3, #4]

  /* Disable the length sampling */
  CLEAR_BIT(DLYBx->CR, DLYB_CR_SEN);
 8005862:	687b      	ldr	r3, [r7, #4]
 8005864:	681b      	ldr	r3, [r3, #0]
 8005866:	f023 0202 	bic.w	r2, r3, #2
 800586a:	687b      	ldr	r3, [r7, #4]
 800586c:	601a      	str	r2, [r3, #0]
}
 800586e:	bf00      	nop
 8005870:	370c      	adds	r7, #12
 8005872:	46bd      	mov	sp, r7
 8005874:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005878:	4770      	bx	lr
	...

0800587c <std>:
 800587c:	2300      	movs	r3, #0
 800587e:	b510      	push	{r4, lr}
 8005880:	4604      	mov	r4, r0
 8005882:	6083      	str	r3, [r0, #8]
 8005884:	8181      	strh	r1, [r0, #12]
 8005886:	4619      	mov	r1, r3
 8005888:	6643      	str	r3, [r0, #100]	; 0x64
 800588a:	81c2      	strh	r2, [r0, #14]
 800588c:	2208      	movs	r2, #8
 800588e:	6183      	str	r3, [r0, #24]
 8005890:	e9c0 3300 	strd	r3, r3, [r0]
 8005894:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8005898:	305c      	adds	r0, #92	; 0x5c
 800589a:	f000 f91f 	bl	8005adc <memset>
 800589e:	4b0d      	ldr	r3, [pc, #52]	; (80058d4 <std+0x58>)
 80058a0:	6224      	str	r4, [r4, #32]
 80058a2:	6263      	str	r3, [r4, #36]	; 0x24
 80058a4:	4b0c      	ldr	r3, [pc, #48]	; (80058d8 <std+0x5c>)
 80058a6:	62a3      	str	r3, [r4, #40]	; 0x28
 80058a8:	4b0c      	ldr	r3, [pc, #48]	; (80058dc <std+0x60>)
 80058aa:	62e3      	str	r3, [r4, #44]	; 0x2c
 80058ac:	4b0c      	ldr	r3, [pc, #48]	; (80058e0 <std+0x64>)
 80058ae:	6323      	str	r3, [r4, #48]	; 0x30
 80058b0:	4b0c      	ldr	r3, [pc, #48]	; (80058e4 <std+0x68>)
 80058b2:	429c      	cmp	r4, r3
 80058b4:	d006      	beq.n	80058c4 <std+0x48>
 80058b6:	f103 0268 	add.w	r2, r3, #104	; 0x68
 80058ba:	4294      	cmp	r4, r2
 80058bc:	d002      	beq.n	80058c4 <std+0x48>
 80058be:	33d0      	adds	r3, #208	; 0xd0
 80058c0:	429c      	cmp	r4, r3
 80058c2:	d105      	bne.n	80058d0 <std+0x54>
 80058c4:	f104 0058 	add.w	r0, r4, #88	; 0x58
 80058c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80058cc:	f000 b938 	b.w	8005b40 <__retarget_lock_init_recursive>
 80058d0:	bd10      	pop	{r4, pc}
 80058d2:	bf00      	nop
 80058d4:	080063a1 	.word	0x080063a1
 80058d8:	080063c3 	.word	0x080063c3
 80058dc:	080063fb 	.word	0x080063fb
 80058e0:	0800641f 	.word	0x0800641f
 80058e4:	20001118 	.word	0x20001118

080058e8 <stdio_exit_handler>:
 80058e8:	4a02      	ldr	r2, [pc, #8]	; (80058f4 <stdio_exit_handler+0xc>)
 80058ea:	4903      	ldr	r1, [pc, #12]	; (80058f8 <stdio_exit_handler+0x10>)
 80058ec:	4803      	ldr	r0, [pc, #12]	; (80058fc <stdio_exit_handler+0x14>)
 80058ee:	f000 b869 	b.w	80059c4 <_fwalk_sglue>
 80058f2:	bf00      	nop
 80058f4:	20000014 	.word	0x20000014
 80058f8:	08006339 	.word	0x08006339
 80058fc:	20000020 	.word	0x20000020

08005900 <cleanup_stdio>:
 8005900:	6841      	ldr	r1, [r0, #4]
 8005902:	4b0c      	ldr	r3, [pc, #48]	; (8005934 <cleanup_stdio+0x34>)
 8005904:	4299      	cmp	r1, r3
 8005906:	b510      	push	{r4, lr}
 8005908:	4604      	mov	r4, r0
 800590a:	d001      	beq.n	8005910 <cleanup_stdio+0x10>
 800590c:	f000 fd14 	bl	8006338 <_fflush_r>
 8005910:	68a1      	ldr	r1, [r4, #8]
 8005912:	4b09      	ldr	r3, [pc, #36]	; (8005938 <cleanup_stdio+0x38>)
 8005914:	4299      	cmp	r1, r3
 8005916:	d002      	beq.n	800591e <cleanup_stdio+0x1e>
 8005918:	4620      	mov	r0, r4
 800591a:	f000 fd0d 	bl	8006338 <_fflush_r>
 800591e:	68e1      	ldr	r1, [r4, #12]
 8005920:	4b06      	ldr	r3, [pc, #24]	; (800593c <cleanup_stdio+0x3c>)
 8005922:	4299      	cmp	r1, r3
 8005924:	d004      	beq.n	8005930 <cleanup_stdio+0x30>
 8005926:	4620      	mov	r0, r4
 8005928:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800592c:	f000 bd04 	b.w	8006338 <_fflush_r>
 8005930:	bd10      	pop	{r4, pc}
 8005932:	bf00      	nop
 8005934:	20001118 	.word	0x20001118
 8005938:	20001180 	.word	0x20001180
 800593c:	200011e8 	.word	0x200011e8

08005940 <global_stdio_init.part.0>:
 8005940:	b510      	push	{r4, lr}
 8005942:	4b0b      	ldr	r3, [pc, #44]	; (8005970 <global_stdio_init.part.0+0x30>)
 8005944:	2104      	movs	r1, #4
 8005946:	4c0b      	ldr	r4, [pc, #44]	; (8005974 <global_stdio_init.part.0+0x34>)
 8005948:	4a0b      	ldr	r2, [pc, #44]	; (8005978 <global_stdio_init.part.0+0x38>)
 800594a:	4620      	mov	r0, r4
 800594c:	601a      	str	r2, [r3, #0]
 800594e:	2200      	movs	r2, #0
 8005950:	f7ff ff94 	bl	800587c <std>
 8005954:	f104 0068 	add.w	r0, r4, #104	; 0x68
 8005958:	2201      	movs	r2, #1
 800595a:	2109      	movs	r1, #9
 800595c:	f7ff ff8e 	bl	800587c <std>
 8005960:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 8005964:	2202      	movs	r2, #2
 8005966:	2112      	movs	r1, #18
 8005968:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800596c:	f7ff bf86 	b.w	800587c <std>
 8005970:	20001250 	.word	0x20001250
 8005974:	20001118 	.word	0x20001118
 8005978:	080058e9 	.word	0x080058e9

0800597c <__sfp_lock_acquire>:
 800597c:	4801      	ldr	r0, [pc, #4]	; (8005984 <__sfp_lock_acquire+0x8>)
 800597e:	f000 b8e0 	b.w	8005b42 <__retarget_lock_acquire_recursive>
 8005982:	bf00      	nop
 8005984:	20001255 	.word	0x20001255

08005988 <__sfp_lock_release>:
 8005988:	4801      	ldr	r0, [pc, #4]	; (8005990 <__sfp_lock_release+0x8>)
 800598a:	f000 b8db 	b.w	8005b44 <__retarget_lock_release_recursive>
 800598e:	bf00      	nop
 8005990:	20001255 	.word	0x20001255

08005994 <__sinit>:
 8005994:	b510      	push	{r4, lr}
 8005996:	4604      	mov	r4, r0
 8005998:	f7ff fff0 	bl	800597c <__sfp_lock_acquire>
 800599c:	6a23      	ldr	r3, [r4, #32]
 800599e:	b11b      	cbz	r3, 80059a8 <__sinit+0x14>
 80059a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80059a4:	f7ff bff0 	b.w	8005988 <__sfp_lock_release>
 80059a8:	4b04      	ldr	r3, [pc, #16]	; (80059bc <__sinit+0x28>)
 80059aa:	6223      	str	r3, [r4, #32]
 80059ac:	4b04      	ldr	r3, [pc, #16]	; (80059c0 <__sinit+0x2c>)
 80059ae:	681b      	ldr	r3, [r3, #0]
 80059b0:	2b00      	cmp	r3, #0
 80059b2:	d1f5      	bne.n	80059a0 <__sinit+0xc>
 80059b4:	f7ff ffc4 	bl	8005940 <global_stdio_init.part.0>
 80059b8:	e7f2      	b.n	80059a0 <__sinit+0xc>
 80059ba:	bf00      	nop
 80059bc:	08005901 	.word	0x08005901
 80059c0:	20001250 	.word	0x20001250

080059c4 <_fwalk_sglue>:
 80059c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80059c8:	4607      	mov	r7, r0
 80059ca:	4688      	mov	r8, r1
 80059cc:	4614      	mov	r4, r2
 80059ce:	2600      	movs	r6, #0
 80059d0:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 80059d4:	f1b9 0901 	subs.w	r9, r9, #1
 80059d8:	d505      	bpl.n	80059e6 <_fwalk_sglue+0x22>
 80059da:	6824      	ldr	r4, [r4, #0]
 80059dc:	2c00      	cmp	r4, #0
 80059de:	d1f7      	bne.n	80059d0 <_fwalk_sglue+0xc>
 80059e0:	4630      	mov	r0, r6
 80059e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80059e6:	89ab      	ldrh	r3, [r5, #12]
 80059e8:	2b01      	cmp	r3, #1
 80059ea:	d907      	bls.n	80059fc <_fwalk_sglue+0x38>
 80059ec:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 80059f0:	3301      	adds	r3, #1
 80059f2:	d003      	beq.n	80059fc <_fwalk_sglue+0x38>
 80059f4:	4629      	mov	r1, r5
 80059f6:	4638      	mov	r0, r7
 80059f8:	47c0      	blx	r8
 80059fa:	4306      	orrs	r6, r0
 80059fc:	3568      	adds	r5, #104	; 0x68
 80059fe:	e7e9      	b.n	80059d4 <_fwalk_sglue+0x10>

08005a00 <iprintf>:
 8005a00:	b40f      	push	{r0, r1, r2, r3}
 8005a02:	b507      	push	{r0, r1, r2, lr}
 8005a04:	4906      	ldr	r1, [pc, #24]	; (8005a20 <iprintf+0x20>)
 8005a06:	ab04      	add	r3, sp, #16
 8005a08:	6808      	ldr	r0, [r1, #0]
 8005a0a:	f853 2b04 	ldr.w	r2, [r3], #4
 8005a0e:	6881      	ldr	r1, [r0, #8]
 8005a10:	9301      	str	r3, [sp, #4]
 8005a12:	f000 f8c1 	bl	8005b98 <_vfiprintf_r>
 8005a16:	b003      	add	sp, #12
 8005a18:	f85d eb04 	ldr.w	lr, [sp], #4
 8005a1c:	b004      	add	sp, #16
 8005a1e:	4770      	bx	lr
 8005a20:	2000006c 	.word	0x2000006c

08005a24 <_puts_r>:
 8005a24:	6a03      	ldr	r3, [r0, #32]
 8005a26:	b570      	push	{r4, r5, r6, lr}
 8005a28:	4605      	mov	r5, r0
 8005a2a:	460e      	mov	r6, r1
 8005a2c:	6884      	ldr	r4, [r0, #8]
 8005a2e:	b90b      	cbnz	r3, 8005a34 <_puts_r+0x10>
 8005a30:	f7ff ffb0 	bl	8005994 <__sinit>
 8005a34:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8005a36:	07db      	lsls	r3, r3, #31
 8005a38:	d405      	bmi.n	8005a46 <_puts_r+0x22>
 8005a3a:	89a3      	ldrh	r3, [r4, #12]
 8005a3c:	0598      	lsls	r0, r3, #22
 8005a3e:	d402      	bmi.n	8005a46 <_puts_r+0x22>
 8005a40:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8005a42:	f000 f87e 	bl	8005b42 <__retarget_lock_acquire_recursive>
 8005a46:	89a3      	ldrh	r3, [r4, #12]
 8005a48:	0719      	lsls	r1, r3, #28
 8005a4a:	d513      	bpl.n	8005a74 <_puts_r+0x50>
 8005a4c:	6923      	ldr	r3, [r4, #16]
 8005a4e:	b18b      	cbz	r3, 8005a74 <_puts_r+0x50>
 8005a50:	3e01      	subs	r6, #1
 8005a52:	68a3      	ldr	r3, [r4, #8]
 8005a54:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8005a58:	3b01      	subs	r3, #1
 8005a5a:	60a3      	str	r3, [r4, #8]
 8005a5c:	b9e9      	cbnz	r1, 8005a9a <_puts_r+0x76>
 8005a5e:	2b00      	cmp	r3, #0
 8005a60:	da2e      	bge.n	8005ac0 <_puts_r+0x9c>
 8005a62:	4622      	mov	r2, r4
 8005a64:	210a      	movs	r1, #10
 8005a66:	4628      	mov	r0, r5
 8005a68:	f000 fcdd 	bl	8006426 <__swbuf_r>
 8005a6c:	3001      	adds	r0, #1
 8005a6e:	d007      	beq.n	8005a80 <_puts_r+0x5c>
 8005a70:	250a      	movs	r5, #10
 8005a72:	e007      	b.n	8005a84 <_puts_r+0x60>
 8005a74:	4621      	mov	r1, r4
 8005a76:	4628      	mov	r0, r5
 8005a78:	f000 fd12 	bl	80064a0 <__swsetup_r>
 8005a7c:	2800      	cmp	r0, #0
 8005a7e:	d0e7      	beq.n	8005a50 <_puts_r+0x2c>
 8005a80:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 8005a84:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8005a86:	07da      	lsls	r2, r3, #31
 8005a88:	d405      	bmi.n	8005a96 <_puts_r+0x72>
 8005a8a:	89a3      	ldrh	r3, [r4, #12]
 8005a8c:	059b      	lsls	r3, r3, #22
 8005a8e:	d402      	bmi.n	8005a96 <_puts_r+0x72>
 8005a90:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8005a92:	f000 f857 	bl	8005b44 <__retarget_lock_release_recursive>
 8005a96:	4628      	mov	r0, r5
 8005a98:	bd70      	pop	{r4, r5, r6, pc}
 8005a9a:	2b00      	cmp	r3, #0
 8005a9c:	da04      	bge.n	8005aa8 <_puts_r+0x84>
 8005a9e:	69a2      	ldr	r2, [r4, #24]
 8005aa0:	429a      	cmp	r2, r3
 8005aa2:	dc06      	bgt.n	8005ab2 <_puts_r+0x8e>
 8005aa4:	290a      	cmp	r1, #10
 8005aa6:	d004      	beq.n	8005ab2 <_puts_r+0x8e>
 8005aa8:	6823      	ldr	r3, [r4, #0]
 8005aaa:	1c5a      	adds	r2, r3, #1
 8005aac:	6022      	str	r2, [r4, #0]
 8005aae:	7019      	strb	r1, [r3, #0]
 8005ab0:	e7cf      	b.n	8005a52 <_puts_r+0x2e>
 8005ab2:	4622      	mov	r2, r4
 8005ab4:	4628      	mov	r0, r5
 8005ab6:	f000 fcb6 	bl	8006426 <__swbuf_r>
 8005aba:	3001      	adds	r0, #1
 8005abc:	d1c9      	bne.n	8005a52 <_puts_r+0x2e>
 8005abe:	e7df      	b.n	8005a80 <_puts_r+0x5c>
 8005ac0:	6823      	ldr	r3, [r4, #0]
 8005ac2:	250a      	movs	r5, #10
 8005ac4:	1c5a      	adds	r2, r3, #1
 8005ac6:	6022      	str	r2, [r4, #0]
 8005ac8:	701d      	strb	r5, [r3, #0]
 8005aca:	e7db      	b.n	8005a84 <_puts_r+0x60>

08005acc <puts>:
 8005acc:	4b02      	ldr	r3, [pc, #8]	; (8005ad8 <puts+0xc>)
 8005ace:	4601      	mov	r1, r0
 8005ad0:	6818      	ldr	r0, [r3, #0]
 8005ad2:	f7ff bfa7 	b.w	8005a24 <_puts_r>
 8005ad6:	bf00      	nop
 8005ad8:	2000006c 	.word	0x2000006c

08005adc <memset>:
 8005adc:	4402      	add	r2, r0
 8005ade:	4603      	mov	r3, r0
 8005ae0:	4293      	cmp	r3, r2
 8005ae2:	d100      	bne.n	8005ae6 <memset+0xa>
 8005ae4:	4770      	bx	lr
 8005ae6:	f803 1b01 	strb.w	r1, [r3], #1
 8005aea:	e7f9      	b.n	8005ae0 <memset+0x4>

08005aec <__errno>:
 8005aec:	4b01      	ldr	r3, [pc, #4]	; (8005af4 <__errno+0x8>)
 8005aee:	6818      	ldr	r0, [r3, #0]
 8005af0:	4770      	bx	lr
 8005af2:	bf00      	nop
 8005af4:	2000006c 	.word	0x2000006c

08005af8 <__libc_init_array>:
 8005af8:	b570      	push	{r4, r5, r6, lr}
 8005afa:	4d0d      	ldr	r5, [pc, #52]	; (8005b30 <__libc_init_array+0x38>)
 8005afc:	2600      	movs	r6, #0
 8005afe:	4c0d      	ldr	r4, [pc, #52]	; (8005b34 <__libc_init_array+0x3c>)
 8005b00:	1b64      	subs	r4, r4, r5
 8005b02:	10a4      	asrs	r4, r4, #2
 8005b04:	42a6      	cmp	r6, r4
 8005b06:	d109      	bne.n	8005b1c <__libc_init_array+0x24>
 8005b08:	4d0b      	ldr	r5, [pc, #44]	; (8005b38 <__libc_init_array+0x40>)
 8005b0a:	2600      	movs	r6, #0
 8005b0c:	4c0b      	ldr	r4, [pc, #44]	; (8005b3c <__libc_init_array+0x44>)
 8005b0e:	f001 f8f5 	bl	8006cfc <_init>
 8005b12:	1b64      	subs	r4, r4, r5
 8005b14:	10a4      	asrs	r4, r4, #2
 8005b16:	42a6      	cmp	r6, r4
 8005b18:	d105      	bne.n	8005b26 <__libc_init_array+0x2e>
 8005b1a:	bd70      	pop	{r4, r5, r6, pc}
 8005b1c:	f855 3b04 	ldr.w	r3, [r5], #4
 8005b20:	3601      	adds	r6, #1
 8005b22:	4798      	blx	r3
 8005b24:	e7ee      	b.n	8005b04 <__libc_init_array+0xc>
 8005b26:	f855 3b04 	ldr.w	r3, [r5], #4
 8005b2a:	3601      	adds	r6, #1
 8005b2c:	4798      	blx	r3
 8005b2e:	e7f2      	b.n	8005b16 <__libc_init_array+0x1e>
 8005b30:	08006f39 	.word	0x08006f39
 8005b34:	08006f39 	.word	0x08006f39
 8005b38:	08006f3c 	.word	0x08006f3c
 8005b3c:	08006f40 	.word	0x08006f40

08005b40 <__retarget_lock_init_recursive>:
 8005b40:	4770      	bx	lr

08005b42 <__retarget_lock_acquire_recursive>:
 8005b42:	4770      	bx	lr

08005b44 <__retarget_lock_release_recursive>:
 8005b44:	4770      	bx	lr

08005b46 <__sfputc_r>:
 8005b46:	6893      	ldr	r3, [r2, #8]
 8005b48:	3b01      	subs	r3, #1
 8005b4a:	2b00      	cmp	r3, #0
 8005b4c:	6093      	str	r3, [r2, #8]
 8005b4e:	b410      	push	{r4}
 8005b50:	da08      	bge.n	8005b64 <__sfputc_r+0x1e>
 8005b52:	6994      	ldr	r4, [r2, #24]
 8005b54:	42a3      	cmp	r3, r4
 8005b56:	db01      	blt.n	8005b5c <__sfputc_r+0x16>
 8005b58:	290a      	cmp	r1, #10
 8005b5a:	d103      	bne.n	8005b64 <__sfputc_r+0x1e>
 8005b5c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005b60:	f000 bc61 	b.w	8006426 <__swbuf_r>
 8005b64:	6813      	ldr	r3, [r2, #0]
 8005b66:	1c58      	adds	r0, r3, #1
 8005b68:	6010      	str	r0, [r2, #0]
 8005b6a:	4608      	mov	r0, r1
 8005b6c:	7019      	strb	r1, [r3, #0]
 8005b6e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005b72:	4770      	bx	lr

08005b74 <__sfputs_r>:
 8005b74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005b76:	4606      	mov	r6, r0
 8005b78:	460f      	mov	r7, r1
 8005b7a:	4614      	mov	r4, r2
 8005b7c:	18d5      	adds	r5, r2, r3
 8005b7e:	42ac      	cmp	r4, r5
 8005b80:	d101      	bne.n	8005b86 <__sfputs_r+0x12>
 8005b82:	2000      	movs	r0, #0
 8005b84:	e007      	b.n	8005b96 <__sfputs_r+0x22>
 8005b86:	463a      	mov	r2, r7
 8005b88:	f814 1b01 	ldrb.w	r1, [r4], #1
 8005b8c:	4630      	mov	r0, r6
 8005b8e:	f7ff ffda 	bl	8005b46 <__sfputc_r>
 8005b92:	1c43      	adds	r3, r0, #1
 8005b94:	d1f3      	bne.n	8005b7e <__sfputs_r+0xa>
 8005b96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005b98 <_vfiprintf_r>:
 8005b98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005b9c:	460d      	mov	r5, r1
 8005b9e:	b09d      	sub	sp, #116	; 0x74
 8005ba0:	4614      	mov	r4, r2
 8005ba2:	4698      	mov	r8, r3
 8005ba4:	4606      	mov	r6, r0
 8005ba6:	b118      	cbz	r0, 8005bb0 <_vfiprintf_r+0x18>
 8005ba8:	6a03      	ldr	r3, [r0, #32]
 8005baa:	b90b      	cbnz	r3, 8005bb0 <_vfiprintf_r+0x18>
 8005bac:	f7ff fef2 	bl	8005994 <__sinit>
 8005bb0:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8005bb2:	07d9      	lsls	r1, r3, #31
 8005bb4:	d405      	bmi.n	8005bc2 <_vfiprintf_r+0x2a>
 8005bb6:	89ab      	ldrh	r3, [r5, #12]
 8005bb8:	059a      	lsls	r2, r3, #22
 8005bba:	d402      	bmi.n	8005bc2 <_vfiprintf_r+0x2a>
 8005bbc:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8005bbe:	f7ff ffc0 	bl	8005b42 <__retarget_lock_acquire_recursive>
 8005bc2:	89ab      	ldrh	r3, [r5, #12]
 8005bc4:	071b      	lsls	r3, r3, #28
 8005bc6:	d501      	bpl.n	8005bcc <_vfiprintf_r+0x34>
 8005bc8:	692b      	ldr	r3, [r5, #16]
 8005bca:	b99b      	cbnz	r3, 8005bf4 <_vfiprintf_r+0x5c>
 8005bcc:	4629      	mov	r1, r5
 8005bce:	4630      	mov	r0, r6
 8005bd0:	f000 fc66 	bl	80064a0 <__swsetup_r>
 8005bd4:	b170      	cbz	r0, 8005bf4 <_vfiprintf_r+0x5c>
 8005bd6:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8005bd8:	07dc      	lsls	r4, r3, #31
 8005bda:	d504      	bpl.n	8005be6 <_vfiprintf_r+0x4e>
 8005bdc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8005be0:	b01d      	add	sp, #116	; 0x74
 8005be2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005be6:	89ab      	ldrh	r3, [r5, #12]
 8005be8:	0598      	lsls	r0, r3, #22
 8005bea:	d4f7      	bmi.n	8005bdc <_vfiprintf_r+0x44>
 8005bec:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8005bee:	f7ff ffa9 	bl	8005b44 <__retarget_lock_release_recursive>
 8005bf2:	e7f3      	b.n	8005bdc <_vfiprintf_r+0x44>
 8005bf4:	2300      	movs	r3, #0
 8005bf6:	f8cd 800c 	str.w	r8, [sp, #12]
 8005bfa:	f04f 0901 	mov.w	r9, #1
 8005bfe:	f8df 81b8 	ldr.w	r8, [pc, #440]	; 8005db8 <_vfiprintf_r+0x220>
 8005c02:	9309      	str	r3, [sp, #36]	; 0x24
 8005c04:	2320      	movs	r3, #32
 8005c06:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8005c0a:	2330      	movs	r3, #48	; 0x30
 8005c0c:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8005c10:	4623      	mov	r3, r4
 8005c12:	469a      	mov	sl, r3
 8005c14:	f813 2b01 	ldrb.w	r2, [r3], #1
 8005c18:	b10a      	cbz	r2, 8005c1e <_vfiprintf_r+0x86>
 8005c1a:	2a25      	cmp	r2, #37	; 0x25
 8005c1c:	d1f9      	bne.n	8005c12 <_vfiprintf_r+0x7a>
 8005c1e:	ebba 0b04 	subs.w	fp, sl, r4
 8005c22:	d00b      	beq.n	8005c3c <_vfiprintf_r+0xa4>
 8005c24:	465b      	mov	r3, fp
 8005c26:	4622      	mov	r2, r4
 8005c28:	4629      	mov	r1, r5
 8005c2a:	4630      	mov	r0, r6
 8005c2c:	f7ff ffa2 	bl	8005b74 <__sfputs_r>
 8005c30:	3001      	adds	r0, #1
 8005c32:	f000 80a9 	beq.w	8005d88 <_vfiprintf_r+0x1f0>
 8005c36:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8005c38:	445a      	add	r2, fp
 8005c3a:	9209      	str	r2, [sp, #36]	; 0x24
 8005c3c:	f89a 3000 	ldrb.w	r3, [sl]
 8005c40:	2b00      	cmp	r3, #0
 8005c42:	f000 80a1 	beq.w	8005d88 <_vfiprintf_r+0x1f0>
 8005c46:	2300      	movs	r3, #0
 8005c48:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005c4c:	f10a 0a01 	add.w	sl, sl, #1
 8005c50:	9304      	str	r3, [sp, #16]
 8005c52:	9307      	str	r3, [sp, #28]
 8005c54:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8005c58:	931a      	str	r3, [sp, #104]	; 0x68
 8005c5a:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8005c5e:	4654      	mov	r4, sl
 8005c60:	2205      	movs	r2, #5
 8005c62:	4855      	ldr	r0, [pc, #340]	; (8005db8 <_vfiprintf_r+0x220>)
 8005c64:	f814 1b01 	ldrb.w	r1, [r4], #1
 8005c68:	f000 fd4c 	bl	8006704 <memchr>
 8005c6c:	9a04      	ldr	r2, [sp, #16]
 8005c6e:	b9d8      	cbnz	r0, 8005ca8 <_vfiprintf_r+0x110>
 8005c70:	06d1      	lsls	r1, r2, #27
 8005c72:	bf44      	itt	mi
 8005c74:	2320      	movmi	r3, #32
 8005c76:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8005c7a:	0713      	lsls	r3, r2, #28
 8005c7c:	bf44      	itt	mi
 8005c7e:	232b      	movmi	r3, #43	; 0x2b
 8005c80:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8005c84:	f89a 3000 	ldrb.w	r3, [sl]
 8005c88:	2b2a      	cmp	r3, #42	; 0x2a
 8005c8a:	d015      	beq.n	8005cb8 <_vfiprintf_r+0x120>
 8005c8c:	9a07      	ldr	r2, [sp, #28]
 8005c8e:	4654      	mov	r4, sl
 8005c90:	2000      	movs	r0, #0
 8005c92:	f04f 0c0a 	mov.w	ip, #10
 8005c96:	4621      	mov	r1, r4
 8005c98:	f811 3b01 	ldrb.w	r3, [r1], #1
 8005c9c:	3b30      	subs	r3, #48	; 0x30
 8005c9e:	2b09      	cmp	r3, #9
 8005ca0:	d94d      	bls.n	8005d3e <_vfiprintf_r+0x1a6>
 8005ca2:	b1b0      	cbz	r0, 8005cd2 <_vfiprintf_r+0x13a>
 8005ca4:	9207      	str	r2, [sp, #28]
 8005ca6:	e014      	b.n	8005cd2 <_vfiprintf_r+0x13a>
 8005ca8:	eba0 0308 	sub.w	r3, r0, r8
 8005cac:	46a2      	mov	sl, r4
 8005cae:	fa09 f303 	lsl.w	r3, r9, r3
 8005cb2:	4313      	orrs	r3, r2
 8005cb4:	9304      	str	r3, [sp, #16]
 8005cb6:	e7d2      	b.n	8005c5e <_vfiprintf_r+0xc6>
 8005cb8:	9b03      	ldr	r3, [sp, #12]
 8005cba:	1d19      	adds	r1, r3, #4
 8005cbc:	681b      	ldr	r3, [r3, #0]
 8005cbe:	2b00      	cmp	r3, #0
 8005cc0:	9103      	str	r1, [sp, #12]
 8005cc2:	bfbb      	ittet	lt
 8005cc4:	425b      	neglt	r3, r3
 8005cc6:	f042 0202 	orrlt.w	r2, r2, #2
 8005cca:	9307      	strge	r3, [sp, #28]
 8005ccc:	9307      	strlt	r3, [sp, #28]
 8005cce:	bfb8      	it	lt
 8005cd0:	9204      	strlt	r2, [sp, #16]
 8005cd2:	7823      	ldrb	r3, [r4, #0]
 8005cd4:	2b2e      	cmp	r3, #46	; 0x2e
 8005cd6:	d10c      	bne.n	8005cf2 <_vfiprintf_r+0x15a>
 8005cd8:	7863      	ldrb	r3, [r4, #1]
 8005cda:	2b2a      	cmp	r3, #42	; 0x2a
 8005cdc:	d134      	bne.n	8005d48 <_vfiprintf_r+0x1b0>
 8005cde:	9b03      	ldr	r3, [sp, #12]
 8005ce0:	3402      	adds	r4, #2
 8005ce2:	1d1a      	adds	r2, r3, #4
 8005ce4:	681b      	ldr	r3, [r3, #0]
 8005ce6:	2b00      	cmp	r3, #0
 8005ce8:	9203      	str	r2, [sp, #12]
 8005cea:	bfb8      	it	lt
 8005cec:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
 8005cf0:	9305      	str	r3, [sp, #20]
 8005cf2:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 8005dc8 <_vfiprintf_r+0x230>
 8005cf6:	2203      	movs	r2, #3
 8005cf8:	7821      	ldrb	r1, [r4, #0]
 8005cfa:	4650      	mov	r0, sl
 8005cfc:	f000 fd02 	bl	8006704 <memchr>
 8005d00:	b138      	cbz	r0, 8005d12 <_vfiprintf_r+0x17a>
 8005d02:	eba0 000a 	sub.w	r0, r0, sl
 8005d06:	2240      	movs	r2, #64	; 0x40
 8005d08:	9b04      	ldr	r3, [sp, #16]
 8005d0a:	3401      	adds	r4, #1
 8005d0c:	4082      	lsls	r2, r0
 8005d0e:	4313      	orrs	r3, r2
 8005d10:	9304      	str	r3, [sp, #16]
 8005d12:	f814 1b01 	ldrb.w	r1, [r4], #1
 8005d16:	2206      	movs	r2, #6
 8005d18:	4828      	ldr	r0, [pc, #160]	; (8005dbc <_vfiprintf_r+0x224>)
 8005d1a:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8005d1e:	f000 fcf1 	bl	8006704 <memchr>
 8005d22:	2800      	cmp	r0, #0
 8005d24:	d03f      	beq.n	8005da6 <_vfiprintf_r+0x20e>
 8005d26:	4b26      	ldr	r3, [pc, #152]	; (8005dc0 <_vfiprintf_r+0x228>)
 8005d28:	bb1b      	cbnz	r3, 8005d72 <_vfiprintf_r+0x1da>
 8005d2a:	9b03      	ldr	r3, [sp, #12]
 8005d2c:	3307      	adds	r3, #7
 8005d2e:	f023 0307 	bic.w	r3, r3, #7
 8005d32:	3308      	adds	r3, #8
 8005d34:	9303      	str	r3, [sp, #12]
 8005d36:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8005d38:	443b      	add	r3, r7
 8005d3a:	9309      	str	r3, [sp, #36]	; 0x24
 8005d3c:	e768      	b.n	8005c10 <_vfiprintf_r+0x78>
 8005d3e:	fb0c 3202 	mla	r2, ip, r2, r3
 8005d42:	460c      	mov	r4, r1
 8005d44:	2001      	movs	r0, #1
 8005d46:	e7a6      	b.n	8005c96 <_vfiprintf_r+0xfe>
 8005d48:	2300      	movs	r3, #0
 8005d4a:	3401      	adds	r4, #1
 8005d4c:	f04f 0c0a 	mov.w	ip, #10
 8005d50:	4619      	mov	r1, r3
 8005d52:	9305      	str	r3, [sp, #20]
 8005d54:	4620      	mov	r0, r4
 8005d56:	f810 2b01 	ldrb.w	r2, [r0], #1
 8005d5a:	3a30      	subs	r2, #48	; 0x30
 8005d5c:	2a09      	cmp	r2, #9
 8005d5e:	d903      	bls.n	8005d68 <_vfiprintf_r+0x1d0>
 8005d60:	2b00      	cmp	r3, #0
 8005d62:	d0c6      	beq.n	8005cf2 <_vfiprintf_r+0x15a>
 8005d64:	9105      	str	r1, [sp, #20]
 8005d66:	e7c4      	b.n	8005cf2 <_vfiprintf_r+0x15a>
 8005d68:	fb0c 2101 	mla	r1, ip, r1, r2
 8005d6c:	4604      	mov	r4, r0
 8005d6e:	2301      	movs	r3, #1
 8005d70:	e7f0      	b.n	8005d54 <_vfiprintf_r+0x1bc>
 8005d72:	ab03      	add	r3, sp, #12
 8005d74:	462a      	mov	r2, r5
 8005d76:	a904      	add	r1, sp, #16
 8005d78:	4630      	mov	r0, r6
 8005d7a:	9300      	str	r3, [sp, #0]
 8005d7c:	4b11      	ldr	r3, [pc, #68]	; (8005dc4 <_vfiprintf_r+0x22c>)
 8005d7e:	f3af 8000 	nop.w
 8005d82:	4607      	mov	r7, r0
 8005d84:	1c78      	adds	r0, r7, #1
 8005d86:	d1d6      	bne.n	8005d36 <_vfiprintf_r+0x19e>
 8005d88:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8005d8a:	07d9      	lsls	r1, r3, #31
 8005d8c:	d405      	bmi.n	8005d9a <_vfiprintf_r+0x202>
 8005d8e:	89ab      	ldrh	r3, [r5, #12]
 8005d90:	059a      	lsls	r2, r3, #22
 8005d92:	d402      	bmi.n	8005d9a <_vfiprintf_r+0x202>
 8005d94:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8005d96:	f7ff fed5 	bl	8005b44 <__retarget_lock_release_recursive>
 8005d9a:	89ab      	ldrh	r3, [r5, #12]
 8005d9c:	065b      	lsls	r3, r3, #25
 8005d9e:	f53f af1d 	bmi.w	8005bdc <_vfiprintf_r+0x44>
 8005da2:	9809      	ldr	r0, [sp, #36]	; 0x24
 8005da4:	e71c      	b.n	8005be0 <_vfiprintf_r+0x48>
 8005da6:	ab03      	add	r3, sp, #12
 8005da8:	462a      	mov	r2, r5
 8005daa:	a904      	add	r1, sp, #16
 8005dac:	4630      	mov	r0, r6
 8005dae:	9300      	str	r3, [sp, #0]
 8005db0:	4b04      	ldr	r3, [pc, #16]	; (8005dc4 <_vfiprintf_r+0x22c>)
 8005db2:	f000 f91d 	bl	8005ff0 <_printf_i>
 8005db6:	e7e4      	b.n	8005d82 <_vfiprintf_r+0x1ea>
 8005db8:	08006eec 	.word	0x08006eec
 8005dbc:	08006ef6 	.word	0x08006ef6
 8005dc0:	00000000 	.word	0x00000000
 8005dc4:	08005b75 	.word	0x08005b75
 8005dc8:	08006ef2 	.word	0x08006ef2

08005dcc <sbrk_aligned>:
 8005dcc:	b570      	push	{r4, r5, r6, lr}
 8005dce:	4e0e      	ldr	r6, [pc, #56]	; (8005e08 <sbrk_aligned+0x3c>)
 8005dd0:	460c      	mov	r4, r1
 8005dd2:	4605      	mov	r5, r0
 8005dd4:	6831      	ldr	r1, [r6, #0]
 8005dd6:	b911      	cbnz	r1, 8005dde <sbrk_aligned+0x12>
 8005dd8:	f000 fc72 	bl	80066c0 <_sbrk_r>
 8005ddc:	6030      	str	r0, [r6, #0]
 8005dde:	4621      	mov	r1, r4
 8005de0:	4628      	mov	r0, r5
 8005de2:	f000 fc6d 	bl	80066c0 <_sbrk_r>
 8005de6:	1c43      	adds	r3, r0, #1
 8005de8:	d00a      	beq.n	8005e00 <sbrk_aligned+0x34>
 8005dea:	1cc4      	adds	r4, r0, #3
 8005dec:	f024 0403 	bic.w	r4, r4, #3
 8005df0:	42a0      	cmp	r0, r4
 8005df2:	d007      	beq.n	8005e04 <sbrk_aligned+0x38>
 8005df4:	1a21      	subs	r1, r4, r0
 8005df6:	4628      	mov	r0, r5
 8005df8:	f000 fc62 	bl	80066c0 <_sbrk_r>
 8005dfc:	3001      	adds	r0, #1
 8005dfe:	d101      	bne.n	8005e04 <sbrk_aligned+0x38>
 8005e00:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8005e04:	4620      	mov	r0, r4
 8005e06:	bd70      	pop	{r4, r5, r6, pc}
 8005e08:	2000125c 	.word	0x2000125c

08005e0c <_malloc_r>:
 8005e0c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005e10:	1ccd      	adds	r5, r1, #3
 8005e12:	4607      	mov	r7, r0
 8005e14:	f025 0503 	bic.w	r5, r5, #3
 8005e18:	3508      	adds	r5, #8
 8005e1a:	2d0c      	cmp	r5, #12
 8005e1c:	bf38      	it	cc
 8005e1e:	250c      	movcc	r5, #12
 8005e20:	2d00      	cmp	r5, #0
 8005e22:	db01      	blt.n	8005e28 <_malloc_r+0x1c>
 8005e24:	42a9      	cmp	r1, r5
 8005e26:	d905      	bls.n	8005e34 <_malloc_r+0x28>
 8005e28:	230c      	movs	r3, #12
 8005e2a:	2600      	movs	r6, #0
 8005e2c:	603b      	str	r3, [r7, #0]
 8005e2e:	4630      	mov	r0, r6
 8005e30:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005e34:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 8005f08 <_malloc_r+0xfc>
 8005e38:	f000 faa6 	bl	8006388 <__malloc_lock>
 8005e3c:	f8d8 3000 	ldr.w	r3, [r8]
 8005e40:	461c      	mov	r4, r3
 8005e42:	bb5c      	cbnz	r4, 8005e9c <_malloc_r+0x90>
 8005e44:	4629      	mov	r1, r5
 8005e46:	4638      	mov	r0, r7
 8005e48:	f7ff ffc0 	bl	8005dcc <sbrk_aligned>
 8005e4c:	1c43      	adds	r3, r0, #1
 8005e4e:	4604      	mov	r4, r0
 8005e50:	d155      	bne.n	8005efe <_malloc_r+0xf2>
 8005e52:	f8d8 4000 	ldr.w	r4, [r8]
 8005e56:	4626      	mov	r6, r4
 8005e58:	2e00      	cmp	r6, #0
 8005e5a:	d145      	bne.n	8005ee8 <_malloc_r+0xdc>
 8005e5c:	2c00      	cmp	r4, #0
 8005e5e:	d048      	beq.n	8005ef2 <_malloc_r+0xe6>
 8005e60:	6823      	ldr	r3, [r4, #0]
 8005e62:	4631      	mov	r1, r6
 8005e64:	4638      	mov	r0, r7
 8005e66:	eb04 0903 	add.w	r9, r4, r3
 8005e6a:	f000 fc29 	bl	80066c0 <_sbrk_r>
 8005e6e:	4581      	cmp	r9, r0
 8005e70:	d13f      	bne.n	8005ef2 <_malloc_r+0xe6>
 8005e72:	6821      	ldr	r1, [r4, #0]
 8005e74:	4638      	mov	r0, r7
 8005e76:	1a6d      	subs	r5, r5, r1
 8005e78:	4629      	mov	r1, r5
 8005e7a:	f7ff ffa7 	bl	8005dcc <sbrk_aligned>
 8005e7e:	3001      	adds	r0, #1
 8005e80:	d037      	beq.n	8005ef2 <_malloc_r+0xe6>
 8005e82:	6823      	ldr	r3, [r4, #0]
 8005e84:	442b      	add	r3, r5
 8005e86:	6023      	str	r3, [r4, #0]
 8005e88:	f8d8 3000 	ldr.w	r3, [r8]
 8005e8c:	2b00      	cmp	r3, #0
 8005e8e:	d038      	beq.n	8005f02 <_malloc_r+0xf6>
 8005e90:	685a      	ldr	r2, [r3, #4]
 8005e92:	42a2      	cmp	r2, r4
 8005e94:	d12b      	bne.n	8005eee <_malloc_r+0xe2>
 8005e96:	2200      	movs	r2, #0
 8005e98:	605a      	str	r2, [r3, #4]
 8005e9a:	e00f      	b.n	8005ebc <_malloc_r+0xb0>
 8005e9c:	6822      	ldr	r2, [r4, #0]
 8005e9e:	1b52      	subs	r2, r2, r5
 8005ea0:	d41f      	bmi.n	8005ee2 <_malloc_r+0xd6>
 8005ea2:	2a0b      	cmp	r2, #11
 8005ea4:	d917      	bls.n	8005ed6 <_malloc_r+0xca>
 8005ea6:	1961      	adds	r1, r4, r5
 8005ea8:	42a3      	cmp	r3, r4
 8005eaa:	6025      	str	r5, [r4, #0]
 8005eac:	bf18      	it	ne
 8005eae:	6059      	strne	r1, [r3, #4]
 8005eb0:	6863      	ldr	r3, [r4, #4]
 8005eb2:	bf08      	it	eq
 8005eb4:	f8c8 1000 	streq.w	r1, [r8]
 8005eb8:	5162      	str	r2, [r4, r5]
 8005eba:	604b      	str	r3, [r1, #4]
 8005ebc:	f104 060b 	add.w	r6, r4, #11
 8005ec0:	4638      	mov	r0, r7
 8005ec2:	f000 fa67 	bl	8006394 <__malloc_unlock>
 8005ec6:	1d23      	adds	r3, r4, #4
 8005ec8:	f026 0607 	bic.w	r6, r6, #7
 8005ecc:	1af2      	subs	r2, r6, r3
 8005ece:	d0ae      	beq.n	8005e2e <_malloc_r+0x22>
 8005ed0:	1b9b      	subs	r3, r3, r6
 8005ed2:	50a3      	str	r3, [r4, r2]
 8005ed4:	e7ab      	b.n	8005e2e <_malloc_r+0x22>
 8005ed6:	42a3      	cmp	r3, r4
 8005ed8:	6862      	ldr	r2, [r4, #4]
 8005eda:	d1dd      	bne.n	8005e98 <_malloc_r+0x8c>
 8005edc:	f8c8 2000 	str.w	r2, [r8]
 8005ee0:	e7ec      	b.n	8005ebc <_malloc_r+0xb0>
 8005ee2:	4623      	mov	r3, r4
 8005ee4:	6864      	ldr	r4, [r4, #4]
 8005ee6:	e7ac      	b.n	8005e42 <_malloc_r+0x36>
 8005ee8:	4634      	mov	r4, r6
 8005eea:	6876      	ldr	r6, [r6, #4]
 8005eec:	e7b4      	b.n	8005e58 <_malloc_r+0x4c>
 8005eee:	4613      	mov	r3, r2
 8005ef0:	e7cc      	b.n	8005e8c <_malloc_r+0x80>
 8005ef2:	230c      	movs	r3, #12
 8005ef4:	4638      	mov	r0, r7
 8005ef6:	603b      	str	r3, [r7, #0]
 8005ef8:	f000 fa4c 	bl	8006394 <__malloc_unlock>
 8005efc:	e797      	b.n	8005e2e <_malloc_r+0x22>
 8005efe:	6025      	str	r5, [r4, #0]
 8005f00:	e7dc      	b.n	8005ebc <_malloc_r+0xb0>
 8005f02:	605b      	str	r3, [r3, #4]
 8005f04:	deff      	udf	#255	; 0xff
 8005f06:	bf00      	nop
 8005f08:	20001258 	.word	0x20001258

08005f0c <_printf_common>:
 8005f0c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005f10:	4616      	mov	r6, r2
 8005f12:	4699      	mov	r9, r3
 8005f14:	688a      	ldr	r2, [r1, #8]
 8005f16:	4607      	mov	r7, r0
 8005f18:	690b      	ldr	r3, [r1, #16]
 8005f1a:	460c      	mov	r4, r1
 8005f1c:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8005f20:	4293      	cmp	r3, r2
 8005f22:	bfb8      	it	lt
 8005f24:	4613      	movlt	r3, r2
 8005f26:	6033      	str	r3, [r6, #0]
 8005f28:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8005f2c:	b10a      	cbz	r2, 8005f32 <_printf_common+0x26>
 8005f2e:	3301      	adds	r3, #1
 8005f30:	6033      	str	r3, [r6, #0]
 8005f32:	6823      	ldr	r3, [r4, #0]
 8005f34:	0699      	lsls	r1, r3, #26
 8005f36:	bf42      	ittt	mi
 8005f38:	6833      	ldrmi	r3, [r6, #0]
 8005f3a:	3302      	addmi	r3, #2
 8005f3c:	6033      	strmi	r3, [r6, #0]
 8005f3e:	6825      	ldr	r5, [r4, #0]
 8005f40:	f015 0506 	ands.w	r5, r5, #6
 8005f44:	d106      	bne.n	8005f54 <_printf_common+0x48>
 8005f46:	f104 0a19 	add.w	sl, r4, #25
 8005f4a:	68e3      	ldr	r3, [r4, #12]
 8005f4c:	6832      	ldr	r2, [r6, #0]
 8005f4e:	1a9b      	subs	r3, r3, r2
 8005f50:	42ab      	cmp	r3, r5
 8005f52:	dc2b      	bgt.n	8005fac <_printf_common+0xa0>
 8005f54:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 8005f58:	1e13      	subs	r3, r2, #0
 8005f5a:	6822      	ldr	r2, [r4, #0]
 8005f5c:	bf18      	it	ne
 8005f5e:	2301      	movne	r3, #1
 8005f60:	0692      	lsls	r2, r2, #26
 8005f62:	d430      	bmi.n	8005fc6 <_printf_common+0xba>
 8005f64:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8005f68:	4649      	mov	r1, r9
 8005f6a:	4638      	mov	r0, r7
 8005f6c:	47c0      	blx	r8
 8005f6e:	3001      	adds	r0, #1
 8005f70:	d023      	beq.n	8005fba <_printf_common+0xae>
 8005f72:	6823      	ldr	r3, [r4, #0]
 8005f74:	341a      	adds	r4, #26
 8005f76:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 8005f7a:	f003 0306 	and.w	r3, r3, #6
 8005f7e:	2b04      	cmp	r3, #4
 8005f80:	bf0a      	itet	eq
 8005f82:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
 8005f86:	2500      	movne	r5, #0
 8005f88:	6833      	ldreq	r3, [r6, #0]
 8005f8a:	f04f 0600 	mov.w	r6, #0
 8005f8e:	bf08      	it	eq
 8005f90:	1aed      	subeq	r5, r5, r3
 8005f92:	f854 3c12 	ldr.w	r3, [r4, #-18]
 8005f96:	bf08      	it	eq
 8005f98:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8005f9c:	4293      	cmp	r3, r2
 8005f9e:	bfc4      	itt	gt
 8005fa0:	1a9b      	subgt	r3, r3, r2
 8005fa2:	18ed      	addgt	r5, r5, r3
 8005fa4:	42b5      	cmp	r5, r6
 8005fa6:	d11a      	bne.n	8005fde <_printf_common+0xd2>
 8005fa8:	2000      	movs	r0, #0
 8005faa:	e008      	b.n	8005fbe <_printf_common+0xb2>
 8005fac:	2301      	movs	r3, #1
 8005fae:	4652      	mov	r2, sl
 8005fb0:	4649      	mov	r1, r9
 8005fb2:	4638      	mov	r0, r7
 8005fb4:	47c0      	blx	r8
 8005fb6:	3001      	adds	r0, #1
 8005fb8:	d103      	bne.n	8005fc2 <_printf_common+0xb6>
 8005fba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8005fbe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005fc2:	3501      	adds	r5, #1
 8005fc4:	e7c1      	b.n	8005f4a <_printf_common+0x3e>
 8005fc6:	18e1      	adds	r1, r4, r3
 8005fc8:	1c5a      	adds	r2, r3, #1
 8005fca:	2030      	movs	r0, #48	; 0x30
 8005fcc:	3302      	adds	r3, #2
 8005fce:	4422      	add	r2, r4
 8005fd0:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8005fd4:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8005fd8:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8005fdc:	e7c2      	b.n	8005f64 <_printf_common+0x58>
 8005fde:	2301      	movs	r3, #1
 8005fe0:	4622      	mov	r2, r4
 8005fe2:	4649      	mov	r1, r9
 8005fe4:	4638      	mov	r0, r7
 8005fe6:	47c0      	blx	r8
 8005fe8:	3001      	adds	r0, #1
 8005fea:	d0e6      	beq.n	8005fba <_printf_common+0xae>
 8005fec:	3601      	adds	r6, #1
 8005fee:	e7d9      	b.n	8005fa4 <_printf_common+0x98>

08005ff0 <_printf_i>:
 8005ff0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8005ff4:	7e0f      	ldrb	r7, [r1, #24]
 8005ff6:	4691      	mov	r9, r2
 8005ff8:	4680      	mov	r8, r0
 8005ffa:	460c      	mov	r4, r1
 8005ffc:	2f78      	cmp	r7, #120	; 0x78
 8005ffe:	469a      	mov	sl, r3
 8006000:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8006002:	f101 0243 	add.w	r2, r1, #67	; 0x43
 8006006:	d807      	bhi.n	8006018 <_printf_i+0x28>
 8006008:	2f62      	cmp	r7, #98	; 0x62
 800600a:	d80a      	bhi.n	8006022 <_printf_i+0x32>
 800600c:	2f00      	cmp	r7, #0
 800600e:	f000 80d3 	beq.w	80061b8 <_printf_i+0x1c8>
 8006012:	2f58      	cmp	r7, #88	; 0x58
 8006014:	f000 80bf 	beq.w	8006196 <_printf_i+0x1a6>
 8006018:	f104 0542 	add.w	r5, r4, #66	; 0x42
 800601c:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 8006020:	e03a      	b.n	8006098 <_printf_i+0xa8>
 8006022:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 8006026:	2b15      	cmp	r3, #21
 8006028:	d8f6      	bhi.n	8006018 <_printf_i+0x28>
 800602a:	a101      	add	r1, pc, #4	; (adr r1, 8006030 <_printf_i+0x40>)
 800602c:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8006030:	08006089 	.word	0x08006089
 8006034:	0800609d 	.word	0x0800609d
 8006038:	08006019 	.word	0x08006019
 800603c:	08006019 	.word	0x08006019
 8006040:	08006019 	.word	0x08006019
 8006044:	08006019 	.word	0x08006019
 8006048:	0800609d 	.word	0x0800609d
 800604c:	08006019 	.word	0x08006019
 8006050:	08006019 	.word	0x08006019
 8006054:	08006019 	.word	0x08006019
 8006058:	08006019 	.word	0x08006019
 800605c:	0800619f 	.word	0x0800619f
 8006060:	080060c9 	.word	0x080060c9
 8006064:	0800615b 	.word	0x0800615b
 8006068:	08006019 	.word	0x08006019
 800606c:	08006019 	.word	0x08006019
 8006070:	080061c1 	.word	0x080061c1
 8006074:	08006019 	.word	0x08006019
 8006078:	080060c9 	.word	0x080060c9
 800607c:	08006019 	.word	0x08006019
 8006080:	08006019 	.word	0x08006019
 8006084:	08006163 	.word	0x08006163
 8006088:	682b      	ldr	r3, [r5, #0]
 800608a:	1d1a      	adds	r2, r3, #4
 800608c:	681b      	ldr	r3, [r3, #0]
 800608e:	602a      	str	r2, [r5, #0]
 8006090:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8006094:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8006098:	2301      	movs	r3, #1
 800609a:	e09e      	b.n	80061da <_printf_i+0x1ea>
 800609c:	6820      	ldr	r0, [r4, #0]
 800609e:	682b      	ldr	r3, [r5, #0]
 80060a0:	0607      	lsls	r7, r0, #24
 80060a2:	f103 0104 	add.w	r1, r3, #4
 80060a6:	6029      	str	r1, [r5, #0]
 80060a8:	d501      	bpl.n	80060ae <_printf_i+0xbe>
 80060aa:	681e      	ldr	r6, [r3, #0]
 80060ac:	e003      	b.n	80060b6 <_printf_i+0xc6>
 80060ae:	0646      	lsls	r6, r0, #25
 80060b0:	d5fb      	bpl.n	80060aa <_printf_i+0xba>
 80060b2:	f9b3 6000 	ldrsh.w	r6, [r3]
 80060b6:	2e00      	cmp	r6, #0
 80060b8:	da03      	bge.n	80060c2 <_printf_i+0xd2>
 80060ba:	232d      	movs	r3, #45	; 0x2d
 80060bc:	4276      	negs	r6, r6
 80060be:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80060c2:	4859      	ldr	r0, [pc, #356]	; (8006228 <_printf_i+0x238>)
 80060c4:	230a      	movs	r3, #10
 80060c6:	e012      	b.n	80060ee <_printf_i+0xfe>
 80060c8:	682b      	ldr	r3, [r5, #0]
 80060ca:	6820      	ldr	r0, [r4, #0]
 80060cc:	1d19      	adds	r1, r3, #4
 80060ce:	6029      	str	r1, [r5, #0]
 80060d0:	0605      	lsls	r5, r0, #24
 80060d2:	d501      	bpl.n	80060d8 <_printf_i+0xe8>
 80060d4:	681e      	ldr	r6, [r3, #0]
 80060d6:	e002      	b.n	80060de <_printf_i+0xee>
 80060d8:	0641      	lsls	r1, r0, #25
 80060da:	d5fb      	bpl.n	80060d4 <_printf_i+0xe4>
 80060dc:	881e      	ldrh	r6, [r3, #0]
 80060de:	2f6f      	cmp	r7, #111	; 0x6f
 80060e0:	4851      	ldr	r0, [pc, #324]	; (8006228 <_printf_i+0x238>)
 80060e2:	bf0c      	ite	eq
 80060e4:	2308      	moveq	r3, #8
 80060e6:	230a      	movne	r3, #10
 80060e8:	2100      	movs	r1, #0
 80060ea:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 80060ee:	6865      	ldr	r5, [r4, #4]
 80060f0:	2d00      	cmp	r5, #0
 80060f2:	60a5      	str	r5, [r4, #8]
 80060f4:	bfa2      	ittt	ge
 80060f6:	6821      	ldrge	r1, [r4, #0]
 80060f8:	f021 0104 	bicge.w	r1, r1, #4
 80060fc:	6021      	strge	r1, [r4, #0]
 80060fe:	b90e      	cbnz	r6, 8006104 <_printf_i+0x114>
 8006100:	2d00      	cmp	r5, #0
 8006102:	d04a      	beq.n	800619a <_printf_i+0x1aa>
 8006104:	4615      	mov	r5, r2
 8006106:	fbb6 f1f3 	udiv	r1, r6, r3
 800610a:	fb03 6711 	mls	r7, r3, r1, r6
 800610e:	5dc7      	ldrb	r7, [r0, r7]
 8006110:	f805 7d01 	strb.w	r7, [r5, #-1]!
 8006114:	4637      	mov	r7, r6
 8006116:	460e      	mov	r6, r1
 8006118:	42bb      	cmp	r3, r7
 800611a:	d9f4      	bls.n	8006106 <_printf_i+0x116>
 800611c:	2b08      	cmp	r3, #8
 800611e:	d10b      	bne.n	8006138 <_printf_i+0x148>
 8006120:	6823      	ldr	r3, [r4, #0]
 8006122:	07de      	lsls	r6, r3, #31
 8006124:	d508      	bpl.n	8006138 <_printf_i+0x148>
 8006126:	6923      	ldr	r3, [r4, #16]
 8006128:	6861      	ldr	r1, [r4, #4]
 800612a:	4299      	cmp	r1, r3
 800612c:	bfde      	ittt	le
 800612e:	2330      	movle	r3, #48	; 0x30
 8006130:	f805 3c01 	strble.w	r3, [r5, #-1]
 8006134:	f105 35ff 	addle.w	r5, r5, #4294967295	; 0xffffffff
 8006138:	1b52      	subs	r2, r2, r5
 800613a:	6122      	str	r2, [r4, #16]
 800613c:	464b      	mov	r3, r9
 800613e:	aa03      	add	r2, sp, #12
 8006140:	4621      	mov	r1, r4
 8006142:	4640      	mov	r0, r8
 8006144:	f8cd a000 	str.w	sl, [sp]
 8006148:	f7ff fee0 	bl	8005f0c <_printf_common>
 800614c:	3001      	adds	r0, #1
 800614e:	d149      	bne.n	80061e4 <_printf_i+0x1f4>
 8006150:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006154:	b004      	add	sp, #16
 8006156:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800615a:	6823      	ldr	r3, [r4, #0]
 800615c:	f043 0320 	orr.w	r3, r3, #32
 8006160:	6023      	str	r3, [r4, #0]
 8006162:	2778      	movs	r7, #120	; 0x78
 8006164:	4831      	ldr	r0, [pc, #196]	; (800622c <_printf_i+0x23c>)
 8006166:	6823      	ldr	r3, [r4, #0]
 8006168:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 800616c:	061f      	lsls	r7, r3, #24
 800616e:	6829      	ldr	r1, [r5, #0]
 8006170:	f851 6b04 	ldr.w	r6, [r1], #4
 8006174:	d402      	bmi.n	800617c <_printf_i+0x18c>
 8006176:	065f      	lsls	r7, r3, #25
 8006178:	bf48      	it	mi
 800617a:	b2b6      	uxthmi	r6, r6
 800617c:	07df      	lsls	r7, r3, #31
 800617e:	6029      	str	r1, [r5, #0]
 8006180:	bf44      	itt	mi
 8006182:	f043 0320 	orrmi.w	r3, r3, #32
 8006186:	6023      	strmi	r3, [r4, #0]
 8006188:	b91e      	cbnz	r6, 8006192 <_printf_i+0x1a2>
 800618a:	6823      	ldr	r3, [r4, #0]
 800618c:	f023 0320 	bic.w	r3, r3, #32
 8006190:	6023      	str	r3, [r4, #0]
 8006192:	2310      	movs	r3, #16
 8006194:	e7a8      	b.n	80060e8 <_printf_i+0xf8>
 8006196:	4824      	ldr	r0, [pc, #144]	; (8006228 <_printf_i+0x238>)
 8006198:	e7e5      	b.n	8006166 <_printf_i+0x176>
 800619a:	4615      	mov	r5, r2
 800619c:	e7be      	b.n	800611c <_printf_i+0x12c>
 800619e:	682b      	ldr	r3, [r5, #0]
 80061a0:	6826      	ldr	r6, [r4, #0]
 80061a2:	1d18      	adds	r0, r3, #4
 80061a4:	6961      	ldr	r1, [r4, #20]
 80061a6:	6028      	str	r0, [r5, #0]
 80061a8:	0635      	lsls	r5, r6, #24
 80061aa:	681b      	ldr	r3, [r3, #0]
 80061ac:	d501      	bpl.n	80061b2 <_printf_i+0x1c2>
 80061ae:	6019      	str	r1, [r3, #0]
 80061b0:	e002      	b.n	80061b8 <_printf_i+0x1c8>
 80061b2:	0670      	lsls	r0, r6, #25
 80061b4:	d5fb      	bpl.n	80061ae <_printf_i+0x1be>
 80061b6:	8019      	strh	r1, [r3, #0]
 80061b8:	2300      	movs	r3, #0
 80061ba:	4615      	mov	r5, r2
 80061bc:	6123      	str	r3, [r4, #16]
 80061be:	e7bd      	b.n	800613c <_printf_i+0x14c>
 80061c0:	682b      	ldr	r3, [r5, #0]
 80061c2:	2100      	movs	r1, #0
 80061c4:	1d1a      	adds	r2, r3, #4
 80061c6:	602a      	str	r2, [r5, #0]
 80061c8:	681d      	ldr	r5, [r3, #0]
 80061ca:	6862      	ldr	r2, [r4, #4]
 80061cc:	4628      	mov	r0, r5
 80061ce:	f000 fa99 	bl	8006704 <memchr>
 80061d2:	b108      	cbz	r0, 80061d8 <_printf_i+0x1e8>
 80061d4:	1b40      	subs	r0, r0, r5
 80061d6:	6060      	str	r0, [r4, #4]
 80061d8:	6863      	ldr	r3, [r4, #4]
 80061da:	6123      	str	r3, [r4, #16]
 80061dc:	2300      	movs	r3, #0
 80061de:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80061e2:	e7ab      	b.n	800613c <_printf_i+0x14c>
 80061e4:	6923      	ldr	r3, [r4, #16]
 80061e6:	462a      	mov	r2, r5
 80061e8:	4649      	mov	r1, r9
 80061ea:	4640      	mov	r0, r8
 80061ec:	47d0      	blx	sl
 80061ee:	3001      	adds	r0, #1
 80061f0:	d0ae      	beq.n	8006150 <_printf_i+0x160>
 80061f2:	6823      	ldr	r3, [r4, #0]
 80061f4:	079b      	lsls	r3, r3, #30
 80061f6:	d413      	bmi.n	8006220 <_printf_i+0x230>
 80061f8:	68e0      	ldr	r0, [r4, #12]
 80061fa:	9b03      	ldr	r3, [sp, #12]
 80061fc:	4298      	cmp	r0, r3
 80061fe:	bfb8      	it	lt
 8006200:	4618      	movlt	r0, r3
 8006202:	e7a7      	b.n	8006154 <_printf_i+0x164>
 8006204:	2301      	movs	r3, #1
 8006206:	4632      	mov	r2, r6
 8006208:	4649      	mov	r1, r9
 800620a:	4640      	mov	r0, r8
 800620c:	47d0      	blx	sl
 800620e:	3001      	adds	r0, #1
 8006210:	d09e      	beq.n	8006150 <_printf_i+0x160>
 8006212:	3501      	adds	r5, #1
 8006214:	68e3      	ldr	r3, [r4, #12]
 8006216:	9903      	ldr	r1, [sp, #12]
 8006218:	1a5b      	subs	r3, r3, r1
 800621a:	42ab      	cmp	r3, r5
 800621c:	dcf2      	bgt.n	8006204 <_printf_i+0x214>
 800621e:	e7eb      	b.n	80061f8 <_printf_i+0x208>
 8006220:	2500      	movs	r5, #0
 8006222:	f104 0619 	add.w	r6, r4, #25
 8006226:	e7f5      	b.n	8006214 <_printf_i+0x224>
 8006228:	08006efd 	.word	0x08006efd
 800622c:	08006f0e 	.word	0x08006f0e

08006230 <__sflush_r>:
 8006230:	898a      	ldrh	r2, [r1, #12]
 8006232:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006236:	4605      	mov	r5, r0
 8006238:	0710      	lsls	r0, r2, #28
 800623a:	460c      	mov	r4, r1
 800623c:	d458      	bmi.n	80062f0 <__sflush_r+0xc0>
 800623e:	684b      	ldr	r3, [r1, #4]
 8006240:	2b00      	cmp	r3, #0
 8006242:	dc05      	bgt.n	8006250 <__sflush_r+0x20>
 8006244:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8006246:	2b00      	cmp	r3, #0
 8006248:	dc02      	bgt.n	8006250 <__sflush_r+0x20>
 800624a:	2000      	movs	r0, #0
 800624c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006250:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8006252:	2e00      	cmp	r6, #0
 8006254:	d0f9      	beq.n	800624a <__sflush_r+0x1a>
 8006256:	2300      	movs	r3, #0
 8006258:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 800625c:	682f      	ldr	r7, [r5, #0]
 800625e:	6a21      	ldr	r1, [r4, #32]
 8006260:	602b      	str	r3, [r5, #0]
 8006262:	d032      	beq.n	80062ca <__sflush_r+0x9a>
 8006264:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8006266:	89a3      	ldrh	r3, [r4, #12]
 8006268:	075a      	lsls	r2, r3, #29
 800626a:	d505      	bpl.n	8006278 <__sflush_r+0x48>
 800626c:	6863      	ldr	r3, [r4, #4]
 800626e:	1ac0      	subs	r0, r0, r3
 8006270:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8006272:	b10b      	cbz	r3, 8006278 <__sflush_r+0x48>
 8006274:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8006276:	1ac0      	subs	r0, r0, r3
 8006278:	2300      	movs	r3, #0
 800627a:	4602      	mov	r2, r0
 800627c:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800627e:	4628      	mov	r0, r5
 8006280:	6a21      	ldr	r1, [r4, #32]
 8006282:	47b0      	blx	r6
 8006284:	1c43      	adds	r3, r0, #1
 8006286:	89a3      	ldrh	r3, [r4, #12]
 8006288:	d106      	bne.n	8006298 <__sflush_r+0x68>
 800628a:	6829      	ldr	r1, [r5, #0]
 800628c:	291d      	cmp	r1, #29
 800628e:	d82b      	bhi.n	80062e8 <__sflush_r+0xb8>
 8006290:	4a28      	ldr	r2, [pc, #160]	; (8006334 <__sflush_r+0x104>)
 8006292:	410a      	asrs	r2, r1
 8006294:	07d6      	lsls	r6, r2, #31
 8006296:	d427      	bmi.n	80062e8 <__sflush_r+0xb8>
 8006298:	2200      	movs	r2, #0
 800629a:	04d9      	lsls	r1, r3, #19
 800629c:	6062      	str	r2, [r4, #4]
 800629e:	6922      	ldr	r2, [r4, #16]
 80062a0:	6022      	str	r2, [r4, #0]
 80062a2:	d504      	bpl.n	80062ae <__sflush_r+0x7e>
 80062a4:	1c42      	adds	r2, r0, #1
 80062a6:	d101      	bne.n	80062ac <__sflush_r+0x7c>
 80062a8:	682b      	ldr	r3, [r5, #0]
 80062aa:	b903      	cbnz	r3, 80062ae <__sflush_r+0x7e>
 80062ac:	6560      	str	r0, [r4, #84]	; 0x54
 80062ae:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80062b0:	602f      	str	r7, [r5, #0]
 80062b2:	2900      	cmp	r1, #0
 80062b4:	d0c9      	beq.n	800624a <__sflush_r+0x1a>
 80062b6:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80062ba:	4299      	cmp	r1, r3
 80062bc:	d002      	beq.n	80062c4 <__sflush_r+0x94>
 80062be:	4628      	mov	r0, r5
 80062c0:	f000 fa2e 	bl	8006720 <_free_r>
 80062c4:	2000      	movs	r0, #0
 80062c6:	6360      	str	r0, [r4, #52]	; 0x34
 80062c8:	e7c0      	b.n	800624c <__sflush_r+0x1c>
 80062ca:	2301      	movs	r3, #1
 80062cc:	4628      	mov	r0, r5
 80062ce:	47b0      	blx	r6
 80062d0:	1c41      	adds	r1, r0, #1
 80062d2:	d1c8      	bne.n	8006266 <__sflush_r+0x36>
 80062d4:	682b      	ldr	r3, [r5, #0]
 80062d6:	2b00      	cmp	r3, #0
 80062d8:	d0c5      	beq.n	8006266 <__sflush_r+0x36>
 80062da:	2b1d      	cmp	r3, #29
 80062dc:	d001      	beq.n	80062e2 <__sflush_r+0xb2>
 80062de:	2b16      	cmp	r3, #22
 80062e0:	d101      	bne.n	80062e6 <__sflush_r+0xb6>
 80062e2:	602f      	str	r7, [r5, #0]
 80062e4:	e7b1      	b.n	800624a <__sflush_r+0x1a>
 80062e6:	89a3      	ldrh	r3, [r4, #12]
 80062e8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80062ec:	81a3      	strh	r3, [r4, #12]
 80062ee:	e7ad      	b.n	800624c <__sflush_r+0x1c>
 80062f0:	690f      	ldr	r7, [r1, #16]
 80062f2:	2f00      	cmp	r7, #0
 80062f4:	d0a9      	beq.n	800624a <__sflush_r+0x1a>
 80062f6:	0793      	lsls	r3, r2, #30
 80062f8:	680e      	ldr	r6, [r1, #0]
 80062fa:	600f      	str	r7, [r1, #0]
 80062fc:	bf0c      	ite	eq
 80062fe:	694b      	ldreq	r3, [r1, #20]
 8006300:	2300      	movne	r3, #0
 8006302:	eba6 0807 	sub.w	r8, r6, r7
 8006306:	608b      	str	r3, [r1, #8]
 8006308:	f1b8 0f00 	cmp.w	r8, #0
 800630c:	dd9d      	ble.n	800624a <__sflush_r+0x1a>
 800630e:	4643      	mov	r3, r8
 8006310:	463a      	mov	r2, r7
 8006312:	6a21      	ldr	r1, [r4, #32]
 8006314:	4628      	mov	r0, r5
 8006316:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8006318:	47b0      	blx	r6
 800631a:	2800      	cmp	r0, #0
 800631c:	dc06      	bgt.n	800632c <__sflush_r+0xfc>
 800631e:	89a3      	ldrh	r3, [r4, #12]
 8006320:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006324:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8006328:	81a3      	strh	r3, [r4, #12]
 800632a:	e78f      	b.n	800624c <__sflush_r+0x1c>
 800632c:	4407      	add	r7, r0
 800632e:	eba8 0800 	sub.w	r8, r8, r0
 8006332:	e7e9      	b.n	8006308 <__sflush_r+0xd8>
 8006334:	dfbffffe 	.word	0xdfbffffe

08006338 <_fflush_r>:
 8006338:	b538      	push	{r3, r4, r5, lr}
 800633a:	690b      	ldr	r3, [r1, #16]
 800633c:	4605      	mov	r5, r0
 800633e:	460c      	mov	r4, r1
 8006340:	b913      	cbnz	r3, 8006348 <_fflush_r+0x10>
 8006342:	2500      	movs	r5, #0
 8006344:	4628      	mov	r0, r5
 8006346:	bd38      	pop	{r3, r4, r5, pc}
 8006348:	b118      	cbz	r0, 8006352 <_fflush_r+0x1a>
 800634a:	6a03      	ldr	r3, [r0, #32]
 800634c:	b90b      	cbnz	r3, 8006352 <_fflush_r+0x1a>
 800634e:	f7ff fb21 	bl	8005994 <__sinit>
 8006352:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8006356:	2b00      	cmp	r3, #0
 8006358:	d0f3      	beq.n	8006342 <_fflush_r+0xa>
 800635a:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800635c:	07d0      	lsls	r0, r2, #31
 800635e:	d404      	bmi.n	800636a <_fflush_r+0x32>
 8006360:	0599      	lsls	r1, r3, #22
 8006362:	d402      	bmi.n	800636a <_fflush_r+0x32>
 8006364:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8006366:	f7ff fbec 	bl	8005b42 <__retarget_lock_acquire_recursive>
 800636a:	4628      	mov	r0, r5
 800636c:	4621      	mov	r1, r4
 800636e:	f7ff ff5f 	bl	8006230 <__sflush_r>
 8006372:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8006374:	4605      	mov	r5, r0
 8006376:	07da      	lsls	r2, r3, #31
 8006378:	d4e4      	bmi.n	8006344 <_fflush_r+0xc>
 800637a:	89a3      	ldrh	r3, [r4, #12]
 800637c:	059b      	lsls	r3, r3, #22
 800637e:	d4e1      	bmi.n	8006344 <_fflush_r+0xc>
 8006380:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8006382:	f7ff fbdf 	bl	8005b44 <__retarget_lock_release_recursive>
 8006386:	e7dd      	b.n	8006344 <_fflush_r+0xc>

08006388 <__malloc_lock>:
 8006388:	4801      	ldr	r0, [pc, #4]	; (8006390 <__malloc_lock+0x8>)
 800638a:	f7ff bbda 	b.w	8005b42 <__retarget_lock_acquire_recursive>
 800638e:	bf00      	nop
 8006390:	20001254 	.word	0x20001254

08006394 <__malloc_unlock>:
 8006394:	4801      	ldr	r0, [pc, #4]	; (800639c <__malloc_unlock+0x8>)
 8006396:	f7ff bbd5 	b.w	8005b44 <__retarget_lock_release_recursive>
 800639a:	bf00      	nop
 800639c:	20001254 	.word	0x20001254

080063a0 <__sread>:
 80063a0:	b510      	push	{r4, lr}
 80063a2:	460c      	mov	r4, r1
 80063a4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80063a8:	f000 f978 	bl	800669c <_read_r>
 80063ac:	2800      	cmp	r0, #0
 80063ae:	bfab      	itete	ge
 80063b0:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 80063b2:	89a3      	ldrhlt	r3, [r4, #12]
 80063b4:	181b      	addge	r3, r3, r0
 80063b6:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 80063ba:	bfac      	ite	ge
 80063bc:	6563      	strge	r3, [r4, #84]	; 0x54
 80063be:	81a3      	strhlt	r3, [r4, #12]
 80063c0:	bd10      	pop	{r4, pc}

080063c2 <__swrite>:
 80063c2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80063c6:	461f      	mov	r7, r3
 80063c8:	898b      	ldrh	r3, [r1, #12]
 80063ca:	4605      	mov	r5, r0
 80063cc:	460c      	mov	r4, r1
 80063ce:	05db      	lsls	r3, r3, #23
 80063d0:	4616      	mov	r6, r2
 80063d2:	d505      	bpl.n	80063e0 <__swrite+0x1e>
 80063d4:	2302      	movs	r3, #2
 80063d6:	2200      	movs	r2, #0
 80063d8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80063dc:	f000 f94c 	bl	8006678 <_lseek_r>
 80063e0:	89a3      	ldrh	r3, [r4, #12]
 80063e2:	4632      	mov	r2, r6
 80063e4:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80063e8:	4628      	mov	r0, r5
 80063ea:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80063ee:	81a3      	strh	r3, [r4, #12]
 80063f0:	463b      	mov	r3, r7
 80063f2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80063f6:	f000 b973 	b.w	80066e0 <_write_r>

080063fa <__sseek>:
 80063fa:	b510      	push	{r4, lr}
 80063fc:	460c      	mov	r4, r1
 80063fe:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8006402:	f000 f939 	bl	8006678 <_lseek_r>
 8006406:	1c43      	adds	r3, r0, #1
 8006408:	89a3      	ldrh	r3, [r4, #12]
 800640a:	bf15      	itete	ne
 800640c:	6560      	strne	r0, [r4, #84]	; 0x54
 800640e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8006412:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8006416:	81a3      	strheq	r3, [r4, #12]
 8006418:	bf18      	it	ne
 800641a:	81a3      	strhne	r3, [r4, #12]
 800641c:	bd10      	pop	{r4, pc}

0800641e <__sclose>:
 800641e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8006422:	f000 b8f7 	b.w	8006614 <_close_r>

08006426 <__swbuf_r>:
 8006426:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006428:	460e      	mov	r6, r1
 800642a:	4614      	mov	r4, r2
 800642c:	4605      	mov	r5, r0
 800642e:	b118      	cbz	r0, 8006438 <__swbuf_r+0x12>
 8006430:	6a03      	ldr	r3, [r0, #32]
 8006432:	b90b      	cbnz	r3, 8006438 <__swbuf_r+0x12>
 8006434:	f7ff faae 	bl	8005994 <__sinit>
 8006438:	69a3      	ldr	r3, [r4, #24]
 800643a:	60a3      	str	r3, [r4, #8]
 800643c:	89a3      	ldrh	r3, [r4, #12]
 800643e:	071a      	lsls	r2, r3, #28
 8006440:	d525      	bpl.n	800648e <__swbuf_r+0x68>
 8006442:	6923      	ldr	r3, [r4, #16]
 8006444:	b31b      	cbz	r3, 800648e <__swbuf_r+0x68>
 8006446:	6823      	ldr	r3, [r4, #0]
 8006448:	b2f6      	uxtb	r6, r6
 800644a:	6922      	ldr	r2, [r4, #16]
 800644c:	4637      	mov	r7, r6
 800644e:	1a98      	subs	r0, r3, r2
 8006450:	6963      	ldr	r3, [r4, #20]
 8006452:	4283      	cmp	r3, r0
 8006454:	dc04      	bgt.n	8006460 <__swbuf_r+0x3a>
 8006456:	4621      	mov	r1, r4
 8006458:	4628      	mov	r0, r5
 800645a:	f7ff ff6d 	bl	8006338 <_fflush_r>
 800645e:	b9e0      	cbnz	r0, 800649a <__swbuf_r+0x74>
 8006460:	68a3      	ldr	r3, [r4, #8]
 8006462:	3b01      	subs	r3, #1
 8006464:	60a3      	str	r3, [r4, #8]
 8006466:	6823      	ldr	r3, [r4, #0]
 8006468:	1c5a      	adds	r2, r3, #1
 800646a:	6022      	str	r2, [r4, #0]
 800646c:	701e      	strb	r6, [r3, #0]
 800646e:	1c43      	adds	r3, r0, #1
 8006470:	6962      	ldr	r2, [r4, #20]
 8006472:	429a      	cmp	r2, r3
 8006474:	d004      	beq.n	8006480 <__swbuf_r+0x5a>
 8006476:	89a3      	ldrh	r3, [r4, #12]
 8006478:	07db      	lsls	r3, r3, #31
 800647a:	d506      	bpl.n	800648a <__swbuf_r+0x64>
 800647c:	2e0a      	cmp	r6, #10
 800647e:	d104      	bne.n	800648a <__swbuf_r+0x64>
 8006480:	4621      	mov	r1, r4
 8006482:	4628      	mov	r0, r5
 8006484:	f7ff ff58 	bl	8006338 <_fflush_r>
 8006488:	b938      	cbnz	r0, 800649a <__swbuf_r+0x74>
 800648a:	4638      	mov	r0, r7
 800648c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800648e:	4621      	mov	r1, r4
 8006490:	4628      	mov	r0, r5
 8006492:	f000 f805 	bl	80064a0 <__swsetup_r>
 8006496:	2800      	cmp	r0, #0
 8006498:	d0d5      	beq.n	8006446 <__swbuf_r+0x20>
 800649a:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 800649e:	e7f4      	b.n	800648a <__swbuf_r+0x64>

080064a0 <__swsetup_r>:
 80064a0:	b538      	push	{r3, r4, r5, lr}
 80064a2:	4b2a      	ldr	r3, [pc, #168]	; (800654c <__swsetup_r+0xac>)
 80064a4:	4605      	mov	r5, r0
 80064a6:	460c      	mov	r4, r1
 80064a8:	6818      	ldr	r0, [r3, #0]
 80064aa:	b118      	cbz	r0, 80064b4 <__swsetup_r+0x14>
 80064ac:	6a03      	ldr	r3, [r0, #32]
 80064ae:	b90b      	cbnz	r3, 80064b4 <__swsetup_r+0x14>
 80064b0:	f7ff fa70 	bl	8005994 <__sinit>
 80064b4:	89a3      	ldrh	r3, [r4, #12]
 80064b6:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80064ba:	0718      	lsls	r0, r3, #28
 80064bc:	d422      	bmi.n	8006504 <__swsetup_r+0x64>
 80064be:	06d9      	lsls	r1, r3, #27
 80064c0:	d407      	bmi.n	80064d2 <__swsetup_r+0x32>
 80064c2:	2309      	movs	r3, #9
 80064c4:	602b      	str	r3, [r5, #0]
 80064c6:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 80064ca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80064ce:	81a3      	strh	r3, [r4, #12]
 80064d0:	e034      	b.n	800653c <__swsetup_r+0x9c>
 80064d2:	0758      	lsls	r0, r3, #29
 80064d4:	d512      	bpl.n	80064fc <__swsetup_r+0x5c>
 80064d6:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80064d8:	b141      	cbz	r1, 80064ec <__swsetup_r+0x4c>
 80064da:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80064de:	4299      	cmp	r1, r3
 80064e0:	d002      	beq.n	80064e8 <__swsetup_r+0x48>
 80064e2:	4628      	mov	r0, r5
 80064e4:	f000 f91c 	bl	8006720 <_free_r>
 80064e8:	2300      	movs	r3, #0
 80064ea:	6363      	str	r3, [r4, #52]	; 0x34
 80064ec:	89a3      	ldrh	r3, [r4, #12]
 80064ee:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 80064f2:	81a3      	strh	r3, [r4, #12]
 80064f4:	2300      	movs	r3, #0
 80064f6:	6063      	str	r3, [r4, #4]
 80064f8:	6923      	ldr	r3, [r4, #16]
 80064fa:	6023      	str	r3, [r4, #0]
 80064fc:	89a3      	ldrh	r3, [r4, #12]
 80064fe:	f043 0308 	orr.w	r3, r3, #8
 8006502:	81a3      	strh	r3, [r4, #12]
 8006504:	6923      	ldr	r3, [r4, #16]
 8006506:	b94b      	cbnz	r3, 800651c <__swsetup_r+0x7c>
 8006508:	89a3      	ldrh	r3, [r4, #12]
 800650a:	f403 7320 	and.w	r3, r3, #640	; 0x280
 800650e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8006512:	d003      	beq.n	800651c <__swsetup_r+0x7c>
 8006514:	4621      	mov	r1, r4
 8006516:	4628      	mov	r0, r5
 8006518:	f000 f83f 	bl	800659a <__smakebuf_r>
 800651c:	89a0      	ldrh	r0, [r4, #12]
 800651e:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8006522:	f010 0301 	ands.w	r3, r0, #1
 8006526:	d00a      	beq.n	800653e <__swsetup_r+0x9e>
 8006528:	2300      	movs	r3, #0
 800652a:	60a3      	str	r3, [r4, #8]
 800652c:	6963      	ldr	r3, [r4, #20]
 800652e:	425b      	negs	r3, r3
 8006530:	61a3      	str	r3, [r4, #24]
 8006532:	6923      	ldr	r3, [r4, #16]
 8006534:	b943      	cbnz	r3, 8006548 <__swsetup_r+0xa8>
 8006536:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 800653a:	d1c4      	bne.n	80064c6 <__swsetup_r+0x26>
 800653c:	bd38      	pop	{r3, r4, r5, pc}
 800653e:	0781      	lsls	r1, r0, #30
 8006540:	bf58      	it	pl
 8006542:	6963      	ldrpl	r3, [r4, #20]
 8006544:	60a3      	str	r3, [r4, #8]
 8006546:	e7f4      	b.n	8006532 <__swsetup_r+0x92>
 8006548:	2000      	movs	r0, #0
 800654a:	e7f7      	b.n	800653c <__swsetup_r+0x9c>
 800654c:	2000006c 	.word	0x2000006c

08006550 <__swhatbuf_r>:
 8006550:	b570      	push	{r4, r5, r6, lr}
 8006552:	460c      	mov	r4, r1
 8006554:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8006558:	b096      	sub	sp, #88	; 0x58
 800655a:	4615      	mov	r5, r2
 800655c:	2900      	cmp	r1, #0
 800655e:	461e      	mov	r6, r3
 8006560:	da0c      	bge.n	800657c <__swhatbuf_r+0x2c>
 8006562:	89a3      	ldrh	r3, [r4, #12]
 8006564:	2100      	movs	r1, #0
 8006566:	f013 0f80 	tst.w	r3, #128	; 0x80
 800656a:	bf0c      	ite	eq
 800656c:	f44f 6380 	moveq.w	r3, #1024	; 0x400
 8006570:	2340      	movne	r3, #64	; 0x40
 8006572:	2000      	movs	r0, #0
 8006574:	6031      	str	r1, [r6, #0]
 8006576:	602b      	str	r3, [r5, #0]
 8006578:	b016      	add	sp, #88	; 0x58
 800657a:	bd70      	pop	{r4, r5, r6, pc}
 800657c:	466a      	mov	r2, sp
 800657e:	f000 f859 	bl	8006634 <_fstat_r>
 8006582:	2800      	cmp	r0, #0
 8006584:	dbed      	blt.n	8006562 <__swhatbuf_r+0x12>
 8006586:	9901      	ldr	r1, [sp, #4]
 8006588:	f401 4170 	and.w	r1, r1, #61440	; 0xf000
 800658c:	f5a1 5300 	sub.w	r3, r1, #8192	; 0x2000
 8006590:	4259      	negs	r1, r3
 8006592:	4159      	adcs	r1, r3
 8006594:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006598:	e7eb      	b.n	8006572 <__swhatbuf_r+0x22>

0800659a <__smakebuf_r>:
 800659a:	898b      	ldrh	r3, [r1, #12]
 800659c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800659e:	079d      	lsls	r5, r3, #30
 80065a0:	4606      	mov	r6, r0
 80065a2:	460c      	mov	r4, r1
 80065a4:	d507      	bpl.n	80065b6 <__smakebuf_r+0x1c>
 80065a6:	f104 0347 	add.w	r3, r4, #71	; 0x47
 80065aa:	6023      	str	r3, [r4, #0]
 80065ac:	6123      	str	r3, [r4, #16]
 80065ae:	2301      	movs	r3, #1
 80065b0:	6163      	str	r3, [r4, #20]
 80065b2:	b002      	add	sp, #8
 80065b4:	bd70      	pop	{r4, r5, r6, pc}
 80065b6:	ab01      	add	r3, sp, #4
 80065b8:	466a      	mov	r2, sp
 80065ba:	f7ff ffc9 	bl	8006550 <__swhatbuf_r>
 80065be:	9900      	ldr	r1, [sp, #0]
 80065c0:	4605      	mov	r5, r0
 80065c2:	4630      	mov	r0, r6
 80065c4:	f7ff fc22 	bl	8005e0c <_malloc_r>
 80065c8:	b948      	cbnz	r0, 80065de <__smakebuf_r+0x44>
 80065ca:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80065ce:	059a      	lsls	r2, r3, #22
 80065d0:	d4ef      	bmi.n	80065b2 <__smakebuf_r+0x18>
 80065d2:	f023 0303 	bic.w	r3, r3, #3
 80065d6:	f043 0302 	orr.w	r3, r3, #2
 80065da:	81a3      	strh	r3, [r4, #12]
 80065dc:	e7e3      	b.n	80065a6 <__smakebuf_r+0xc>
 80065de:	89a3      	ldrh	r3, [r4, #12]
 80065e0:	6020      	str	r0, [r4, #0]
 80065e2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80065e6:	6120      	str	r0, [r4, #16]
 80065e8:	81a3      	strh	r3, [r4, #12]
 80065ea:	9b00      	ldr	r3, [sp, #0]
 80065ec:	6163      	str	r3, [r4, #20]
 80065ee:	9b01      	ldr	r3, [sp, #4]
 80065f0:	b15b      	cbz	r3, 800660a <__smakebuf_r+0x70>
 80065f2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80065f6:	4630      	mov	r0, r6
 80065f8:	f000 f82e 	bl	8006658 <_isatty_r>
 80065fc:	b128      	cbz	r0, 800660a <__smakebuf_r+0x70>
 80065fe:	89a3      	ldrh	r3, [r4, #12]
 8006600:	f023 0303 	bic.w	r3, r3, #3
 8006604:	f043 0301 	orr.w	r3, r3, #1
 8006608:	81a3      	strh	r3, [r4, #12]
 800660a:	89a3      	ldrh	r3, [r4, #12]
 800660c:	431d      	orrs	r5, r3
 800660e:	81a5      	strh	r5, [r4, #12]
 8006610:	e7cf      	b.n	80065b2 <__smakebuf_r+0x18>
	...

08006614 <_close_r>:
 8006614:	b538      	push	{r3, r4, r5, lr}
 8006616:	2300      	movs	r3, #0
 8006618:	4d05      	ldr	r5, [pc, #20]	; (8006630 <_close_r+0x1c>)
 800661a:	4604      	mov	r4, r0
 800661c:	4608      	mov	r0, r1
 800661e:	602b      	str	r3, [r5, #0]
 8006620:	f000 f9a2 	bl	8006968 <_close>
 8006624:	1c43      	adds	r3, r0, #1
 8006626:	d102      	bne.n	800662e <_close_r+0x1a>
 8006628:	682b      	ldr	r3, [r5, #0]
 800662a:	b103      	cbz	r3, 800662e <_close_r+0x1a>
 800662c:	6023      	str	r3, [r4, #0]
 800662e:	bd38      	pop	{r3, r4, r5, pc}
 8006630:	20001260 	.word	0x20001260

08006634 <_fstat_r>:
 8006634:	b538      	push	{r3, r4, r5, lr}
 8006636:	2300      	movs	r3, #0
 8006638:	4d06      	ldr	r5, [pc, #24]	; (8006654 <_fstat_r+0x20>)
 800663a:	4604      	mov	r4, r0
 800663c:	4608      	mov	r0, r1
 800663e:	4611      	mov	r1, r2
 8006640:	602b      	str	r3, [r5, #0]
 8006642:	f000 f9d8 	bl	80069f6 <_fstat>
 8006646:	1c43      	adds	r3, r0, #1
 8006648:	d102      	bne.n	8006650 <_fstat_r+0x1c>
 800664a:	682b      	ldr	r3, [r5, #0]
 800664c:	b103      	cbz	r3, 8006650 <_fstat_r+0x1c>
 800664e:	6023      	str	r3, [r4, #0]
 8006650:	bd38      	pop	{r3, r4, r5, pc}
 8006652:	bf00      	nop
 8006654:	20001260 	.word	0x20001260

08006658 <_isatty_r>:
 8006658:	b538      	push	{r3, r4, r5, lr}
 800665a:	2300      	movs	r3, #0
 800665c:	4d05      	ldr	r5, [pc, #20]	; (8006674 <_isatty_r+0x1c>)
 800665e:	4604      	mov	r4, r0
 8006660:	4608      	mov	r0, r1
 8006662:	602b      	str	r3, [r5, #0]
 8006664:	f000 fb2e 	bl	8006cc4 <_isatty>
 8006668:	1c43      	adds	r3, r0, #1
 800666a:	d102      	bne.n	8006672 <_isatty_r+0x1a>
 800666c:	682b      	ldr	r3, [r5, #0]
 800666e:	b103      	cbz	r3, 8006672 <_isatty_r+0x1a>
 8006670:	6023      	str	r3, [r4, #0]
 8006672:	bd38      	pop	{r3, r4, r5, pc}
 8006674:	20001260 	.word	0x20001260

08006678 <_lseek_r>:
 8006678:	b538      	push	{r3, r4, r5, lr}
 800667a:	4604      	mov	r4, r0
 800667c:	4d06      	ldr	r5, [pc, #24]	; (8006698 <_lseek_r+0x20>)
 800667e:	4608      	mov	r0, r1
 8006680:	4611      	mov	r1, r2
 8006682:	2200      	movs	r2, #0
 8006684:	602a      	str	r2, [r5, #0]
 8006686:	461a      	mov	r2, r3
 8006688:	f000 f92b 	bl	80068e2 <_lseek>
 800668c:	1c43      	adds	r3, r0, #1
 800668e:	d102      	bne.n	8006696 <_lseek_r+0x1e>
 8006690:	682b      	ldr	r3, [r5, #0]
 8006692:	b103      	cbz	r3, 8006696 <_lseek_r+0x1e>
 8006694:	6023      	str	r3, [r4, #0]
 8006696:	bd38      	pop	{r3, r4, r5, pc}
 8006698:	20001260 	.word	0x20001260

0800669c <_read_r>:
 800669c:	b538      	push	{r3, r4, r5, lr}
 800669e:	4604      	mov	r4, r0
 80066a0:	4d06      	ldr	r5, [pc, #24]	; (80066bc <_read_r+0x20>)
 80066a2:	4608      	mov	r0, r1
 80066a4:	4611      	mov	r1, r2
 80066a6:	2200      	movs	r2, #0
 80066a8:	602a      	str	r2, [r5, #0]
 80066aa:	461a      	mov	r2, r3
 80066ac:	f000 f8c1 	bl	8006832 <_read>
 80066b0:	1c43      	adds	r3, r0, #1
 80066b2:	d102      	bne.n	80066ba <_read_r+0x1e>
 80066b4:	682b      	ldr	r3, [r5, #0]
 80066b6:	b103      	cbz	r3, 80066ba <_read_r+0x1e>
 80066b8:	6023      	str	r3, [r4, #0]
 80066ba:	bd38      	pop	{r3, r4, r5, pc}
 80066bc:	20001260 	.word	0x20001260

080066c0 <_sbrk_r>:
 80066c0:	b538      	push	{r3, r4, r5, lr}
 80066c2:	2300      	movs	r3, #0
 80066c4:	4d05      	ldr	r5, [pc, #20]	; (80066dc <_sbrk_r+0x1c>)
 80066c6:	4604      	mov	r4, r0
 80066c8:	4608      	mov	r0, r1
 80066ca:	602b      	str	r3, [r5, #0]
 80066cc:	f7fa fb12 	bl	8000cf4 <_sbrk>
 80066d0:	1c43      	adds	r3, r0, #1
 80066d2:	d102      	bne.n	80066da <_sbrk_r+0x1a>
 80066d4:	682b      	ldr	r3, [r5, #0]
 80066d6:	b103      	cbz	r3, 80066da <_sbrk_r+0x1a>
 80066d8:	6023      	str	r3, [r4, #0]
 80066da:	bd38      	pop	{r3, r4, r5, pc}
 80066dc:	20001260 	.word	0x20001260

080066e0 <_write_r>:
 80066e0:	b538      	push	{r3, r4, r5, lr}
 80066e2:	4604      	mov	r4, r0
 80066e4:	4d06      	ldr	r5, [pc, #24]	; (8006700 <_write_r+0x20>)
 80066e6:	4608      	mov	r0, r1
 80066e8:	4611      	mov	r1, r2
 80066ea:	2200      	movs	r2, #0
 80066ec:	602a      	str	r2, [r5, #0]
 80066ee:	461a      	mov	r2, r3
 80066f0:	f000 f909 	bl	8006906 <_write>
 80066f4:	1c43      	adds	r3, r0, #1
 80066f6:	d102      	bne.n	80066fe <_write_r+0x1e>
 80066f8:	682b      	ldr	r3, [r5, #0]
 80066fa:	b103      	cbz	r3, 80066fe <_write_r+0x1e>
 80066fc:	6023      	str	r3, [r4, #0]
 80066fe:	bd38      	pop	{r3, r4, r5, pc}
 8006700:	20001260 	.word	0x20001260

08006704 <memchr>:
 8006704:	b2c9      	uxtb	r1, r1
 8006706:	4402      	add	r2, r0
 8006708:	b510      	push	{r4, lr}
 800670a:	4290      	cmp	r0, r2
 800670c:	4603      	mov	r3, r0
 800670e:	d101      	bne.n	8006714 <memchr+0x10>
 8006710:	2300      	movs	r3, #0
 8006712:	e003      	b.n	800671c <memchr+0x18>
 8006714:	781c      	ldrb	r4, [r3, #0]
 8006716:	3001      	adds	r0, #1
 8006718:	428c      	cmp	r4, r1
 800671a:	d1f6      	bne.n	800670a <memchr+0x6>
 800671c:	4618      	mov	r0, r3
 800671e:	bd10      	pop	{r4, pc}

08006720 <_free_r>:
 8006720:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8006722:	2900      	cmp	r1, #0
 8006724:	d043      	beq.n	80067ae <_free_r+0x8e>
 8006726:	f851 3c04 	ldr.w	r3, [r1, #-4]
 800672a:	1f0c      	subs	r4, r1, #4
 800672c:	9001      	str	r0, [sp, #4]
 800672e:	2b00      	cmp	r3, #0
 8006730:	bfb8      	it	lt
 8006732:	18e4      	addlt	r4, r4, r3
 8006734:	f7ff fe28 	bl	8006388 <__malloc_lock>
 8006738:	4a1e      	ldr	r2, [pc, #120]	; (80067b4 <_free_r+0x94>)
 800673a:	9801      	ldr	r0, [sp, #4]
 800673c:	6813      	ldr	r3, [r2, #0]
 800673e:	b933      	cbnz	r3, 800674e <_free_r+0x2e>
 8006740:	6063      	str	r3, [r4, #4]
 8006742:	6014      	str	r4, [r2, #0]
 8006744:	b003      	add	sp, #12
 8006746:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 800674a:	f7ff be23 	b.w	8006394 <__malloc_unlock>
 800674e:	42a3      	cmp	r3, r4
 8006750:	d908      	bls.n	8006764 <_free_r+0x44>
 8006752:	6825      	ldr	r5, [r4, #0]
 8006754:	1961      	adds	r1, r4, r5
 8006756:	428b      	cmp	r3, r1
 8006758:	bf01      	itttt	eq
 800675a:	6819      	ldreq	r1, [r3, #0]
 800675c:	685b      	ldreq	r3, [r3, #4]
 800675e:	1949      	addeq	r1, r1, r5
 8006760:	6021      	streq	r1, [r4, #0]
 8006762:	e7ed      	b.n	8006740 <_free_r+0x20>
 8006764:	461a      	mov	r2, r3
 8006766:	685b      	ldr	r3, [r3, #4]
 8006768:	b10b      	cbz	r3, 800676e <_free_r+0x4e>
 800676a:	42a3      	cmp	r3, r4
 800676c:	d9fa      	bls.n	8006764 <_free_r+0x44>
 800676e:	6811      	ldr	r1, [r2, #0]
 8006770:	1855      	adds	r5, r2, r1
 8006772:	42a5      	cmp	r5, r4
 8006774:	d10b      	bne.n	800678e <_free_r+0x6e>
 8006776:	6824      	ldr	r4, [r4, #0]
 8006778:	4421      	add	r1, r4
 800677a:	1854      	adds	r4, r2, r1
 800677c:	6011      	str	r1, [r2, #0]
 800677e:	42a3      	cmp	r3, r4
 8006780:	d1e0      	bne.n	8006744 <_free_r+0x24>
 8006782:	681c      	ldr	r4, [r3, #0]
 8006784:	685b      	ldr	r3, [r3, #4]
 8006786:	440c      	add	r4, r1
 8006788:	6053      	str	r3, [r2, #4]
 800678a:	6014      	str	r4, [r2, #0]
 800678c:	e7da      	b.n	8006744 <_free_r+0x24>
 800678e:	d902      	bls.n	8006796 <_free_r+0x76>
 8006790:	230c      	movs	r3, #12
 8006792:	6003      	str	r3, [r0, #0]
 8006794:	e7d6      	b.n	8006744 <_free_r+0x24>
 8006796:	6825      	ldr	r5, [r4, #0]
 8006798:	1961      	adds	r1, r4, r5
 800679a:	428b      	cmp	r3, r1
 800679c:	bf02      	ittt	eq
 800679e:	6819      	ldreq	r1, [r3, #0]
 80067a0:	685b      	ldreq	r3, [r3, #4]
 80067a2:	1949      	addeq	r1, r1, r5
 80067a4:	6063      	str	r3, [r4, #4]
 80067a6:	bf08      	it	eq
 80067a8:	6021      	streq	r1, [r4, #0]
 80067aa:	6054      	str	r4, [r2, #4]
 80067ac:	e7ca      	b.n	8006744 <_free_r+0x24>
 80067ae:	b003      	add	sp, #12
 80067b0:	bd30      	pop	{r4, r5, pc}
 80067b2:	bf00      	nop
 80067b4:	20001258 	.word	0x20001258

080067b8 <findslot>:
 80067b8:	4b0a      	ldr	r3, [pc, #40]	; (80067e4 <findslot+0x2c>)
 80067ba:	b510      	push	{r4, lr}
 80067bc:	4604      	mov	r4, r0
 80067be:	6818      	ldr	r0, [r3, #0]
 80067c0:	b118      	cbz	r0, 80067ca <findslot+0x12>
 80067c2:	6a03      	ldr	r3, [r0, #32]
 80067c4:	b90b      	cbnz	r3, 80067ca <findslot+0x12>
 80067c6:	f7ff f8e5 	bl	8005994 <__sinit>
 80067ca:	2c13      	cmp	r4, #19
 80067cc:	d807      	bhi.n	80067de <findslot+0x26>
 80067ce:	4806      	ldr	r0, [pc, #24]	; (80067e8 <findslot+0x30>)
 80067d0:	f850 2034 	ldr.w	r2, [r0, r4, lsl #3]
 80067d4:	3201      	adds	r2, #1
 80067d6:	d002      	beq.n	80067de <findslot+0x26>
 80067d8:	eb00 00c4 	add.w	r0, r0, r4, lsl #3
 80067dc:	bd10      	pop	{r4, pc}
 80067de:	2000      	movs	r0, #0
 80067e0:	e7fc      	b.n	80067dc <findslot+0x24>
 80067e2:	bf00      	nop
 80067e4:	2000006c 	.word	0x2000006c
 80067e8:	20001270 	.word	0x20001270

080067ec <error>:
 80067ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80067ee:	4604      	mov	r4, r0
 80067f0:	2613      	movs	r6, #19
 80067f2:	f7ff f97b 	bl	8005aec <__errno>
 80067f6:	2700      	movs	r7, #0
 80067f8:	4605      	mov	r5, r0
 80067fa:	4630      	mov	r0, r6
 80067fc:	4639      	mov	r1, r7
 80067fe:	beab      	bkpt	0x00ab
 8006800:	4606      	mov	r6, r0
 8006802:	4620      	mov	r0, r4
 8006804:	602e      	str	r6, [r5, #0]
 8006806:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08006808 <checkerror>:
 8006808:	1c43      	adds	r3, r0, #1
 800680a:	d101      	bne.n	8006810 <checkerror+0x8>
 800680c:	f7ff bfee 	b.w	80067ec <error>
 8006810:	4770      	bx	lr

08006812 <_swiread>:
 8006812:	b530      	push	{r4, r5, lr}
 8006814:	b085      	sub	sp, #20
 8006816:	2406      	movs	r4, #6
 8006818:	ad01      	add	r5, sp, #4
 800681a:	9203      	str	r2, [sp, #12]
 800681c:	e9cd 0101 	strd	r0, r1, [sp, #4]
 8006820:	4620      	mov	r0, r4
 8006822:	4629      	mov	r1, r5
 8006824:	beab      	bkpt	0x00ab
 8006826:	4604      	mov	r4, r0
 8006828:	4620      	mov	r0, r4
 800682a:	f7ff ffed 	bl	8006808 <checkerror>
 800682e:	b005      	add	sp, #20
 8006830:	bd30      	pop	{r4, r5, pc}

08006832 <_read>:
 8006832:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8006834:	4615      	mov	r5, r2
 8006836:	9101      	str	r1, [sp, #4]
 8006838:	f7ff ffbe 	bl	80067b8 <findslot>
 800683c:	4604      	mov	r4, r0
 800683e:	9901      	ldr	r1, [sp, #4]
 8006840:	b938      	cbnz	r0, 8006852 <_read+0x20>
 8006842:	f7ff f953 	bl	8005aec <__errno>
 8006846:	2309      	movs	r3, #9
 8006848:	6003      	str	r3, [r0, #0]
 800684a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800684e:	b003      	add	sp, #12
 8006850:	bd30      	pop	{r4, r5, pc}
 8006852:	462a      	mov	r2, r5
 8006854:	6800      	ldr	r0, [r0, #0]
 8006856:	f7ff ffdc 	bl	8006812 <_swiread>
 800685a:	1c43      	adds	r3, r0, #1
 800685c:	d0f7      	beq.n	800684e <_read+0x1c>
 800685e:	1a2a      	subs	r2, r5, r0
 8006860:	6863      	ldr	r3, [r4, #4]
 8006862:	4413      	add	r3, r2
 8006864:	4610      	mov	r0, r2
 8006866:	6063      	str	r3, [r4, #4]
 8006868:	e7f1      	b.n	800684e <_read+0x1c>

0800686a <_swilseek>:
 800686a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800686c:	460c      	mov	r4, r1
 800686e:	4616      	mov	r6, r2
 8006870:	f7ff ffa2 	bl	80067b8 <findslot>
 8006874:	4605      	mov	r5, r0
 8006876:	b940      	cbnz	r0, 800688a <_swilseek+0x20>
 8006878:	f7ff f938 	bl	8005aec <__errno>
 800687c:	2309      	movs	r3, #9
 800687e:	6003      	str	r3, [r0, #0]
 8006880:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8006884:	4620      	mov	r0, r4
 8006886:	b003      	add	sp, #12
 8006888:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800688a:	2e02      	cmp	r6, #2
 800688c:	d903      	bls.n	8006896 <_swilseek+0x2c>
 800688e:	f7ff f92d 	bl	8005aec <__errno>
 8006892:	2316      	movs	r3, #22
 8006894:	e7f3      	b.n	800687e <_swilseek+0x14>
 8006896:	2e01      	cmp	r6, #1
 8006898:	d112      	bne.n	80068c0 <_swilseek+0x56>
 800689a:	6843      	ldr	r3, [r0, #4]
 800689c:	18e4      	adds	r4, r4, r3
 800689e:	d4f6      	bmi.n	800688e <_swilseek+0x24>
 80068a0:	682b      	ldr	r3, [r5, #0]
 80068a2:	260a      	movs	r6, #10
 80068a4:	466f      	mov	r7, sp
 80068a6:	e9cd 3400 	strd	r3, r4, [sp]
 80068aa:	4630      	mov	r0, r6
 80068ac:	4639      	mov	r1, r7
 80068ae:	beab      	bkpt	0x00ab
 80068b0:	4606      	mov	r6, r0
 80068b2:	4630      	mov	r0, r6
 80068b4:	f7ff ffa8 	bl	8006808 <checkerror>
 80068b8:	2800      	cmp	r0, #0
 80068ba:	dbe1      	blt.n	8006880 <_swilseek+0x16>
 80068bc:	606c      	str	r4, [r5, #4]
 80068be:	e7e1      	b.n	8006884 <_swilseek+0x1a>
 80068c0:	2e02      	cmp	r6, #2
 80068c2:	6803      	ldr	r3, [r0, #0]
 80068c4:	d1ec      	bne.n	80068a0 <_swilseek+0x36>
 80068c6:	260c      	movs	r6, #12
 80068c8:	466f      	mov	r7, sp
 80068ca:	9300      	str	r3, [sp, #0]
 80068cc:	4630      	mov	r0, r6
 80068ce:	4639      	mov	r1, r7
 80068d0:	beab      	bkpt	0x00ab
 80068d2:	4606      	mov	r6, r0
 80068d4:	4630      	mov	r0, r6
 80068d6:	f7ff ff97 	bl	8006808 <checkerror>
 80068da:	1c43      	adds	r3, r0, #1
 80068dc:	d0d0      	beq.n	8006880 <_swilseek+0x16>
 80068de:	4404      	add	r4, r0
 80068e0:	e7de      	b.n	80068a0 <_swilseek+0x36>

080068e2 <_lseek>:
 80068e2:	f7ff bfc2 	b.w	800686a <_swilseek>

080068e6 <_swiwrite>:
 80068e6:	b530      	push	{r4, r5, lr}
 80068e8:	b085      	sub	sp, #20
 80068ea:	2405      	movs	r4, #5
 80068ec:	ad01      	add	r5, sp, #4
 80068ee:	9203      	str	r2, [sp, #12]
 80068f0:	e9cd 0101 	strd	r0, r1, [sp, #4]
 80068f4:	4620      	mov	r0, r4
 80068f6:	4629      	mov	r1, r5
 80068f8:	beab      	bkpt	0x00ab
 80068fa:	4604      	mov	r4, r0
 80068fc:	4620      	mov	r0, r4
 80068fe:	f7ff ff83 	bl	8006808 <checkerror>
 8006902:	b005      	add	sp, #20
 8006904:	bd30      	pop	{r4, r5, pc}

08006906 <_write>:
 8006906:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8006908:	4615      	mov	r5, r2
 800690a:	9101      	str	r1, [sp, #4]
 800690c:	f7ff ff54 	bl	80067b8 <findslot>
 8006910:	4604      	mov	r4, r0
 8006912:	9901      	ldr	r1, [sp, #4]
 8006914:	b930      	cbnz	r0, 8006924 <_write+0x1e>
 8006916:	f7ff f8e9 	bl	8005aec <__errno>
 800691a:	2309      	movs	r3, #9
 800691c:	6003      	str	r3, [r0, #0]
 800691e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006922:	e012      	b.n	800694a <_write+0x44>
 8006924:	462a      	mov	r2, r5
 8006926:	6800      	ldr	r0, [r0, #0]
 8006928:	f7ff ffdd 	bl	80068e6 <_swiwrite>
 800692c:	2800      	cmp	r0, #0
 800692e:	dbf6      	blt.n	800691e <_write+0x18>
 8006930:	6862      	ldr	r2, [r4, #4]
 8006932:	1a2b      	subs	r3, r5, r0
 8006934:	42a8      	cmp	r0, r5
 8006936:	441a      	add	r2, r3
 8006938:	6062      	str	r2, [r4, #4]
 800693a:	d105      	bne.n	8006948 <_write+0x42>
 800693c:	2000      	movs	r0, #0
 800693e:	b003      	add	sp, #12
 8006940:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8006944:	f7ff bf52 	b.w	80067ec <error>
 8006948:	4618      	mov	r0, r3
 800694a:	b003      	add	sp, #12
 800694c:	bd30      	pop	{r4, r5, pc}

0800694e <_swiclose>:
 800694e:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8006950:	2402      	movs	r4, #2
 8006952:	ad01      	add	r5, sp, #4
 8006954:	9001      	str	r0, [sp, #4]
 8006956:	4620      	mov	r0, r4
 8006958:	4629      	mov	r1, r5
 800695a:	beab      	bkpt	0x00ab
 800695c:	4604      	mov	r4, r0
 800695e:	4620      	mov	r0, r4
 8006960:	f7ff ff52 	bl	8006808 <checkerror>
 8006964:	b003      	add	sp, #12
 8006966:	bd30      	pop	{r4, r5, pc}

08006968 <_close>:
 8006968:	b538      	push	{r3, r4, r5, lr}
 800696a:	4605      	mov	r5, r0
 800696c:	f7ff ff24 	bl	80067b8 <findslot>
 8006970:	4604      	mov	r4, r0
 8006972:	b930      	cbnz	r0, 8006982 <_close+0x1a>
 8006974:	f7ff f8ba 	bl	8005aec <__errno>
 8006978:	2309      	movs	r3, #9
 800697a:	6003      	str	r3, [r0, #0]
 800697c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006980:	bd38      	pop	{r3, r4, r5, pc}
 8006982:	3d01      	subs	r5, #1
 8006984:	2d01      	cmp	r5, #1
 8006986:	d809      	bhi.n	800699c <_close+0x34>
 8006988:	4b09      	ldr	r3, [pc, #36]	; (80069b0 <_close+0x48>)
 800698a:	689a      	ldr	r2, [r3, #8]
 800698c:	691b      	ldr	r3, [r3, #16]
 800698e:	429a      	cmp	r2, r3
 8006990:	d104      	bne.n	800699c <_close+0x34>
 8006992:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8006996:	6003      	str	r3, [r0, #0]
 8006998:	2000      	movs	r0, #0
 800699a:	e7f1      	b.n	8006980 <_close+0x18>
 800699c:	6820      	ldr	r0, [r4, #0]
 800699e:	f7ff ffd6 	bl	800694e <_swiclose>
 80069a2:	2800      	cmp	r0, #0
 80069a4:	d1ec      	bne.n	8006980 <_close+0x18>
 80069a6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80069aa:	6023      	str	r3, [r4, #0]
 80069ac:	e7e8      	b.n	8006980 <_close+0x18>
 80069ae:	bf00      	nop
 80069b0:	20001270 	.word	0x20001270

080069b4 <_swistat>:
 80069b4:	b570      	push	{r4, r5, r6, lr}
 80069b6:	460c      	mov	r4, r1
 80069b8:	f7ff fefe 	bl	80067b8 <findslot>
 80069bc:	4605      	mov	r5, r0
 80069be:	b930      	cbnz	r0, 80069ce <_swistat+0x1a>
 80069c0:	f7ff f894 	bl	8005aec <__errno>
 80069c4:	2309      	movs	r3, #9
 80069c6:	6003      	str	r3, [r0, #0]
 80069c8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80069cc:	bd70      	pop	{r4, r5, r6, pc}
 80069ce:	6863      	ldr	r3, [r4, #4]
 80069d0:	260c      	movs	r6, #12
 80069d2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80069d6:	6063      	str	r3, [r4, #4]
 80069d8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80069dc:	64a3      	str	r3, [r4, #72]	; 0x48
 80069de:	4630      	mov	r0, r6
 80069e0:	4629      	mov	r1, r5
 80069e2:	beab      	bkpt	0x00ab
 80069e4:	4605      	mov	r5, r0
 80069e6:	4628      	mov	r0, r5
 80069e8:	f7ff ff0e 	bl	8006808 <checkerror>
 80069ec:	1c43      	adds	r3, r0, #1
 80069ee:	bf1c      	itt	ne
 80069f0:	6120      	strne	r0, [r4, #16]
 80069f2:	2000      	movne	r0, #0
 80069f4:	e7ea      	b.n	80069cc <_swistat+0x18>

080069f6 <_fstat>:
 80069f6:	460b      	mov	r3, r1
 80069f8:	2258      	movs	r2, #88	; 0x58
 80069fa:	2100      	movs	r1, #0
 80069fc:	b510      	push	{r4, lr}
 80069fe:	4604      	mov	r4, r0
 8006a00:	4618      	mov	r0, r3
 8006a02:	f7ff f86b 	bl	8005adc <memset>
 8006a06:	4601      	mov	r1, r0
 8006a08:	4620      	mov	r0, r4
 8006a0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8006a0e:	f7ff bfd1 	b.w	80069b4 <_swistat>

08006a12 <_stat>:
 8006a12:	b538      	push	{r3, r4, r5, lr}
 8006a14:	460d      	mov	r5, r1
 8006a16:	4604      	mov	r4, r0
 8006a18:	2258      	movs	r2, #88	; 0x58
 8006a1a:	2100      	movs	r1, #0
 8006a1c:	4628      	mov	r0, r5
 8006a1e:	f7ff f85d 	bl	8005adc <memset>
 8006a22:	4620      	mov	r0, r4
 8006a24:	2100      	movs	r1, #0
 8006a26:	f000 f811 	bl	8006a4c <_swiopen>
 8006a2a:	1c43      	adds	r3, r0, #1
 8006a2c:	4604      	mov	r4, r0
 8006a2e:	d00b      	beq.n	8006a48 <_stat+0x36>
 8006a30:	686b      	ldr	r3, [r5, #4]
 8006a32:	4629      	mov	r1, r5
 8006a34:	f443 4301 	orr.w	r3, r3, #33024	; 0x8100
 8006a38:	606b      	str	r3, [r5, #4]
 8006a3a:	f7ff ffbb 	bl	80069b4 <_swistat>
 8006a3e:	4605      	mov	r5, r0
 8006a40:	4620      	mov	r0, r4
 8006a42:	462c      	mov	r4, r5
 8006a44:	f7ff ff90 	bl	8006968 <_close>
 8006a48:	4620      	mov	r0, r4
 8006a4a:	bd38      	pop	{r3, r4, r5, pc}

08006a4c <_swiopen>:
 8006a4c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006a50:	4607      	mov	r7, r0
 8006a52:	b097      	sub	sp, #92	; 0x5c
 8006a54:	460e      	mov	r6, r1
 8006a56:	2500      	movs	r5, #0
 8006a58:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 8006afc <_swiopen+0xb0>
 8006a5c:	f858 4035 	ldr.w	r4, [r8, r5, lsl #3]
 8006a60:	1c61      	adds	r1, r4, #1
 8006a62:	d036      	beq.n	8006ad2 <_swiopen+0x86>
 8006a64:	3501      	adds	r5, #1
 8006a66:	2d14      	cmp	r5, #20
 8006a68:	d1f8      	bne.n	8006a5c <_swiopen+0x10>
 8006a6a:	f7ff f83f 	bl	8005aec <__errno>
 8006a6e:	2318      	movs	r3, #24
 8006a70:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8006a74:	6003      	str	r3, [r0, #0]
 8006a76:	e03c      	b.n	8006af2 <_swiopen+0xa6>
 8006a78:	f3c6 4400 	ubfx	r4, r6, #16, #1
 8006a7c:	f240 6301 	movw	r3, #1537	; 0x601
 8006a80:	07b2      	lsls	r2, r6, #30
 8006a82:	4638      	mov	r0, r7
 8006a84:	9700      	str	r7, [sp, #0]
 8006a86:	bf48      	it	mi
 8006a88:	f044 0402 	orrmi.w	r4, r4, #2
 8006a8c:	421e      	tst	r6, r3
 8006a8e:	bf18      	it	ne
 8006a90:	f044 0404 	orrne.w	r4, r4, #4
 8006a94:	0733      	lsls	r3, r6, #28
 8006a96:	bf44      	itt	mi
 8006a98:	f024 0404 	bicmi.w	r4, r4, #4
 8006a9c:	f044 0408 	orrmi.w	r4, r4, #8
 8006aa0:	f7f9 fbea 	bl	8000278 <strlen>
 8006aa4:	e9cd 4001 	strd	r4, r0, [sp, #4]
 8006aa8:	2401      	movs	r4, #1
 8006aaa:	4620      	mov	r0, r4
 8006aac:	4649      	mov	r1, r9
 8006aae:	beab      	bkpt	0x00ab
 8006ab0:	4604      	mov	r4, r0
 8006ab2:	2c00      	cmp	r4, #0
 8006ab4:	db08      	blt.n	8006ac8 <_swiopen+0x7c>
 8006ab6:	f848 4035 	str.w	r4, [r8, r5, lsl #3]
 8006aba:	2300      	movs	r3, #0
 8006abc:	eb08 08c5 	add.w	r8, r8, r5, lsl #3
 8006ac0:	462c      	mov	r4, r5
 8006ac2:	f8c8 3004 	str.w	r3, [r8, #4]
 8006ac6:	e014      	b.n	8006af2 <_swiopen+0xa6>
 8006ac8:	4620      	mov	r0, r4
 8006aca:	f7ff fe8f 	bl	80067ec <error>
 8006ace:	4604      	mov	r4, r0
 8006ad0:	e00f      	b.n	8006af2 <_swiopen+0xa6>
 8006ad2:	f406 6320 	and.w	r3, r6, #2560	; 0xa00
 8006ad6:	46e9      	mov	r9, sp
 8006ad8:	f5b3 6f20 	cmp.w	r3, #2560	; 0xa00
 8006adc:	d1cc      	bne.n	8006a78 <_swiopen+0x2c>
 8006ade:	4649      	mov	r1, r9
 8006ae0:	4638      	mov	r0, r7
 8006ae2:	f7ff ff96 	bl	8006a12 <_stat>
 8006ae6:	3001      	adds	r0, #1
 8006ae8:	d0c6      	beq.n	8006a78 <_swiopen+0x2c>
 8006aea:	f7fe ffff 	bl	8005aec <__errno>
 8006aee:	2311      	movs	r3, #17
 8006af0:	6003      	str	r3, [r0, #0]
 8006af2:	4620      	mov	r0, r4
 8006af4:	b017      	add	sp, #92	; 0x5c
 8006af6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8006afa:	bf00      	nop
 8006afc:	20001270 	.word	0x20001270

08006b00 <_get_semihosting_exts>:
 8006b00:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8006b04:	4606      	mov	r6, r0
 8006b06:	4615      	mov	r5, r2
 8006b08:	460f      	mov	r7, r1
 8006b0a:	482a      	ldr	r0, [pc, #168]	; (8006bb4 <_get_semihosting_exts+0xb4>)
 8006b0c:	2100      	movs	r1, #0
 8006b0e:	f7ff ff9d 	bl	8006a4c <_swiopen>
 8006b12:	4604      	mov	r4, r0
 8006b14:	462a      	mov	r2, r5
 8006b16:	2100      	movs	r1, #0
 8006b18:	4630      	mov	r0, r6
 8006b1a:	f7fe ffdf 	bl	8005adc <memset>
 8006b1e:	1c63      	adds	r3, r4, #1
 8006b20:	d016      	beq.n	8006b50 <_get_semihosting_exts+0x50>
 8006b22:	4620      	mov	r0, r4
 8006b24:	f04f 080c 	mov.w	r8, #12
 8006b28:	f7ff fe46 	bl	80067b8 <findslot>
 8006b2c:	4681      	mov	r9, r0
 8006b2e:	4640      	mov	r0, r8
 8006b30:	4649      	mov	r1, r9
 8006b32:	beab      	bkpt	0x00ab
 8006b34:	4680      	mov	r8, r0
 8006b36:	4640      	mov	r0, r8
 8006b38:	f7ff fe66 	bl	8006808 <checkerror>
 8006b3c:	2803      	cmp	r0, #3
 8006b3e:	dd02      	ble.n	8006b46 <_get_semihosting_exts+0x46>
 8006b40:	1ec3      	subs	r3, r0, #3
 8006b42:	42ab      	cmp	r3, r5
 8006b44:	dc08      	bgt.n	8006b58 <_get_semihosting_exts+0x58>
 8006b46:	4620      	mov	r0, r4
 8006b48:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8006b4c:	f7ff ff0c 	bl	8006968 <_close>
 8006b50:	4620      	mov	r0, r4
 8006b52:	b003      	add	sp, #12
 8006b54:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8006b58:	2204      	movs	r2, #4
 8006b5a:	4620      	mov	r0, r4
 8006b5c:	eb0d 0102 	add.w	r1, sp, r2
 8006b60:	f7ff fe67 	bl	8006832 <_read>
 8006b64:	2803      	cmp	r0, #3
 8006b66:	ddee      	ble.n	8006b46 <_get_semihosting_exts+0x46>
 8006b68:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8006b6c:	2b53      	cmp	r3, #83	; 0x53
 8006b6e:	d1ea      	bne.n	8006b46 <_get_semihosting_exts+0x46>
 8006b70:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8006b74:	2b48      	cmp	r3, #72	; 0x48
 8006b76:	d1e6      	bne.n	8006b46 <_get_semihosting_exts+0x46>
 8006b78:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8006b7c:	2b46      	cmp	r3, #70	; 0x46
 8006b7e:	d1e2      	bne.n	8006b46 <_get_semihosting_exts+0x46>
 8006b80:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8006b84:	2b42      	cmp	r3, #66	; 0x42
 8006b86:	d1de      	bne.n	8006b46 <_get_semihosting_exts+0x46>
 8006b88:	2201      	movs	r2, #1
 8006b8a:	4639      	mov	r1, r7
 8006b8c:	4620      	mov	r0, r4
 8006b8e:	f7ff fe6c 	bl	800686a <_swilseek>
 8006b92:	2800      	cmp	r0, #0
 8006b94:	dbd7      	blt.n	8006b46 <_get_semihosting_exts+0x46>
 8006b96:	462a      	mov	r2, r5
 8006b98:	4631      	mov	r1, r6
 8006b9a:	4620      	mov	r0, r4
 8006b9c:	f7ff fe49 	bl	8006832 <_read>
 8006ba0:	4605      	mov	r5, r0
 8006ba2:	4620      	mov	r0, r4
 8006ba4:	f7ff fee0 	bl	8006968 <_close>
 8006ba8:	4628      	mov	r0, r5
 8006baa:	f7ff fe2d 	bl	8006808 <checkerror>
 8006bae:	4604      	mov	r4, r0
 8006bb0:	e7ce      	b.n	8006b50 <_get_semihosting_exts+0x50>
 8006bb2:	bf00      	nop
 8006bb4:	08006f1f 	.word	0x08006f1f

08006bb8 <initialise_semihosting_exts>:
 8006bb8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8006bba:	2100      	movs	r1, #0
 8006bbc:	2201      	movs	r2, #1
 8006bbe:	4d09      	ldr	r5, [pc, #36]	; (8006be4 <initialise_semihosting_exts+0x2c>)
 8006bc0:	a801      	add	r0, sp, #4
 8006bc2:	4c09      	ldr	r4, [pc, #36]	; (8006be8 <initialise_semihosting_exts+0x30>)
 8006bc4:	6029      	str	r1, [r5, #0]
 8006bc6:	6022      	str	r2, [r4, #0]
 8006bc8:	f7ff ff9a 	bl	8006b00 <_get_semihosting_exts>
 8006bcc:	2800      	cmp	r0, #0
 8006bce:	dd07      	ble.n	8006be0 <initialise_semihosting_exts+0x28>
 8006bd0:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8006bd4:	f003 0201 	and.w	r2, r3, #1
 8006bd8:	f003 0302 	and.w	r3, r3, #2
 8006bdc:	602a      	str	r2, [r5, #0]
 8006bde:	6023      	str	r3, [r4, #0]
 8006be0:	b003      	add	sp, #12
 8006be2:	bd30      	pop	{r4, r5, pc}
 8006be4:	20000070 	.word	0x20000070
 8006be8:	20000074 	.word	0x20000074

08006bec <_has_ext_stdout_stderr>:
 8006bec:	b510      	push	{r4, lr}
 8006bee:	4c04      	ldr	r4, [pc, #16]	; (8006c00 <_has_ext_stdout_stderr+0x14>)
 8006bf0:	6823      	ldr	r3, [r4, #0]
 8006bf2:	2b00      	cmp	r3, #0
 8006bf4:	da01      	bge.n	8006bfa <_has_ext_stdout_stderr+0xe>
 8006bf6:	f7ff ffdf 	bl	8006bb8 <initialise_semihosting_exts>
 8006bfa:	6820      	ldr	r0, [r4, #0]
 8006bfc:	bd10      	pop	{r4, pc}
 8006bfe:	bf00      	nop
 8006c00:	20000074 	.word	0x20000074

08006c04 <initialise_monitor_handles>:
 8006c04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006c08:	2303      	movs	r3, #3
 8006c0a:	b085      	sub	sp, #20
 8006c0c:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 8006cbc <initialise_monitor_handles+0xb8>
 8006c10:	2400      	movs	r4, #0
 8006c12:	af01      	add	r7, sp, #4
 8006c14:	2501      	movs	r5, #1
 8006c16:	f8cd 9004 	str.w	r9, [sp, #4]
 8006c1a:	9303      	str	r3, [sp, #12]
 8006c1c:	9402      	str	r4, [sp, #8]
 8006c1e:	4628      	mov	r0, r5
 8006c20:	4639      	mov	r1, r7
 8006c22:	beab      	bkpt	0x00ab
 8006c24:	4605      	mov	r5, r0
 8006c26:	f8df 8098 	ldr.w	r8, [pc, #152]	; 8006cc0 <initialise_monitor_handles+0xbc>
 8006c2a:	4623      	mov	r3, r4
 8006c2c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8006c30:	4c1f      	ldr	r4, [pc, #124]	; (8006cb0 <initialise_monitor_handles+0xac>)
 8006c32:	f8c8 5000 	str.w	r5, [r8]
 8006c36:	f844 2033 	str.w	r2, [r4, r3, lsl #3]
 8006c3a:	3301      	adds	r3, #1
 8006c3c:	2b14      	cmp	r3, #20
 8006c3e:	d1fa      	bne.n	8006c36 <initialise_monitor_handles+0x32>
 8006c40:	4d1c      	ldr	r5, [pc, #112]	; (8006cb4 <initialise_monitor_handles+0xb0>)
 8006c42:	f7ff ffd3 	bl	8006bec <_has_ext_stdout_stderr>
 8006c46:	b1d0      	cbz	r0, 8006c7e <initialise_monitor_handles+0x7a>
 8006c48:	f04f 0a03 	mov.w	sl, #3
 8006c4c:	2304      	movs	r3, #4
 8006c4e:	f8cd 9004 	str.w	r9, [sp, #4]
 8006c52:	2601      	movs	r6, #1
 8006c54:	f8cd a00c 	str.w	sl, [sp, #12]
 8006c58:	9302      	str	r3, [sp, #8]
 8006c5a:	4630      	mov	r0, r6
 8006c5c:	4639      	mov	r1, r7
 8006c5e:	beab      	bkpt	0x00ab
 8006c60:	4683      	mov	fp, r0
 8006c62:	4b15      	ldr	r3, [pc, #84]	; (8006cb8 <initialise_monitor_handles+0xb4>)
 8006c64:	f8cd 9004 	str.w	r9, [sp, #4]
 8006c68:	f8c3 b000 	str.w	fp, [r3]
 8006c6c:	2308      	movs	r3, #8
 8006c6e:	f8cd a00c 	str.w	sl, [sp, #12]
 8006c72:	9302      	str	r3, [sp, #8]
 8006c74:	4630      	mov	r0, r6
 8006c76:	4639      	mov	r1, r7
 8006c78:	beab      	bkpt	0x00ab
 8006c7a:	4606      	mov	r6, r0
 8006c7c:	602e      	str	r6, [r5, #0]
 8006c7e:	682b      	ldr	r3, [r5, #0]
 8006c80:	2600      	movs	r6, #0
 8006c82:	3301      	adds	r3, #1
 8006c84:	6066      	str	r6, [r4, #4]
 8006c86:	bf02      	ittt	eq
 8006c88:	4b0b      	ldreq	r3, [pc, #44]	; (8006cb8 <initialise_monitor_handles+0xb4>)
 8006c8a:	681b      	ldreq	r3, [r3, #0]
 8006c8c:	602b      	streq	r3, [r5, #0]
 8006c8e:	f8d8 3000 	ldr.w	r3, [r8]
 8006c92:	6023      	str	r3, [r4, #0]
 8006c94:	f7ff ffaa 	bl	8006bec <_has_ext_stdout_stderr>
 8006c98:	b130      	cbz	r0, 8006ca8 <initialise_monitor_handles+0xa4>
 8006c9a:	4b07      	ldr	r3, [pc, #28]	; (8006cb8 <initialise_monitor_handles+0xb4>)
 8006c9c:	681b      	ldr	r3, [r3, #0]
 8006c9e:	e9c4 3602 	strd	r3, r6, [r4, #8]
 8006ca2:	682b      	ldr	r3, [r5, #0]
 8006ca4:	e9c4 3604 	strd	r3, r6, [r4, #16]
 8006ca8:	b005      	add	sp, #20
 8006caa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006cae:	bf00      	nop
 8006cb0:	20001270 	.word	0x20001270
 8006cb4:	20001264 	.word	0x20001264
 8006cb8:	2000126c 	.word	0x2000126c
 8006cbc:	08006f35 	.word	0x08006f35
 8006cc0:	20001268 	.word	0x20001268

08006cc4 <_isatty>:
 8006cc4:	b570      	push	{r4, r5, r6, lr}
 8006cc6:	f7ff fd77 	bl	80067b8 <findslot>
 8006cca:	2509      	movs	r5, #9
 8006ccc:	4604      	mov	r4, r0
 8006cce:	b920      	cbnz	r0, 8006cda <_isatty+0x16>
 8006cd0:	f7fe ff0c 	bl	8005aec <__errno>
 8006cd4:	6005      	str	r5, [r0, #0]
 8006cd6:	4620      	mov	r0, r4
 8006cd8:	bd70      	pop	{r4, r5, r6, pc}
 8006cda:	4628      	mov	r0, r5
 8006cdc:	4621      	mov	r1, r4
 8006cde:	beab      	bkpt	0x00ab
 8006ce0:	4604      	mov	r4, r0
 8006ce2:	2c01      	cmp	r4, #1
 8006ce4:	d0f7      	beq.n	8006cd6 <_isatty+0x12>
 8006ce6:	f7fe ff01 	bl	8005aec <__errno>
 8006cea:	2400      	movs	r4, #0
 8006cec:	4605      	mov	r5, r0
 8006cee:	2613      	movs	r6, #19
 8006cf0:	4630      	mov	r0, r6
 8006cf2:	4621      	mov	r1, r4
 8006cf4:	beab      	bkpt	0x00ab
 8006cf6:	4606      	mov	r6, r0
 8006cf8:	602e      	str	r6, [r5, #0]
 8006cfa:	e7ec      	b.n	8006cd6 <_isatty+0x12>

08006cfc <_init>:
 8006cfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006cfe:	bf00      	nop
 8006d00:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006d02:	bc08      	pop	{r3}
 8006d04:	469e      	mov	lr, r3
 8006d06:	4770      	bx	lr

08006d08 <_fini>:
 8006d08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006d0a:	bf00      	nop
 8006d0c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006d0e:	bc08      	pop	{r3}
 8006d10:	469e      	mov	lr, r3
 8006d12:	4770      	bx	lr
